{"ast":null,"code":"var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar _SnowfallCanvas_ctx, _SnowfallCanvas_canvas;\n\nimport Snowflake, { defaultConfig } from './Snowflake.js';\nimport { targetFrameTime } from './config.js';\nexport class SnowfallCanvas {\n  get ctx() {\n    return __classPrivateFieldGet(this, _SnowfallCanvas_ctx, \"f\");\n  }\n\n  get canvas() {\n    return __classPrivateFieldGet(this, _SnowfallCanvas_canvas, \"f\");\n  }\n\n  set canvas(canvas) {\n    __classPrivateFieldSet(this, _SnowfallCanvas_canvas, canvas, \"f\");\n\n    __classPrivateFieldSet(this, _SnowfallCanvas_ctx, canvas.getContext('2d'), \"f\");\n  }\n\n  constructor(canvas, config) {\n    this.lastUpdate = Date.now();\n    this.snowflakes = [];\n\n    _SnowfallCanvas_ctx.set(this, void 0);\n\n    _SnowfallCanvas_canvas.set(this, void 0);\n\n    __classPrivateFieldSet(this, _SnowfallCanvas_canvas, canvas, \"f\");\n\n    __classPrivateFieldSet(this, _SnowfallCanvas_ctx, canvas.getContext('2d'), \"f\");\n\n    this.config = {\n      snowflakeCount: 150,\n      ...defaultConfig,\n      ...config\n    };\n    this.snowflakes = [];\n    this.snowflakes = Snowflake.createSnowflakes(canvas, config.snowflakeCount || 150, config);\n    this.play();\n  }\n  /**\n   * Updates the config used for the snowfall animation, if the number of snowflakes\n   * has changed then this will create new or remove existing snowflakes gracefully\n   * to retain the position of as many existing snowflakes as possible.\n   */\n\n\n  updateConfig(config) {\n    this.config = { ...this.config,\n      ...config\n    };\n    const sizeDifference = this.config.snowflakeCount - this.snowflakes.length;\n\n    if (sizeDifference > 0) {\n      this.snowflakes = [...this.snowflakes, ...Snowflake.createSnowflakes(this.canvas, sizeDifference, config)];\n    }\n\n    if (sizeDifference < 0) {\n      this.snowflakes = this.snowflakes.slice(0, this.config.snowflakeCount);\n    }\n\n    for (const snowflake of this.snowflakes) {\n      snowflake.updateConfig(this.config);\n    }\n  }\n  /**\n   * Updates the location of each snowflake based on the number of frames passed then\n   * clears the canvas and draws each snowflake.\n   */\n\n\n  render() {\n    let framesPassed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    const {\n      ctx,\n      canvas,\n      snowflakes\n    } = this;\n    if (!ctx || !canvas) return;\n    const {\n      offsetWidth,\n      offsetHeight\n    } = canvas; // Update the position of each snowflake\n\n    for (const snowflake of snowflakes) {\n      snowflake.update(offsetWidth, offsetHeight, framesPassed);\n    } // Render the snowflakes\n\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, offsetWidth, offsetHeight); // If using images, draw each image individually\n\n    if (this.config.images && this.config.images.length > 0) {\n      for (const snowflake of snowflakes) {\n        snowflake.drawImage(ctx);\n      }\n\n      return;\n    } // Not using images\n    // If 3D rotation is enabled, draw each circle individually with transform\n\n\n    if (this.config.enable3DRotation) {\n      for (const snowflake of snowflakes) {\n        snowflake.drawCircle3D(ctx, this.config.color);\n      }\n    } else {\n      // Draw circles in a single path for better performance\n      ctx.beginPath();\n\n      for (const snowflake of snowflakes) {\n        snowflake.drawCircle(ctx);\n      }\n\n      ctx.fillStyle = this.config.color;\n      ctx.fill();\n    }\n  }\n  /**\n   * The animation loop, will calculate the time since the last render and update\n   * the position of the snowflakes appropriately before queueing another frame.\n   */\n\n\n  loop() {\n    // Update based on time passed so that a slow frame rate won't slow down the snowflake\n    const now = Date.now();\n    const msPassed = Date.now() - this.lastUpdate;\n    this.lastUpdate = now; // Frames that would have passed if running at 60 fps\n\n    const framesPassed = msPassed / targetFrameTime;\n    this.render(framesPassed);\n    this.animationFrame = requestAnimationFrame(() => this.loop());\n  }\n  /** Start the animation playing. */\n\n\n  play() {\n    this.loop();\n  }\n  /** Pause the animation. */\n\n\n  pause() {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = undefined;\n    }\n  }\n\n}\n_SnowfallCanvas_ctx = new WeakMap(), _SnowfallCanvas_canvas = new WeakMap();\nexport default SnowfallCanvas;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AAAA,OAAOA,SAAP,IAAqCC,aAArC,QAA0D,gBAA1D;AACA,SAASC,eAAT,QAAgC,aAAhC;AAWA,OAAM,MAAOC,cAAP,CAAqB;EAMlB,IAAHC,GAAG;IACL,OAAOC,6BAAIC,mBAAJ,EAAI,GAAJ,CAAP;EACD;;EAGS,IAANC,MAAM;IACR,OAAOF,6BAAIG,sBAAJ,EAAI,GAAJ,CAAP;EACD;;EACS,IAAND,MAAM,CAACA,MAAD,EAA0B;IAClCE,6BAAID,sBAAJ,EAAeD,MAAf,EAAqB,GAArB;;IACAE,6BAAIH,mBAAJ,EAAYC,MAAM,CAACG,UAAP,CAAkB,IAAlB,CAAZ,EAAmC,GAAnC;EACD;;EAEDC,YAAYJ,MAAZ,EAAuCK,MAAvC,EAA4E;IAlBpE,kBAAaC,IAAI,CAACC,GAAL,EAAb;IACA,kBAA0B,EAA1B;;IAGRR;;IAKAE;;IAUEC,6BAAID,sBAAJ,EAAeD,MAAf,EAAqB,GAArB;;IACAE,6BAAIH,mBAAJ,EAAYC,MAAM,CAACG,UAAP,CAAkB,IAAlB,CAAZ,EAAmC,GAAnC;;IACA,KAAKE,MAAL,GAAc;MAAEG,cAAc,EAAE,GAAlB;MAAuB,GAAGd,aAA1B;MAAyC,GAAGW;IAA5C,CAAd;IACA,KAAKI,UAAL,GAAkB,EAAlB;IACA,KAAKA,UAAL,GAAkBhB,SAAS,CAACiB,gBAAV,CAA2BV,MAA3B,EAAmCK,MAAM,CAACG,cAAP,IAAyB,GAA5D,EAAiEH,MAAjE,CAAlB;IACA,KAAKM,IAAL;EACD;EAED;;;;;;;EAKAC,YAAY,CAACP,MAAD,EAAsC;IAChD,KAAKA,MAAL,GAAc,EAAE,GAAG,KAAKA,MAAV;MAAkB,GAAGA;IAArB,CAAd;IAEA,MAAMQ,cAAc,GAAG,KAAKR,MAAL,CAAYG,cAAZ,GAA6B,KAAKC,UAAL,CAAgBK,MAApE;;IAEA,IAAID,cAAc,GAAG,CAArB,EAAwB;MACtB,KAAKJ,UAAL,GAAkB,CAAC,GAAG,KAAKA,UAAT,EAAqB,GAAGhB,SAAS,CAACiB,gBAAV,CAA2B,KAAKV,MAAhC,EAAwCa,cAAxC,EAAwDR,MAAxD,CAAxB,CAAlB;IACD;;IAED,IAAIQ,cAAc,GAAG,CAArB,EAAwB;MACtB,KAAKJ,UAAL,GAAkB,KAAKA,UAAL,CAAgBM,KAAhB,CAAsB,CAAtB,EAAyB,KAAKV,MAAL,CAAYG,cAArC,CAAlB;IACD;;IAED,KAAK,MAAMQ,SAAX,IAAwB,KAAKP,UAA7B,EAAyC;MACvCO,SAAS,CAACJ,YAAV,CAAuB,KAAKP,MAA5B;IACD;EACF;EAED;;;;;;EAIQY,MAAM,GAAiB;IAAA,IAAhBC,YAAgB,uEAAD,CAAC;IAC7B,MAAM;MAAErB,GAAF;MAAOG,MAAP;MAAeS;IAAf,IAA8B,IAApC;IAEA,IAAI,CAACZ,GAAD,IAAQ,CAACG,MAAb,EAAqB;IAErB,MAAM;MAAEmB,WAAF;MAAeC;IAAf,IAAgCpB,MAAtC,CAL6B,CAO7B;;IACA,KAAK,MAAMgB,SAAX,IAAwBP,UAAxB,EAAoC;MAClCO,SAAS,CAACK,MAAV,CAAiBF,WAAjB,EAA8BC,YAA9B,EAA4CF,YAA5C;IACD,CAV4B,CAY7B;;;IACArB,GAAG,CAACyB,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,EAAgC,CAAhC;IACAzB,GAAG,CAAC0B,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoBJ,WAApB,EAAiCC,YAAjC,EAd6B,CAgB7B;;IACA,IAAI,KAAKf,MAAL,CAAYmB,MAAZ,IAAsB,KAAKnB,MAAL,CAAYmB,MAAZ,CAAmBV,MAAnB,GAA4B,CAAtD,EAAyD;MACvD,KAAK,MAAME,SAAX,IAAwBP,UAAxB,EAAoC;QAClCO,SAAS,CAACS,SAAV,CAAoB5B,GAApB;MACD;;MACD;IACD,CAtB4B,CAwB7B;IACA;;;IACA,IAAI,KAAKQ,MAAL,CAAYqB,gBAAhB,EAAkC;MAChC,KAAK,MAAMV,SAAX,IAAwBP,UAAxB,EAAoC;QAClCO,SAAS,CAACW,YAAV,CAAuB9B,GAAvB,EAA4B,KAAKQ,MAAL,CAAYuB,KAAxC;MACD;IACF,CAJD,MAIO;MACL;MACA/B,GAAG,CAACgC,SAAJ;;MACA,KAAK,MAAMb,SAAX,IAAwBP,UAAxB,EAAoC;QAClCO,SAAS,CAACc,UAAV,CAAqBjC,GAArB;MACD;;MACDA,GAAG,CAACkC,SAAJ,GAAgB,KAAK1B,MAAL,CAAYuB,KAA5B;MACA/B,GAAG,CAACmC,IAAJ;IACD;EACF;EAID;;;;;;EAIQC,IAAI;IACV;IACA,MAAM1B,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;IACA,MAAM2B,QAAQ,GAAG5B,IAAI,CAACC,GAAL,KAAa,KAAK4B,UAAnC;IACA,KAAKA,UAAL,GAAkB5B,GAAlB,CAJU,CAMV;;IACA,MAAMW,YAAY,GAAGgB,QAAQ,GAAGvC,eAAhC;IAEA,KAAKsB,MAAL,CAAYC,YAAZ;IAEA,KAAKkB,cAAL,GAAsBC,qBAAqB,CAAC,MAAM,KAAKJ,IAAL,EAAP,CAA3C;EACD;EAED;;;EACAtB,IAAI;IACF,KAAKsB,IAAL;EACD;EAED;;;EACAK,KAAK;IACH,IAAI,KAAKF,cAAT,EAAyB;MACvBG,oBAAoB,CAAC,KAAKH,cAAN,CAApB;MACA,KAAKA,cAAL,GAAsBI,SAAtB;IACD;EACF;;AA/HwB;;AAkI3B,eAAe5C,cAAf","names":["Snowflake","defaultConfig","targetFrameTime","SnowfallCanvas","ctx","__classPrivateFieldGet","_SnowfallCanvas_ctx","canvas","_SnowfallCanvas_canvas","__classPrivateFieldSet","getContext","constructor","config","Date","now","snowflakeCount","snowflakes","createSnowflakes","play","updateConfig","sizeDifference","length","slice","snowflake","render","framesPassed","offsetWidth","offsetHeight","update","setTransform","clearRect","images","drawImage","enable3DRotation","drawCircle3D","color","beginPath","drawCircle","fillStyle","fill","loop","msPassed","lastUpdate","animationFrame","requestAnimationFrame","pause","cancelAnimationFrame","undefined"],"sources":["C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\react-snowfall\\src\\SnowfallCanvas.ts"],"sourcesContent":["import Snowflake, { SnowflakeConfig, defaultConfig } from './Snowflake.js'\r\nimport { targetFrameTime } from './config.js'\r\n\r\nexport interface SnowfallCanvasConfig extends SnowflakeConfig {\r\n  /**\r\n   * The number of snowflakes to be rendered.\r\n   *\r\n   * The default value is 150.\r\n   */\r\n  snowflakeCount: number\r\n}\r\n\r\nexport class SnowfallCanvas {\r\n  private lastUpdate = Date.now()\r\n  private snowflakes: Snowflake[] = []\r\n  private config: SnowfallCanvasConfig\r\n\r\n  #ctx: CanvasRenderingContext2D | null\r\n  get ctx() {\r\n    return this.#ctx\r\n  }\r\n\r\n  #canvas: HTMLCanvasElement\r\n  get canvas() {\r\n    return this.#canvas\r\n  }\r\n  set canvas(canvas: HTMLCanvasElement) {\r\n    this.#canvas = canvas\r\n    this.#ctx = canvas.getContext('2d')\r\n  }\r\n\r\n  constructor(canvas: HTMLCanvasElement, config: Partial<SnowfallCanvasConfig>) {\r\n    this.#canvas = canvas\r\n    this.#ctx = canvas.getContext('2d')\r\n    this.config = { snowflakeCount: 150, ...defaultConfig, ...config }\r\n    this.snowflakes = []\r\n    this.snowflakes = Snowflake.createSnowflakes(canvas, config.snowflakeCount || 150, config)\r\n    this.play()\r\n  }\r\n\r\n  /**\r\n   * Updates the config used for the snowfall animation, if the number of snowflakes\r\n   * has changed then this will create new or remove existing snowflakes gracefully\r\n   * to retain the position of as many existing snowflakes as possible.\r\n   */\r\n  updateConfig(config: Partial<SnowfallCanvasConfig>) {\r\n    this.config = { ...this.config, ...config }\r\n\r\n    const sizeDifference = this.config.snowflakeCount - this.snowflakes.length\r\n\r\n    if (sizeDifference > 0) {\r\n      this.snowflakes = [...this.snowflakes, ...Snowflake.createSnowflakes(this.canvas, sizeDifference, config)]\r\n    }\r\n\r\n    if (sizeDifference < 0) {\r\n      this.snowflakes = this.snowflakes.slice(0, this.config.snowflakeCount)\r\n    }\r\n\r\n    for (const snowflake of this.snowflakes) {\r\n      snowflake.updateConfig(this.config)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the location of each snowflake based on the number of frames passed then\r\n   * clears the canvas and draws each snowflake.\r\n   */\r\n  private render(framesPassed = 1) {\r\n    const { ctx, canvas, snowflakes } = this\r\n\r\n    if (!ctx || !canvas) return\r\n\r\n    const { offsetWidth, offsetHeight } = canvas\r\n\r\n    // Update the position of each snowflake\r\n    for (const snowflake of snowflakes) {\r\n      snowflake.update(offsetWidth, offsetHeight, framesPassed)\r\n    }\r\n\r\n    // Render the snowflakes\r\n    ctx.setTransform(1, 0, 0, 1, 0, 0)\r\n    ctx.clearRect(0, 0, offsetWidth, offsetHeight)\r\n\r\n    // If using images, draw each image individually\r\n    if (this.config.images && this.config.images.length > 0) {\r\n      for (const snowflake of snowflakes) {\r\n        snowflake.drawImage(ctx)\r\n      }\r\n      return\r\n    }\r\n\r\n    // Not using images\r\n    // If 3D rotation is enabled, draw each circle individually with transform\r\n    if (this.config.enable3DRotation) {\r\n      for (const snowflake of snowflakes) {\r\n        snowflake.drawCircle3D(ctx, this.config.color!)\r\n      }\r\n    } else {\r\n      // Draw circles in a single path for better performance\r\n      ctx.beginPath()\r\n      for (const snowflake of snowflakes) {\r\n        snowflake.drawCircle(ctx)\r\n      }\r\n      ctx.fillStyle = this.config.color!\r\n      ctx.fill()\r\n    }\r\n  }\r\n\r\n  private animationFrame: number | undefined\r\n\r\n  /**\r\n   * The animation loop, will calculate the time since the last render and update\r\n   * the position of the snowflakes appropriately before queueing another frame.\r\n   */\r\n  private loop() {\r\n    // Update based on time passed so that a slow frame rate won't slow down the snowflake\r\n    const now = Date.now()\r\n    const msPassed = Date.now() - this.lastUpdate\r\n    this.lastUpdate = now\r\n\r\n    // Frames that would have passed if running at 60 fps\r\n    const framesPassed = msPassed / targetFrameTime\r\n\r\n    this.render(framesPassed)\r\n\r\n    this.animationFrame = requestAnimationFrame(() => this.loop())\r\n  }\r\n\r\n  /** Start the animation playing. */\r\n  play() {\r\n    this.loop()\r\n  }\r\n\r\n  /** Pause the animation. */\r\n  pause() {\r\n    if (this.animationFrame) {\r\n      cancelAnimationFrame(this.animationFrame)\r\n      this.animationFrame = undefined\r\n    }\r\n  }\r\n}\r\n\r\nexport default SnowfallCanvas\r\n"]},"metadata":{},"sourceType":"module"}