{"ast":null,"code":"var _excluded = [\"id\"],\n    _excluded2 = [\"activeDot\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"fill\", \"fillOpacity\", \"hide\", \"isAnimationActive\", \"legendType\", \"stroke\", \"xAxisId\", \"yAxisId\"];\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n\n  var o,\n      r,\n      i = _objectWithoutPropertiesLoose(e, t);\n\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n\n  return i;\n}\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n\n  return t;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n\n  return t;\n}\n\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === r ? String : Number)(t);\n}\n\nimport * as React from 'react';\nimport { PureComponent, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Curve } from '../shape/Curve';\nimport { Layer } from '../container/Layer';\nimport { CartesianLabelListContextProvider, LabelListFromLabelProp } from '../component/LabelList';\nimport { Dots } from '../component/Dots';\nimport { Global } from '../util/Global';\nimport { interpolate, isNan, isNullish, isNumber, noop } from '../util/DataUtils';\nimport { getCateCoordinateOfLine, getNormalizedStackId, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { isClipDot } from '../util/ReactUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { selectArea } from '../state/selectors/areaSelectors';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { useCartesianChartLayout, useChartLayout } from '../context/chartLayoutContext';\nimport { useChartName } from '../state/selectors/selectors';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAppSelector } from '../state/hooks';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { isWellBehavedNumber } from '../util/isWellBehavedNumber';\nimport { usePlotArea } from '../hooks';\nimport { RegisterGraphicalItemId } from '../context/RegisterGraphicalItemId';\nimport { SetCartesianGraphicalItem } from '../state/SetGraphicalItem';\nimport { svgPropertiesNoEvents } from '../util/svgPropertiesNoEvents';\nimport { JavascriptAnimate } from '../animation/JavascriptAnimate';\nimport { getRadiusAndStrokeWidthFromDot } from '../util/getRadiusAndStrokeWidthFromDot';\nimport { svgPropertiesAndEvents } from '../util/svgPropertiesAndEvents';\nimport { ZIndexLayer } from '../zIndex/ZIndexLayer';\nimport { DefaultZIndexes } from '../zIndex/DefaultZIndexes';\nimport { propsAreEqual } from '../util/propsAreEqual';\n/**\n * @inline\n */\n\n/**\n * Our base value array has payload in it, and we expose it externally too.\n */\n\n/**\n * Internal props, combination of external props + defaultProps + private Recharts state\n */\n\n/**\n * External props, intended for end users to fill in\n */\n\n/**\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\n */\n\nfunction getLegendItemColor(stroke, fill) {\n  return stroke && stroke !== 'none' ? stroke : fill;\n}\n\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    fill,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: getLegendItemColor(stroke, fill),\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\n\nvar SetAreaTooltipEntrySettings = /*#__PURE__*/React.memo(_ref => {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit,\n    tooltipType,\n    id\n  } = _ref;\n  var tooltipEntrySettings = {\n    dataDefinedOnItem: data,\n    getPosition: noop,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: tooltipType,\n      color: getLegendItemColor(stroke, fill),\n      unit,\n      graphicalItemId: id\n    }\n  };\n  return /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n    tooltipEntrySettings: tooltipEntrySettings\n  });\n});\n\nfunction AreaDotsWrapper(_ref2) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref2;\n  var {\n    needClip,\n    dot,\n    dataKey\n  } = props;\n  var areaProps = svgPropertiesNoEvents(props);\n  return /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    dot: dot,\n    className: \"recharts-area-dots\",\n    dotClassName: \"recharts-area-dot\",\n    dataKey: dataKey,\n    baseProps: areaProps,\n    needClip: needClip,\n    clipPathId: clipPathId\n  });\n}\n\nfunction AreaLabelListProvider(_ref3) {\n  var {\n    showLabels,\n    children,\n    points\n  } = _ref3;\n  var labelListEntries = points.map(point => {\n    var _point$x, _point$y;\n\n    var viewBox = {\n      x: (_point$x = point.x) !== null && _point$x !== void 0 ? _point$x : 0,\n      y: (_point$y = point.y) !== null && _point$y !== void 0 ? _point$y : 0,\n      width: 0,\n      lowerWidth: 0,\n      upperWidth: 0,\n      height: 0\n    };\n    return _objectSpread(_objectSpread({}, viewBox), {}, {\n      value: point.value,\n      payload: point.payload,\n      parentViewBox: undefined,\n      viewBox,\n      fill: undefined\n    });\n  });\n  return /*#__PURE__*/React.createElement(CartesianLabelListContextProvider, {\n    value: showLabels ? labelListEntries : undefined\n  }, children);\n}\n\nfunction StaticArea(_ref4) {\n  var {\n    points,\n    baseLine,\n    needClip,\n    clipPathId,\n    props\n  } = _ref4;\n  var {\n    layout,\n    type,\n    stroke,\n    connectNulls,\n    isRange\n  } = props;\n\n  var {\n    id\n  } = props,\n      propsWithoutId = _objectWithoutProperties(props, _excluded);\n\n  var allOtherProps = svgPropertiesNoEvents(propsWithoutId);\n  var propsWithEvents = svgPropertiesAndEvents(propsWithoutId);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Layer, {\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : undefined\n  }, /*#__PURE__*/React.createElement(Curve, _extends({}, propsWithEvents, {\n    id: id,\n    points: points,\n    connectNulls: connectNulls,\n    type: type,\n    baseLine: baseLine,\n    layout: layout,\n    stroke: \"none\",\n    className: \"recharts-area-area\"\n  })), stroke !== 'none' && /*#__PURE__*/React.createElement(Curve, _extends({}, allOtherProps, {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: points\n  })), stroke !== 'none' && isRange && /*#__PURE__*/React.createElement(Curve, _extends({}, allOtherProps, {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: baseLine\n  }))), /*#__PURE__*/React.createElement(AreaDotsWrapper, {\n    points: points,\n    props: propsWithoutId,\n    clipPathId: clipPathId\n  }));\n}\n\nfunction VerticalRect(_ref5) {\n  var _points$, _points;\n\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref5;\n  var startY = (_points$ = points[0]) === null || _points$ === void 0 ? void 0 : _points$.y;\n  var endY = (_points = points[points.length - 1]) === null || _points === void 0 ? void 0 : _points.y;\n\n  if (!isWellBehavedNumber(startY) || !isWellBehavedNumber(endY)) {\n    return null;\n  }\n\n  var height = alpha * Math.abs(startY - endY);\n  var maxX = Math.max(...points.map(entry => entry.x || 0));\n\n  if (isNumber(baseLine)) {\n    maxX = Math.max(baseLine, maxX);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxX = Math.max(...baseLine.map(entry => entry.x || 0), maxX);\n  }\n\n  if (isNumber(maxX)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: 0,\n      y: startY < endY ? startY : startY - height,\n      width: maxX + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1),\n      height: Math.floor(height)\n    });\n  }\n\n  return null;\n}\n\nfunction HorizontalRect(_ref6) {\n  var _points$2, _points2;\n\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref6;\n  var startX = (_points$2 = points[0]) === null || _points$2 === void 0 ? void 0 : _points$2.x;\n  var endX = (_points2 = points[points.length - 1]) === null || _points2 === void 0 ? void 0 : _points2.x;\n\n  if (!isWellBehavedNumber(startX) || !isWellBehavedNumber(endX)) {\n    return null;\n  }\n\n  var width = alpha * Math.abs(startX - endX);\n  var maxY = Math.max(...points.map(entry => entry.y || 0));\n\n  if (isNumber(baseLine)) {\n    maxY = Math.max(baseLine, maxY);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxY = Math.max(...baseLine.map(entry => entry.y || 0), maxY);\n  }\n\n  if (isNumber(maxY)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: startX < endX ? startX : startX - width,\n      y: 0,\n      width: width,\n      height: Math.floor(maxY + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1))\n    });\n  }\n\n  return null;\n}\n\nfunction ClipRect(_ref7) {\n  var {\n    alpha,\n    layout,\n    points,\n    baseLine,\n    strokeWidth\n  } = _ref7;\n\n  if (layout === 'vertical') {\n    return /*#__PURE__*/React.createElement(VerticalRect, {\n      alpha: alpha,\n      points: points,\n      baseLine: baseLine,\n      strokeWidth: strokeWidth\n    });\n  }\n\n  return /*#__PURE__*/React.createElement(HorizontalRect, {\n    alpha: alpha,\n    points: points,\n    baseLine: baseLine,\n    strokeWidth: strokeWidth\n  });\n}\n\nfunction AreaWithAnimation(_ref8) {\n  var {\n    needClip,\n    clipPathId,\n    props,\n    previousPointsRef,\n    previousBaselineRef\n  } = _ref8;\n  var {\n    points,\n    baseLine,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    onAnimationStart,\n    onAnimationEnd\n  } = props;\n  var animationInput = useMemo(() => ({\n    points,\n    baseLine\n  }), [points, baseLine]);\n  var animationId = useAnimationId(animationInput, 'recharts-area-');\n  var layout = useCartesianChartLayout();\n  var [isAnimating, setIsAnimating] = useState(false);\n  var showLabels = !isAnimating;\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n\n  if (layout == null) {\n    return null;\n  }\n\n  var prevPoints = previousPointsRef.current;\n  var prevBaseLine = previousBaselineRef.current;\n  return /*#__PURE__*/React.createElement(AreaLabelListProvider, {\n    showLabels: showLabels,\n    points: points\n  }, props.children, /*#__PURE__*/React.createElement(JavascriptAnimate, {\n    animationId: animationId,\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, t => {\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepPoints =\n      /*\n       * Here it is important that at the very end of the animation, on the last frame,\n       * we render the original points without any interpolation.\n       * This is needed because the code above is checking for reference equality to decide if the animation should run\n       * and if we create a new array instance (even if the numbers were the same)\n       * then we would break animations.\n       */\n      t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(prev.x, entry.x, t),\n            y: interpolate(prev.y, entry.y, t)\n          });\n        }\n\n        return entry;\n      });\n      var stepBaseLine;\n\n      if (isNumber(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, baseLine, t);\n      } else if (isNullish(baseLine) || isNan(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, 0, t);\n      } else {\n        stepBaseLine = baseLine.map((entry, index) => {\n          var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n\n          if (Array.isArray(prevBaseLine) && prevBaseLine[prevPointIndex]) {\n            var prev = prevBaseLine[prevPointIndex];\n            return _objectSpread(_objectSpread({}, entry), {}, {\n              x: interpolate(prev.x, entry.x, t),\n              y: interpolate(prev.y, entry.y, t)\n            });\n          }\n\n          return entry;\n        });\n      }\n\n      if (t > 0) {\n        /*\n         * We need to keep the refs in the parent component because we need to remember the last shape of the animation\n         * even if AreaWithAnimation is unmounted as that happens when changing props.\n         *\n         * And we need to update the refs here because here is where the interpolation is computed.\n         * Eslint doesn't like changing function arguments, but we need it so here is an eslint-disable.\n         */\n        // eslint-disable-next-line no-param-reassign\n        previousPointsRef.current = stepPoints; // eslint-disable-next-line no-param-reassign\n\n        previousBaselineRef.current = stepBaseLine;\n      }\n\n      return /*#__PURE__*/React.createElement(StaticArea, {\n        points: stepPoints,\n        baseLine: stepBaseLine,\n        needClip: needClip,\n        clipPathId: clipPathId,\n        props: props\n      });\n    }\n\n    if (t > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points; // eslint-disable-next-line no-param-reassign\n\n      previousBaselineRef.current = baseLine;\n    }\n\n    return /*#__PURE__*/React.createElement(Layer, null, isAnimationActive && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"animationClipPath-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(ClipRect, {\n      alpha: t,\n      points: points,\n      baseLine: baseLine,\n      layout: layout,\n      strokeWidth: props.strokeWidth\n    }))), /*#__PURE__*/React.createElement(Layer, {\n      clipPath: \"url(#animationClipPath-\".concat(clipPathId, \")\")\n    }, /*#__PURE__*/React.createElement(StaticArea, {\n      points: points,\n      baseLine: baseLine,\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: props\n    })));\n  }), /*#__PURE__*/React.createElement(LabelListFromLabelProp, {\n    label: props.label\n  }));\n}\n/*\n * This components decides if the area should be animated or not.\n * It also holds the state of the animation.\n */\n\n\nfunction RenderArea(_ref9) {\n  var {\n    needClip,\n    clipPathId,\n    props\n  } = _ref9;\n  /*\n   * These two must be refs, not state!\n   * Because we want to store the most recent shape of the animation in case we have to interrupt the animation;\n   * that happens when user initiates another animation before the current one finishes.\n   *\n   * If this was a useState, then every step in the animation would trigger a re-render.\n   * So, useRef it is.\n   */\n\n  var previousPointsRef = useRef(null);\n  var previousBaselineRef = useRef();\n  return /*#__PURE__*/React.createElement(AreaWithAnimation, {\n    needClip: needClip,\n    clipPathId: clipPathId,\n    props: props,\n    previousPointsRef: previousPointsRef,\n    previousBaselineRef: previousBaselineRef\n  });\n}\n\nclass AreaWithState extends PureComponent {\n  render() {\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      top,\n      left,\n      needClip,\n      xAxisId,\n      yAxisId,\n      width,\n      height,\n      id,\n      baseLine,\n      zIndex\n    } = this.props;\n\n    if (hide) {\n      return null;\n    }\n\n    var layerClass = clsx('recharts-area', className);\n    var clipPathId = id;\n    var {\n      r,\n      strokeWidth\n    } = getRadiusAndStrokeWidthFromDot(dot);\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    var activePointsClipPath = needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : undefined;\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\n      zIndex: zIndex\n    }, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(RenderArea, {\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: this.props\n    })), /*#__PURE__*/React.createElement(ActivePoints, {\n      points: points,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot,\n      clipPath: activePointsClipPath\n    }), this.props.isRange && Array.isArray(baseLine) && /*#__PURE__*/React.createElement(ActivePoints, {\n      points: baseLine,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot,\n      clipPath: activePointsClipPath\n    }));\n  }\n\n}\n\nexport var defaultAreaProps = {\n  activeDot: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: false,\n  fill: '#3182bd',\n  fillOpacity: 0.6,\n  hide: false,\n  isAnimationActive: 'auto',\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  type: 'linear',\n  label: false,\n  xAxisId: 0,\n  yAxisId: 0,\n  zIndex: DefaultZIndexes.area\n};\n\nfunction AreaImpl(props) {\n  var _useAppSelector;\n\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultAreaProps),\n      {\n    activeDot,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    connectNulls,\n    dot,\n    fill,\n    fillOpacity,\n    hide,\n    isAnimationActive,\n    legendType,\n    stroke,\n    xAxisId,\n    yAxisId\n  } = _resolveDefaultProps,\n      everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded2);\n\n  var layout = useChartLayout();\n  var chartName = useChartName();\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var isPanorama = useIsPanorama();\n  var {\n    points,\n    isRange,\n    baseLine\n  } = (_useAppSelector = useAppSelector(state => selectArea(state, props.id, isPanorama))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};\n  var plotArea = usePlotArea();\n\n  if (layout !== 'horizontal' && layout !== 'vertical' || plotArea == null) {\n    // Can't render Area in an unsupported layout\n    return null;\n  }\n\n  if (chartName !== 'AreaChart' && chartName !== 'ComposedChart') {\n    // There is nothing stopping us from rendering Area in other charts, except for historical reasons. Do we want to allow that?\n    return null;\n  }\n\n  var {\n    height,\n    width,\n    x: left,\n    y: top\n  } = plotArea;\n\n  if (!points || !points.length) {\n    return null;\n  }\n\n  return /*#__PURE__*/React.createElement(AreaWithState, _extends({}, everythingElse, {\n    activeDot: activeDot,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    baseLine: baseLine,\n    connectNulls: connectNulls,\n    dot: dot,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    height: height,\n    hide: hide,\n    layout: layout,\n    isAnimationActive: isAnimationActive === 'auto' ? !Global.isSsr : isAnimationActive,\n    isRange: isRange,\n    legendType: legendType,\n    needClip: needClip,\n    points: points,\n    stroke: stroke,\n    width: width,\n    left: left,\n    top: top,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId\n  }));\n}\n\nexport var getBaseValue = (layout, chartBaseValue, itemBaseValue, xAxis, yAxis) => {\n  // The baseValue can be defined both on the AreaChart, and on the Area.\n  // The value for the item takes precedence.\n  var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;\n\n  if (isNumber(baseValue)) {\n    return baseValue;\n  }\n\n  var numericAxis = layout === 'horizontal' ? yAxis : xAxis; // @ts-expect-error d3scale .domain() returns unknown, Math.max expects number\n\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    var domainMax = Math.max(domain[0], domain[1]);\n    var domainMin = Math.min(domain[0], domain[1]);\n\n    if (baseValue === 'dataMin') {\n      return domainMin;\n    }\n\n    if (baseValue === 'dataMax') {\n      return domainMax;\n    }\n\n    return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);\n  }\n\n  if (baseValue === 'dataMin') {\n    return domain[0];\n  }\n\n  if (baseValue === 'dataMax') {\n    return domain[1];\n  }\n\n  return domain[0];\n};\nexport function computeArea(_ref0) {\n  var {\n    areaSettings: {\n      connectNulls,\n      baseValue: itemBaseValue,\n      dataKey\n    },\n    stackedData,\n    layout,\n    chartBaseValue,\n    xAxis,\n    yAxis,\n    displayedData,\n    dataStartIndex,\n    xAxisTicks,\n    yAxisTicks,\n    bandSize\n  } = _ref0;\n  var hasStack = stackedData && stackedData.length;\n  var baseValue = getBaseValue(layout, chartBaseValue, itemBaseValue, xAxis, yAxis);\n  var isHorizontalLayout = layout === 'horizontal';\n  var isRange = false;\n  var points = displayedData.map((entry, index) => {\n    var _valueAsArray$, _valueAsArray, _xAxis$scale$map;\n\n    var valueAsArray;\n\n    if (hasStack) {\n      valueAsArray = stackedData[dataStartIndex + index];\n    } else {\n      var rawValue = getValueByDataKey(entry, dataKey);\n\n      if (!Array.isArray(rawValue)) {\n        // @ts-expect-error getValueByDataKey is not checking its return value\n        valueAsArray = [baseValue, rawValue];\n      } else {\n        // @ts-expect-error getValueByDataKey is not checking its return value\n        valueAsArray = rawValue;\n        isRange = true;\n      }\n    }\n\n    var value1 = (_valueAsArray$ = (_valueAsArray = valueAsArray) === null || _valueAsArray === void 0 ? void 0 : _valueAsArray[1]) !== null && _valueAsArray$ !== void 0 ? _valueAsArray$ : null;\n    var isBreakPoint = value1 == null || hasStack && !connectNulls && getValueByDataKey(entry, dataKey) == null;\n\n    if (isHorizontalLayout) {\n      var _yAxis$scale$map;\n\n      return {\n        x: getCateCoordinateOfLine({\n          axis: xAxis,\n          ticks: xAxisTicks,\n          bandSize,\n          entry,\n          index\n        }),\n        y: isBreakPoint ? null : (_yAxis$scale$map = yAxis.scale.map(value1)) !== null && _yAxis$scale$map !== void 0 ? _yAxis$scale$map : null,\n        value: valueAsArray,\n        payload: entry\n      };\n    }\n\n    return {\n      x: isBreakPoint ? null : (_xAxis$scale$map = xAxis.scale.map(value1)) !== null && _xAxis$scale$map !== void 0 ? _xAxis$scale$map : null,\n      y: getCateCoordinateOfLine({\n        axis: yAxis,\n        ticks: yAxisTicks,\n        bandSize,\n        entry,\n        index\n      }),\n      value: valueAsArray,\n      payload: entry\n    };\n  });\n  var baseLine;\n\n  if (hasStack || isRange) {\n    baseLine = points.map(entry => {\n      var _xAxis$scale$map2;\n\n      var x = Array.isArray(entry.value) ? entry.value[0] : null;\n\n      if (isHorizontalLayout) {\n        var _yAxis$scale$map2;\n\n        return {\n          x: entry.x,\n          y: x != null && entry.y != null ? (_yAxis$scale$map2 = yAxis.scale.map(x)) !== null && _yAxis$scale$map2 !== void 0 ? _yAxis$scale$map2 : null : null,\n          payload: entry.payload\n        };\n      }\n\n      return {\n        x: x != null ? (_xAxis$scale$map2 = xAxis.scale.map(x)) !== null && _xAxis$scale$map2 !== void 0 ? _xAxis$scale$map2 : null : null,\n        y: entry.y,\n        payload: entry.payload\n      };\n    });\n  } else {\n    baseLine = isHorizontalLayout ? yAxis.scale.map(baseValue) : xAxis.scale.map(baseValue);\n  }\n\n  return {\n    points,\n    baseLine: baseLine !== null && baseLine !== void 0 ? baseLine : 0,\n    isRange\n  };\n}\n\nfunction AreaFn(outsideProps) {\n  var props = resolveDefaultProps(outsideProps, defaultAreaProps);\n  var isPanorama = useIsPanorama(); // Report all props to Redux store first, before calling any hooks, to avoid circular dependencies.\n\n  return /*#__PURE__*/React.createElement(RegisterGraphicalItemId, {\n    id: props.id,\n    type: \"area\"\n  }, id => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetLegendPayload, {\n    legendPayload: computeLegendPayloadFromAreaData(props)\n  }), /*#__PURE__*/React.createElement(SetAreaTooltipEntrySettings, {\n    dataKey: props.dataKey,\n    data: props.data,\n    stroke: props.stroke,\n    strokeWidth: props.strokeWidth,\n    fill: props.fill,\n    name: props.name,\n    hide: props.hide,\n    unit: props.unit,\n    tooltipType: props.tooltipType,\n    id: id\n  }), /*#__PURE__*/React.createElement(SetCartesianGraphicalItem, {\n    type: \"area\",\n    id: id,\n    data: props.data,\n    dataKey: props.dataKey,\n    xAxisId: props.xAxisId,\n    yAxisId: props.yAxisId,\n    zAxisId: 0,\n    stackId: getNormalizedStackId(props.stackId),\n    hide: props.hide,\n    barSize: undefined,\n    baseValue: props.baseValue,\n    isPanorama: isPanorama,\n    connectNulls: props.connectNulls\n  }), /*#__PURE__*/React.createElement(AreaImpl, _extends({}, props, {\n    id: id\n  }))));\n}\n/**\n * @provides LabelListContext\n * @consumes CartesianChartContext\n */\n\n\nexport var Area = /*#__PURE__*/React.memo(AreaFn, propsAreEqual);\nArea.displayName = 'Area';","map":{"version":3,"names":["_excluded","_excluded2","_extends","Object","assign","bind","n","e","arguments","length","t","r","hasOwnProperty","call","apply","_objectWithoutProperties","o","i","_objectWithoutPropertiesLoose","getOwnPropertySymbols","indexOf","propertyIsEnumerable","ownKeys","keys","filter","getOwnPropertyDescriptor","enumerable","push","_objectSpread","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","React","PureComponent","useCallback","useMemo","useRef","useState","clsx","Curve","Layer","CartesianLabelListContextProvider","LabelListFromLabelProp","Dots","Global","interpolate","isNan","isNullish","isNumber","noop","getCateCoordinateOfLine","getNormalizedStackId","getTooltipNameProp","getValueByDataKey","isClipDot","ActivePoints","SetTooltipEntrySettings","GraphicalItemClipPath","useNeedsClip","selectArea","useIsPanorama","useCartesianChartLayout","useChartLayout","useChartName","SetLegendPayload","useAppSelector","useAnimationId","resolveDefaultProps","isWellBehavedNumber","usePlotArea","RegisterGraphicalItemId","SetCartesianGraphicalItem","svgPropertiesNoEvents","JavascriptAnimate","getRadiusAndStrokeWidthFromDot","svgPropertiesAndEvents","ZIndexLayer","DefaultZIndexes","propsAreEqual","getLegendItemColor","stroke","fill","computeLegendPayloadFromAreaData","props","dataKey","name","legendType","hide","inactive","type","color","payload","SetAreaTooltipEntrySettings","memo","_ref","data","strokeWidth","unit","tooltipType","id","tooltipEntrySettings","dataDefinedOnItem","getPosition","settings","nameKey","undefined","graphicalItemId","createElement","AreaDotsWrapper","_ref2","clipPathId","points","needClip","dot","areaProps","className","dotClassName","baseProps","AreaLabelListProvider","_ref3","showLabels","children","labelListEntries","map","point","_point$x","_point$y","viewBox","x","y","width","lowerWidth","upperWidth","height","parentViewBox","StaticArea","_ref4","baseLine","layout","connectNulls","isRange","propsWithoutId","allOtherProps","propsWithEvents","Fragment","clipPath","concat","VerticalRect","_ref5","_points$","_points","alpha","startY","endY","Math","abs","maxX","max","entry","Array","isArray","parseInt","floor","HorizontalRect","_ref6","_points$2","_points2","startX","endX","maxY","ClipRect","_ref7","AreaWithAnimation","_ref8","previousPointsRef","previousBaselineRef","isAnimationActive","animationBegin","animationDuration","animationEasing","onAnimationStart","onAnimationEnd","animationInput","animationId","isAnimating","setIsAnimating","handleAnimationEnd","handleAnimationStart","prevPoints","current","prevBaseLine","begin","duration","isActive","easing","key","prevPointsDiffFactor","stepPoints","index","prevPointIndex","prev","stepBaseLine","label","RenderArea","_ref9","AreaWithState","render","top","left","xAxisId","yAxisId","zIndex","layerClass","clipDot","dotSize","activePointsClipPath","mainColor","itemDataKey","activeDot","defaultAreaProps","fillOpacity","area","AreaImpl","_useAppSelector","_resolveDefaultProps","everythingElse","chartName","isPanorama","state","plotArea","isSsr","getBaseValue","chartBaseValue","itemBaseValue","xAxis","yAxis","baseValue","numericAxis","domain","scale","domainMax","domainMin","min","computeArea","_ref0","areaSettings","stackedData","displayedData","dataStartIndex","xAxisTicks","yAxisTicks","bandSize","hasStack","isHorizontalLayout","_valueAsArray$","_valueAsArray","_xAxis$scale$map","valueAsArray","rawValue","value1","isBreakPoint","_yAxis$scale$map","axis","ticks","_xAxis$scale$map2","_yAxis$scale$map2","AreaFn","outsideProps","legendPayload","zAxisId","stackId","barSize","Area","displayName"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/cartesian/Area.js"],"sourcesContent":["var _excluded = [\"id\"],\n  _excluded2 = [\"activeDot\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"fill\", \"fillOpacity\", \"hide\", \"isAnimationActive\", \"legendType\", \"stroke\", \"xAxisId\", \"yAxisId\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport * as React from 'react';\nimport { PureComponent, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Curve } from '../shape/Curve';\nimport { Layer } from '../container/Layer';\nimport { CartesianLabelListContextProvider, LabelListFromLabelProp } from '../component/LabelList';\nimport { Dots } from '../component/Dots';\nimport { Global } from '../util/Global';\nimport { interpolate, isNan, isNullish, isNumber, noop } from '../util/DataUtils';\nimport { getCateCoordinateOfLine, getNormalizedStackId, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { isClipDot } from '../util/ReactUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { selectArea } from '../state/selectors/areaSelectors';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { useCartesianChartLayout, useChartLayout } from '../context/chartLayoutContext';\nimport { useChartName } from '../state/selectors/selectors';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAppSelector } from '../state/hooks';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { isWellBehavedNumber } from '../util/isWellBehavedNumber';\nimport { usePlotArea } from '../hooks';\nimport { RegisterGraphicalItemId } from '../context/RegisterGraphicalItemId';\nimport { SetCartesianGraphicalItem } from '../state/SetGraphicalItem';\nimport { svgPropertiesNoEvents } from '../util/svgPropertiesNoEvents';\nimport { JavascriptAnimate } from '../animation/JavascriptAnimate';\nimport { getRadiusAndStrokeWidthFromDot } from '../util/getRadiusAndStrokeWidthFromDot';\nimport { svgPropertiesAndEvents } from '../util/svgPropertiesAndEvents';\nimport { ZIndexLayer } from '../zIndex/ZIndexLayer';\nimport { DefaultZIndexes } from '../zIndex/DefaultZIndexes';\nimport { propsAreEqual } from '../util/propsAreEqual';\n\n/**\n * @inline\n */\n\n/**\n * Our base value array has payload in it, and we expose it externally too.\n */\n\n/**\n * Internal props, combination of external props + defaultProps + private Recharts state\n */\n\n/**\n * External props, intended for end users to fill in\n */\n\n/**\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\n */\n\nfunction getLegendItemColor(stroke, fill) {\n  return stroke && stroke !== 'none' ? stroke : fill;\n}\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    fill,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: getLegendItemColor(stroke, fill),\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\nvar SetAreaTooltipEntrySettings = /*#__PURE__*/React.memo(_ref => {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit,\n    tooltipType,\n    id\n  } = _ref;\n  var tooltipEntrySettings = {\n    dataDefinedOnItem: data,\n    getPosition: noop,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: tooltipType,\n      color: getLegendItemColor(stroke, fill),\n      unit,\n      graphicalItemId: id\n    }\n  };\n  return /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n    tooltipEntrySettings: tooltipEntrySettings\n  });\n});\nfunction AreaDotsWrapper(_ref2) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref2;\n  var {\n    needClip,\n    dot,\n    dataKey\n  } = props;\n  var areaProps = svgPropertiesNoEvents(props);\n  return /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    dot: dot,\n    className: \"recharts-area-dots\",\n    dotClassName: \"recharts-area-dot\",\n    dataKey: dataKey,\n    baseProps: areaProps,\n    needClip: needClip,\n    clipPathId: clipPathId\n  });\n}\nfunction AreaLabelListProvider(_ref3) {\n  var {\n    showLabels,\n    children,\n    points\n  } = _ref3;\n  var labelListEntries = points.map(point => {\n    var _point$x, _point$y;\n    var viewBox = {\n      x: (_point$x = point.x) !== null && _point$x !== void 0 ? _point$x : 0,\n      y: (_point$y = point.y) !== null && _point$y !== void 0 ? _point$y : 0,\n      width: 0,\n      lowerWidth: 0,\n      upperWidth: 0,\n      height: 0\n    };\n    return _objectSpread(_objectSpread({}, viewBox), {}, {\n      value: point.value,\n      payload: point.payload,\n      parentViewBox: undefined,\n      viewBox,\n      fill: undefined\n    });\n  });\n  return /*#__PURE__*/React.createElement(CartesianLabelListContextProvider, {\n    value: showLabels ? labelListEntries : undefined\n  }, children);\n}\nfunction StaticArea(_ref4) {\n  var {\n    points,\n    baseLine,\n    needClip,\n    clipPathId,\n    props\n  } = _ref4;\n  var {\n    layout,\n    type,\n    stroke,\n    connectNulls,\n    isRange\n  } = props;\n  var {\n      id\n    } = props,\n    propsWithoutId = _objectWithoutProperties(props, _excluded);\n  var allOtherProps = svgPropertiesNoEvents(propsWithoutId);\n  var propsWithEvents = svgPropertiesAndEvents(propsWithoutId);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Layer, {\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : undefined\n  }, /*#__PURE__*/React.createElement(Curve, _extends({}, propsWithEvents, {\n    id: id,\n    points: points,\n    connectNulls: connectNulls,\n    type: type,\n    baseLine: baseLine,\n    layout: layout,\n    stroke: \"none\",\n    className: \"recharts-area-area\"\n  })), stroke !== 'none' && /*#__PURE__*/React.createElement(Curve, _extends({}, allOtherProps, {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: points\n  })), stroke !== 'none' && isRange && /*#__PURE__*/React.createElement(Curve, _extends({}, allOtherProps, {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: baseLine\n  }))), /*#__PURE__*/React.createElement(AreaDotsWrapper, {\n    points: points,\n    props: propsWithoutId,\n    clipPathId: clipPathId\n  }));\n}\nfunction VerticalRect(_ref5) {\n  var _points$, _points;\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref5;\n  var startY = (_points$ = points[0]) === null || _points$ === void 0 ? void 0 : _points$.y;\n  var endY = (_points = points[points.length - 1]) === null || _points === void 0 ? void 0 : _points.y;\n  if (!isWellBehavedNumber(startY) || !isWellBehavedNumber(endY)) {\n    return null;\n  }\n  var height = alpha * Math.abs(startY - endY);\n  var maxX = Math.max(...points.map(entry => entry.x || 0));\n  if (isNumber(baseLine)) {\n    maxX = Math.max(baseLine, maxX);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxX = Math.max(...baseLine.map(entry => entry.x || 0), maxX);\n  }\n  if (isNumber(maxX)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: 0,\n      y: startY < endY ? startY : startY - height,\n      width: maxX + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1),\n      height: Math.floor(height)\n    });\n  }\n  return null;\n}\nfunction HorizontalRect(_ref6) {\n  var _points$2, _points2;\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref6;\n  var startX = (_points$2 = points[0]) === null || _points$2 === void 0 ? void 0 : _points$2.x;\n  var endX = (_points2 = points[points.length - 1]) === null || _points2 === void 0 ? void 0 : _points2.x;\n  if (!isWellBehavedNumber(startX) || !isWellBehavedNumber(endX)) {\n    return null;\n  }\n  var width = alpha * Math.abs(startX - endX);\n  var maxY = Math.max(...points.map(entry => entry.y || 0));\n  if (isNumber(baseLine)) {\n    maxY = Math.max(baseLine, maxY);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxY = Math.max(...baseLine.map(entry => entry.y || 0), maxY);\n  }\n  if (isNumber(maxY)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: startX < endX ? startX : startX - width,\n      y: 0,\n      width: width,\n      height: Math.floor(maxY + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1))\n    });\n  }\n  return null;\n}\nfunction ClipRect(_ref7) {\n  var {\n    alpha,\n    layout,\n    points,\n    baseLine,\n    strokeWidth\n  } = _ref7;\n  if (layout === 'vertical') {\n    return /*#__PURE__*/React.createElement(VerticalRect, {\n      alpha: alpha,\n      points: points,\n      baseLine: baseLine,\n      strokeWidth: strokeWidth\n    });\n  }\n  return /*#__PURE__*/React.createElement(HorizontalRect, {\n    alpha: alpha,\n    points: points,\n    baseLine: baseLine,\n    strokeWidth: strokeWidth\n  });\n}\nfunction AreaWithAnimation(_ref8) {\n  var {\n    needClip,\n    clipPathId,\n    props,\n    previousPointsRef,\n    previousBaselineRef\n  } = _ref8;\n  var {\n    points,\n    baseLine,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    onAnimationStart,\n    onAnimationEnd\n  } = props;\n  var animationInput = useMemo(() => ({\n    points,\n    baseLine\n  }), [points, baseLine]);\n  var animationId = useAnimationId(animationInput, 'recharts-area-');\n  var layout = useCartesianChartLayout();\n  var [isAnimating, setIsAnimating] = useState(false);\n  var showLabels = !isAnimating;\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  if (layout == null) {\n    return null;\n  }\n  var prevPoints = previousPointsRef.current;\n  var prevBaseLine = previousBaselineRef.current;\n  return /*#__PURE__*/React.createElement(AreaLabelListProvider, {\n    showLabels: showLabels,\n    points: points\n  }, props.children, /*#__PURE__*/React.createElement(JavascriptAnimate, {\n    animationId: animationId,\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, t => {\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepPoints =\n      /*\n       * Here it is important that at the very end of the animation, on the last frame,\n       * we render the original points without any interpolation.\n       * This is needed because the code above is checking for reference equality to decide if the animation should run\n       * and if we create a new array instance (even if the numbers were the same)\n       * then we would break animations.\n       */\n      t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(prev.x, entry.x, t),\n            y: interpolate(prev.y, entry.y, t)\n          });\n        }\n        return entry;\n      });\n      var stepBaseLine;\n      if (isNumber(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, baseLine, t);\n      } else if (isNullish(baseLine) || isNan(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, 0, t);\n      } else {\n        stepBaseLine = baseLine.map((entry, index) => {\n          var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n          if (Array.isArray(prevBaseLine) && prevBaseLine[prevPointIndex]) {\n            var prev = prevBaseLine[prevPointIndex];\n            return _objectSpread(_objectSpread({}, entry), {}, {\n              x: interpolate(prev.x, entry.x, t),\n              y: interpolate(prev.y, entry.y, t)\n            });\n          }\n          return entry;\n        });\n      }\n      if (t > 0) {\n        /*\n         * We need to keep the refs in the parent component because we need to remember the last shape of the animation\n         * even if AreaWithAnimation is unmounted as that happens when changing props.\n         *\n         * And we need to update the refs here because here is where the interpolation is computed.\n         * Eslint doesn't like changing function arguments, but we need it so here is an eslint-disable.\n         */\n        // eslint-disable-next-line no-param-reassign\n        previousPointsRef.current = stepPoints;\n        // eslint-disable-next-line no-param-reassign\n        previousBaselineRef.current = stepBaseLine;\n      }\n      return /*#__PURE__*/React.createElement(StaticArea, {\n        points: stepPoints,\n        baseLine: stepBaseLine,\n        needClip: needClip,\n        clipPathId: clipPathId,\n        props: props\n      });\n    }\n    if (t > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points;\n      // eslint-disable-next-line no-param-reassign\n      previousBaselineRef.current = baseLine;\n    }\n    return /*#__PURE__*/React.createElement(Layer, null, isAnimationActive && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"animationClipPath-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(ClipRect, {\n      alpha: t,\n      points: points,\n      baseLine: baseLine,\n      layout: layout,\n      strokeWidth: props.strokeWidth\n    }))), /*#__PURE__*/React.createElement(Layer, {\n      clipPath: \"url(#animationClipPath-\".concat(clipPathId, \")\")\n    }, /*#__PURE__*/React.createElement(StaticArea, {\n      points: points,\n      baseLine: baseLine,\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: props\n    })));\n  }), /*#__PURE__*/React.createElement(LabelListFromLabelProp, {\n    label: props.label\n  }));\n}\n\n/*\n * This components decides if the area should be animated or not.\n * It also holds the state of the animation.\n */\nfunction RenderArea(_ref9) {\n  var {\n    needClip,\n    clipPathId,\n    props\n  } = _ref9;\n  /*\n   * These two must be refs, not state!\n   * Because we want to store the most recent shape of the animation in case we have to interrupt the animation;\n   * that happens when user initiates another animation before the current one finishes.\n   *\n   * If this was a useState, then every step in the animation would trigger a re-render.\n   * So, useRef it is.\n   */\n  var previousPointsRef = useRef(null);\n  var previousBaselineRef = useRef();\n  return /*#__PURE__*/React.createElement(AreaWithAnimation, {\n    needClip: needClip,\n    clipPathId: clipPathId,\n    props: props,\n    previousPointsRef: previousPointsRef,\n    previousBaselineRef: previousBaselineRef\n  });\n}\nclass AreaWithState extends PureComponent {\n  render() {\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      top,\n      left,\n      needClip,\n      xAxisId,\n      yAxisId,\n      width,\n      height,\n      id,\n      baseLine,\n      zIndex\n    } = this.props;\n    if (hide) {\n      return null;\n    }\n    var layerClass = clsx('recharts-area', className);\n    var clipPathId = id;\n    var {\n      r,\n      strokeWidth\n    } = getRadiusAndStrokeWidthFromDot(dot);\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    var activePointsClipPath = needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : undefined;\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\n      zIndex: zIndex\n    }, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(RenderArea, {\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: this.props\n    })), /*#__PURE__*/React.createElement(ActivePoints, {\n      points: points,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot,\n      clipPath: activePointsClipPath\n    }), this.props.isRange && Array.isArray(baseLine) && /*#__PURE__*/React.createElement(ActivePoints, {\n      points: baseLine,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot,\n      clipPath: activePointsClipPath\n    }));\n  }\n}\nexport var defaultAreaProps = {\n  activeDot: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: false,\n  fill: '#3182bd',\n  fillOpacity: 0.6,\n  hide: false,\n  isAnimationActive: 'auto',\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  type: 'linear',\n  label: false,\n  xAxisId: 0,\n  yAxisId: 0,\n  zIndex: DefaultZIndexes.area\n};\nfunction AreaImpl(props) {\n  var _useAppSelector;\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultAreaProps),\n    {\n      activeDot,\n      animationBegin,\n      animationDuration,\n      animationEasing,\n      connectNulls,\n      dot,\n      fill,\n      fillOpacity,\n      hide,\n      isAnimationActive,\n      legendType,\n      stroke,\n      xAxisId,\n      yAxisId\n    } = _resolveDefaultProps,\n    everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded2);\n  var layout = useChartLayout();\n  var chartName = useChartName();\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var isPanorama = useIsPanorama();\n  var {\n    points,\n    isRange,\n    baseLine\n  } = (_useAppSelector = useAppSelector(state => selectArea(state, props.id, isPanorama))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};\n  var plotArea = usePlotArea();\n  if (layout !== 'horizontal' && layout !== 'vertical' || plotArea == null) {\n    // Can't render Area in an unsupported layout\n    return null;\n  }\n  if (chartName !== 'AreaChart' && chartName !== 'ComposedChart') {\n    // There is nothing stopping us from rendering Area in other charts, except for historical reasons. Do we want to allow that?\n    return null;\n  }\n  var {\n    height,\n    width,\n    x: left,\n    y: top\n  } = plotArea;\n  if (!points || !points.length) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(AreaWithState, _extends({}, everythingElse, {\n    activeDot: activeDot,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    baseLine: baseLine,\n    connectNulls: connectNulls,\n    dot: dot,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    height: height,\n    hide: hide,\n    layout: layout,\n    isAnimationActive: isAnimationActive === 'auto' ? !Global.isSsr : isAnimationActive,\n    isRange: isRange,\n    legendType: legendType,\n    needClip: needClip,\n    points: points,\n    stroke: stroke,\n    width: width,\n    left: left,\n    top: top,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId\n  }));\n}\nexport var getBaseValue = (layout, chartBaseValue, itemBaseValue, xAxis, yAxis) => {\n  // The baseValue can be defined both on the AreaChart, and on the Area.\n  // The value for the item takes precedence.\n  var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;\n  if (isNumber(baseValue)) {\n    return baseValue;\n  }\n  var numericAxis = layout === 'horizontal' ? yAxis : xAxis;\n  // @ts-expect-error d3scale .domain() returns unknown, Math.max expects number\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    var domainMax = Math.max(domain[0], domain[1]);\n    var domainMin = Math.min(domain[0], domain[1]);\n    if (baseValue === 'dataMin') {\n      return domainMin;\n    }\n    if (baseValue === 'dataMax') {\n      return domainMax;\n    }\n    return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);\n  }\n  if (baseValue === 'dataMin') {\n    return domain[0];\n  }\n  if (baseValue === 'dataMax') {\n    return domain[1];\n  }\n  return domain[0];\n};\nexport function computeArea(_ref0) {\n  var {\n    areaSettings: {\n      connectNulls,\n      baseValue: itemBaseValue,\n      dataKey\n    },\n    stackedData,\n    layout,\n    chartBaseValue,\n    xAxis,\n    yAxis,\n    displayedData,\n    dataStartIndex,\n    xAxisTicks,\n    yAxisTicks,\n    bandSize\n  } = _ref0;\n  var hasStack = stackedData && stackedData.length;\n  var baseValue = getBaseValue(layout, chartBaseValue, itemBaseValue, xAxis, yAxis);\n  var isHorizontalLayout = layout === 'horizontal';\n  var isRange = false;\n  var points = displayedData.map((entry, index) => {\n    var _valueAsArray$, _valueAsArray, _xAxis$scale$map;\n    var valueAsArray;\n    if (hasStack) {\n      valueAsArray = stackedData[dataStartIndex + index];\n    } else {\n      var rawValue = getValueByDataKey(entry, dataKey);\n      if (!Array.isArray(rawValue)) {\n        // @ts-expect-error getValueByDataKey is not checking its return value\n        valueAsArray = [baseValue, rawValue];\n      } else {\n        // @ts-expect-error getValueByDataKey is not checking its return value\n        valueAsArray = rawValue;\n        isRange = true;\n      }\n    }\n    var value1 = (_valueAsArray$ = (_valueAsArray = valueAsArray) === null || _valueAsArray === void 0 ? void 0 : _valueAsArray[1]) !== null && _valueAsArray$ !== void 0 ? _valueAsArray$ : null;\n    var isBreakPoint = value1 == null || hasStack && !connectNulls && getValueByDataKey(entry, dataKey) == null;\n    if (isHorizontalLayout) {\n      var _yAxis$scale$map;\n      return {\n        x: getCateCoordinateOfLine({\n          axis: xAxis,\n          ticks: xAxisTicks,\n          bandSize,\n          entry,\n          index\n        }),\n        y: isBreakPoint ? null : (_yAxis$scale$map = yAxis.scale.map(value1)) !== null && _yAxis$scale$map !== void 0 ? _yAxis$scale$map : null,\n        value: valueAsArray,\n        payload: entry\n      };\n    }\n    return {\n      x: isBreakPoint ? null : (_xAxis$scale$map = xAxis.scale.map(value1)) !== null && _xAxis$scale$map !== void 0 ? _xAxis$scale$map : null,\n      y: getCateCoordinateOfLine({\n        axis: yAxis,\n        ticks: yAxisTicks,\n        bandSize,\n        entry,\n        index\n      }),\n      value: valueAsArray,\n      payload: entry\n    };\n  });\n  var baseLine;\n  if (hasStack || isRange) {\n    baseLine = points.map(entry => {\n      var _xAxis$scale$map2;\n      var x = Array.isArray(entry.value) ? entry.value[0] : null;\n      if (isHorizontalLayout) {\n        var _yAxis$scale$map2;\n        return {\n          x: entry.x,\n          y: x != null && entry.y != null ? (_yAxis$scale$map2 = yAxis.scale.map(x)) !== null && _yAxis$scale$map2 !== void 0 ? _yAxis$scale$map2 : null : null,\n          payload: entry.payload\n        };\n      }\n      return {\n        x: x != null ? (_xAxis$scale$map2 = xAxis.scale.map(x)) !== null && _xAxis$scale$map2 !== void 0 ? _xAxis$scale$map2 : null : null,\n        y: entry.y,\n        payload: entry.payload\n      };\n    });\n  } else {\n    baseLine = isHorizontalLayout ? yAxis.scale.map(baseValue) : xAxis.scale.map(baseValue);\n  }\n  return {\n    points,\n    baseLine: baseLine !== null && baseLine !== void 0 ? baseLine : 0,\n    isRange\n  };\n}\nfunction AreaFn(outsideProps) {\n  var props = resolveDefaultProps(outsideProps, defaultAreaProps);\n  var isPanorama = useIsPanorama();\n  // Report all props to Redux store first, before calling any hooks, to avoid circular dependencies.\n  return /*#__PURE__*/React.createElement(RegisterGraphicalItemId, {\n    id: props.id,\n    type: \"area\"\n  }, id => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetLegendPayload, {\n    legendPayload: computeLegendPayloadFromAreaData(props)\n  }), /*#__PURE__*/React.createElement(SetAreaTooltipEntrySettings, {\n    dataKey: props.dataKey,\n    data: props.data,\n    stroke: props.stroke,\n    strokeWidth: props.strokeWidth,\n    fill: props.fill,\n    name: props.name,\n    hide: props.hide,\n    unit: props.unit,\n    tooltipType: props.tooltipType,\n    id: id\n  }), /*#__PURE__*/React.createElement(SetCartesianGraphicalItem, {\n    type: \"area\",\n    id: id,\n    data: props.data,\n    dataKey: props.dataKey,\n    xAxisId: props.xAxisId,\n    yAxisId: props.yAxisId,\n    zAxisId: 0,\n    stackId: getNormalizedStackId(props.stackId),\n    hide: props.hide,\n    barSize: undefined,\n    baseValue: props.baseValue,\n    isPanorama: isPanorama,\n    connectNulls: props.connectNulls\n  }), /*#__PURE__*/React.createElement(AreaImpl, _extends({}, props, {\n    id: id\n  }))));\n}\n\n/**\n * @provides LabelListContext\n * @consumes CartesianChartContext\n */\nexport var Area = /*#__PURE__*/React.memo(AreaFn, propsAreEqual);\nArea.displayName = 'Area';"],"mappings":"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"},"metadata":{},"sourceType":"module"}