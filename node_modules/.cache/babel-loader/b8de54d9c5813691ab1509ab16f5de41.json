{"ast":null,"code":"function ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n\n  return t;\n}\n\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === r ? String : Number)(t);\n}\n\nimport { createSelector } from 'reselect';\nimport range from 'es-toolkit/compat/range';\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { getDomainOfStackGroups, getStackedData, getValueByDataKey, isCategoricalAxis } from '../../util/ChartUtils';\nimport { selectChartDataWithIndexes, selectChartDataWithIndexesIfNotInPanoramaPosition4 } from './dataSelectors';\nimport { isWellFormedNumberDomain, numericalDomainSpecifiedWithoutRequiringData, parseNumericalUserDomain } from '../../util/isDomainSpecifiedByUser';\nimport { getPercentValue, hasDuplicate, isNan, isNotNil, isNumOrStr, mathSign, upperFirst } from '../../util/DataUtils';\nimport { isWellBehavedNumber } from '../../util/isWellBehavedNumber';\nimport { getNiceTickValues, getTickValuesFixedDomain } from '../../util/scale';\nimport { selectChartHeight, selectChartWidth } from './containerSelectors';\nimport { selectAllXAxes, selectAllYAxes } from './selectAllAxes';\nimport { selectChartOffsetInternal } from './selectChartOffsetInternal';\nimport { selectBrushDimensions, selectBrushSettings } from './brushSelectors';\nimport { selectBarCategoryGap, selectChartName, selectReverseStackOrder, selectStackOffsetType } from './rootPropsSelectors';\nimport { selectAngleAxis, selectAngleAxisRange, selectRadiusAxis, selectRadiusAxisRange } from './polarAxisSelectors';\nimport { pickAxisType } from './pickAxisType';\nimport { pickAxisId } from './pickAxisId';\nimport { combineAxisRangeWithReverse } from './combiners/combineAxisRangeWithReverse';\nimport { DEFAULT_Y_AXIS_WIDTH } from '../../util/Constants';\nimport { getStackSeriesIdentifier } from '../../util/stacks/getStackSeriesIdentifier';\nimport { combineDisplayedStackedData } from './combiners/combineDisplayedStackedData';\nimport { isStacked } from '../types/StackedGraphicalItem';\nimport { numberDomainEqualityCheck } from './numberDomainEqualityCheck';\nimport { emptyArraysAreEqualCheck } from './arrayEqualityCheck';\nimport { selectTooltipAxisType } from './selectTooltipAxisType';\nimport { selectTooltipAxisId } from './selectTooltipAxisId';\nimport { rechartsScaleFactory } from '../../util/scale/RechartsScale';\nimport { combineCheckedDomain } from './combiners/combineCheckedDomain';\nexport var defaultNumericDomain = [0, 'auto'];\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\n\nexport var implicitXAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: undefined,\n  height: 30,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'bottom',\n  padding: {\n    left: 0,\n    right: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'category',\n  unit: undefined\n};\nexport var selectXAxisSettingsNoDefaults = (state, axisId) => {\n  return state.cartesianAxis.xAxis[axisId];\n};\nexport var selectXAxisSettings = (state, axisId) => {\n  var axis = selectXAxisSettingsNoDefaults(state, axisId);\n\n  if (axis == null) {\n    return implicitXAxis;\n  }\n\n  return axis;\n};\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\n\nexport var implicitYAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: defaultNumericDomain,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'left',\n  padding: {\n    top: 0,\n    bottom: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'number',\n  unit: undefined,\n  width: DEFAULT_Y_AXIS_WIDTH\n};\nexport var selectYAxisSettingsNoDefaults = (state, axisId) => {\n  return state.cartesianAxis.yAxis[axisId];\n};\nexport var selectYAxisSettings = (state, axisId) => {\n  var axis = selectYAxisSettingsNoDefaults(state, axisId);\n\n  if (axis == null) {\n    return implicitYAxis;\n  }\n\n  return axis;\n};\nexport var implicitZAxis = {\n  domain: [0, 'auto'],\n  includeHidden: false,\n  reversed: false,\n  allowDataOverflow: false,\n  allowDuplicatedCategory: false,\n  dataKey: undefined,\n  id: 0,\n  name: '',\n  range: [64, 64],\n  scale: 'auto',\n  type: 'number',\n  unit: ''\n};\nexport var selectZAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.zAxis[axisId];\n\n  if (axis == null) {\n    return implicitZAxis;\n  }\n\n  return axis;\n};\nexport var selectBaseAxis = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n\n    case 'zAxis':\n      {\n        return selectZAxisSettings(state, axisId);\n      }\n\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\nvar selectCartesianAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n/**\n * Selects either an X or Y axis. Doesn't work with Z axis - for that, instead use selectBaseAxis.\n * @param state Root state\n * @param axisType xAxis | yAxis\n * @param axisId xAxisId | yAxisId\n * @returns axis settings object\n */\n\n\nexport var selectRenderableAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n/**\n * @param state RechartsRootState\n * @return boolean true if there is at least one Bar or RadialBar\n */\n\nexport var selectHasBar = state => state.graphicalItems.cartesianItems.some(item => item.type === 'bar') || state.graphicalItems.polarItems.some(item => item.type === 'radialBar');\n/**\n * Filters CartesianGraphicalItemSettings by the relevant axis ID\n * @param axisType 'xAxis' | 'yAxis' | 'zAxis' | 'radiusAxis' | 'angleAxis'\n * @param axisId from props, defaults to 0\n *\n * @returns Predicate function that return true for CartesianGraphicalItemSettings that are relevant to the specified axis\n */\n\nexport function itemAxisPredicate(axisType, axisId) {\n  return item => {\n    switch (axisType) {\n      case 'xAxis':\n        // This is sensitive to the data type, as 0 !== '0'. I wonder if we should be more flexible. How does 2.x branch behave? TODO write test for that\n        return 'xAxisId' in item && item.xAxisId === axisId;\n\n      case 'yAxis':\n        return 'yAxisId' in item && item.yAxisId === axisId;\n\n      case 'zAxis':\n        return 'zAxisId' in item && item.zAxisId === axisId;\n\n      case 'angleAxis':\n        return 'angleAxisId' in item && item.angleAxisId === axisId;\n\n      case 'radiusAxis':\n        return 'radiusAxisId' in item && item.radiusAxisId === axisId;\n\n      default:\n        return false;\n    }\n  };\n} // TODO appears there is a bug where this selector is called from polar context, find and fix it.\n\nexport var selectUnfilteredCartesianItems = state => state.graphicalItems.cartesianItems;\nvar selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);\nexport var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter(item => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {\n    return true;\n  }\n\n  return !item.hide;\n});\nexport var selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings, {\n  memoizeOptions: {\n    resultEqualityCheck: emptyArraysAreEqualCheck\n  }\n});\nexport var selectStackedCartesianItemsSettings = createSelector([selectCartesianItemsSettings], cartesianItems => {\n  return cartesianItems.filter(item => item.type === 'area' || item.type === 'bar').filter(isStacked);\n});\nexport var filterGraphicalNotStackedItems = cartesianItems => cartesianItems.filter(item => !('stackId' in item) || item.stackId === undefined);\nvar selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);\nexport var combineGraphicalItemsData = cartesianItems => cartesianItems.map(item => item.data).filter(Boolean).flat(1);\n/**\n * This is a \"cheap\" selector - it returns the data but doesn't iterate them, so it is not sensitive on the array length.\n * Also does not apply dataKey yet.\n * @param state RechartsRootState\n * @returns data defined on the chart graphical items, such as Line or Scatter or Pie, and filtered with appropriate dataKey\n */\n\nexport var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData, {\n  memoizeOptions: {\n    resultEqualityCheck: emptyArraysAreEqualCheck\n  }\n});\nexport var combineDisplayedData = (graphicalItemsData, _ref) => {\n  var {\n    chartData = [],\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n\n  if (graphicalItemsData.length > 0) {\n    /*\n     * There is no slicing when data is defined on graphical items. Why?\n     * Because Brush ignores data defined on graphical items,\n     * and does not render.\n     * So Brush will never show up in a Scatter chart for example.\n     * This is something we will need to fix.\n     *\n     * Now, when the root chart data is not defined, the dataEndIndex is 0,\n     * which means the itemsData will be sliced to an empty array anyway.\n     * But that's an implementation detail, and we can fix that too.\n     *\n     * Also, in absence of Axis dataKey, we use the dataKey from each item, respectively.\n     * This is the usual pattern for numerical axis, that is the one where bars go up:\n     * users don't specify any dataKey by default and expect the axis to \"just match the data\".\n     */\n    return graphicalItemsData;\n  }\n\n  return chartData.slice(dataStartIndex, dataEndIndex + 1);\n};\n/**\n * This selector will return all data there is in the chart: graphical items, chart root, all together.\n * Useful for figuring out an axis domain (because that needs to know of everything),\n * not useful for rendering individual graphical elements (because they need to know which data is theirs and which is not).\n *\n * This function will discard the original indexes, so it is also not useful for anything that depends on ordering.\n */\n\nexport var selectDisplayedData = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanoramaPosition4], combineDisplayedData);\nexport var combineAppliedValues = (data, axisSettings, items) => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    return data.map(item => ({\n      value: getValueByDataKey(item, axisSettings.dataKey)\n    }));\n  }\n\n  if (items.length > 0) {\n    return items.map(item => item.dataKey).flatMap(dataKey => data.map(entry => ({\n      value: getValueByDataKey(entry, dataKey)\n    })));\n  }\n\n  return data.map(entry => ({\n    value: entry\n  }));\n};\n/**\n * This selector will return all values with the appropriate dataKey applied on them.\n * Which dataKey is appropriate depends on where it is defined.\n *\n * This is an expensive selector - it will iterate all data and compute their value using the provided dataKey.\n */\n\nexport var selectAllAppliedValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);\nexport function isErrorBarRelevantForAxisType(axisType, errorBar) {\n  switch (axisType) {\n    case 'xAxis':\n      return errorBar.direction === 'x';\n\n    case 'yAxis':\n      return errorBar.direction === 'y';\n\n    default:\n      return false;\n  }\n}\n\nfunction makeNumber(val) {\n  if (isNumOrStr(val) || val instanceof Date) {\n    var n = Number(val);\n\n    if (isWellBehavedNumber(n)) {\n      return n;\n    }\n  }\n\n  return undefined;\n}\n\nfunction makeDomain(val) {\n  if (Array.isArray(val)) {\n    var attempt = [makeNumber(val[0]), makeNumber(val[1])];\n\n    if (isWellFormedNumberDomain(attempt)) {\n      return attempt;\n    }\n\n    return undefined;\n  }\n\n  var n = makeNumber(val);\n\n  if (n == null) {\n    return undefined;\n  }\n\n  return [n, n];\n}\n\nfunction onlyAllowNumbers(data) {\n  return data.map(makeNumber).filter(isNotNil);\n}\n/**\n * @param entry One item in the 'data' array. Could be anything really - this is defined externally. This is the raw, before dataKey application\n * @param appliedValue This is the result of applying the 'main' dataKey on the `entry`.\n * @param relevantErrorBars Error bars that are relevant for the current axis and layout and all that.\n * @return either undefined or an array of ErrorValue\n */\n\n\nexport function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {\n  if (!relevantErrorBars || typeof appliedValue !== 'number' || isNan(appliedValue)) {\n    return [];\n  }\n\n  if (!relevantErrorBars.length) {\n    return [];\n  }\n\n  return onlyAllowNumbers(relevantErrorBars.flatMap(eb => {\n    var errorValue = getValueByDataKey(entry, eb.dataKey);\n    var lowBound, highBound;\n\n    if (Array.isArray(errorValue)) {\n      [lowBound, highBound] = errorValue;\n    } else {\n      lowBound = highBound = errorValue;\n    }\n\n    if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {\n      return undefined;\n    }\n\n    return [appliedValue - lowBound, appliedValue + highBound];\n  }));\n}\nexport var selectTooltipAxis = state => {\n  var axisType = selectTooltipAxisType(state);\n  var axisId = selectTooltipAxisId(state);\n  return selectRenderableAxisSettings(state, axisType, axisId);\n};\nexport var selectTooltipAxisDataKey = createSelector([selectTooltipAxis], axis => axis === null || axis === void 0 ? void 0 : axis.dataKey);\nexport var selectDisplayedStackedData = createSelector([selectStackedCartesianItemsSettings, selectChartDataWithIndexesIfNotInPanoramaPosition4, selectTooltipAxis], combineDisplayedStackedData);\nexport var combineStackGroups = (displayedData, items, stackOffsetType, reverseStackOrder) => {\n  var initialItemsGroups = {};\n  var itemsGroup = items.reduce((acc, item) => {\n    if (item.stackId == null) {\n      return acc;\n    }\n\n    var stack = acc[item.stackId];\n\n    if (stack == null) {\n      stack = [];\n    }\n\n    stack.push(item);\n    acc[item.stackId] = stack;\n    return acc;\n  }, initialItemsGroups);\n  return Object.fromEntries(Object.entries(itemsGroup).map(_ref2 => {\n    var [stackId, graphicalItems] = _ref2;\n    var orderedGraphicalItems = reverseStackOrder ? [...graphicalItems].reverse() : graphicalItems;\n    var dataKeys = orderedGraphicalItems.map(getStackSeriesIdentifier);\n    return [stackId, {\n      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that\n      stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),\n      graphicalItems: orderedGraphicalItems\n    }];\n  }));\n};\n/**\n * Stack groups are groups of graphical items that stack on each other.\n * Stack is a function of axis type (X, Y), axis ID, and stack ID.\n * Graphical items that do not have a stack ID are not going to be present in stack groups.\n */\n\nexport var selectStackGroups = createSelector([selectDisplayedStackedData, selectStackedCartesianItemsSettings, selectStackOffsetType, selectReverseStackOrder], combineStackGroups);\nexport var combineDomainOfStackGroups = (stackGroups, _ref3, axisType, domainFromUserPreference) => {\n  var {\n    dataStartIndex,\n    dataEndIndex\n  } = _ref3;\n\n  if (domainFromUserPreference != null) {\n    // User has specified a domain, so we respect that and we can skip computing anything else\n    return undefined;\n  }\n\n  if (axisType === 'zAxis') {\n    // ZAxis ignores stacks\n    return undefined;\n  }\n\n  var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);\n\n  if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {\n    return undefined;\n  }\n\n  return domainOfStackGroups;\n};\nvar selectAllowsDataOverflow = createSelector([selectBaseAxis], axisSettings => axisSettings.allowDataOverflow);\nexport var getDomainDefinition = axisSettings => {\n  var _axisSettings$domain;\n\n  if (axisSettings == null || !('domain' in axisSettings)) {\n    return defaultNumericDomain;\n  }\n\n  if (axisSettings.domain != null) {\n    return axisSettings.domain;\n  }\n\n  if ('ticks' in axisSettings && axisSettings.ticks != null) {\n    if (axisSettings.type === 'number') {\n      var allValues = onlyAllowNumbers(axisSettings.ticks);\n      return [Math.min(...allValues), Math.max(...allValues)];\n    }\n\n    if (axisSettings.type === 'category') {\n      return axisSettings.ticks.map(String);\n    }\n  }\n\n  return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;\n};\nexport var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);\n/**\n * Under certain circumstances, we can determine the domain without looking at the data at all.\n * This is the case when the domain is explicitly specified as numbers, or when it is specified\n * as 'auto' or 'dataMin'/'dataMax' and data overflow is not allowed.\n *\n * In that case, this function will return the domain, otherwise it returns undefined.\n *\n * This is an optimization to avoid unnecessary data processing.\n * @param state\n * @param axisType\n * @param axisId\n * @param isPanorama\n */\n\nexport var selectDomainFromUserPreference = createSelector([selectDomainDefinition, selectAllowsDataOverflow], numericalDomainSpecifiedWithoutRequiringData);\nexport var selectDomainOfStackGroups = createSelector([selectStackGroups, selectChartDataWithIndexes, pickAxisType, selectDomainFromUserPreference], combineDomainOfStackGroups, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\nexport var selectAllErrorBarSettings = state => state.errorBars;\n\nvar combineRelevantErrorBarSettings = (cartesianItemsSettings, allErrorBarSettings, axisType) => {\n  return cartesianItemsSettings.flatMap(item => {\n    return allErrorBarSettings[item.id];\n  }).filter(Boolean).filter(e => {\n    return isErrorBarRelevantForAxisType(axisType, e);\n  });\n};\n\nexport var mergeDomains = function mergeDomains() {\n  for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {\n    domains[_key] = arguments[_key];\n  }\n\n  var allDomains = domains.filter(Boolean);\n\n  if (allDomains.length === 0) {\n    return undefined;\n  }\n\n  var allValues = allDomains.flat();\n  var min = Math.min(...allValues);\n  var max = Math.max(...allValues);\n  return [min, max];\n};\nexport var combineDomainOfAllAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, errorBars, axisType) => {\n  var lowerEnd, upperEnd;\n\n  if (items.length > 0) {\n    data.forEach(entry => {\n      items.forEach(item => {\n        var _errorBars$item$id, _axisSettings$dataKey;\n\n        var relevantErrorBars = (_errorBars$item$id = errorBars[item.id]) === null || _errorBars$item$id === void 0 ? void 0 : _errorBars$item$id.filter(errorBar => isErrorBarRelevantForAxisType(axisType, errorBar));\n        var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);\n        var errorDomain = getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars);\n\n        if (errorDomain.length >= 2) {\n          var localLower = Math.min(...errorDomain);\n          var localUpper = Math.max(...errorDomain);\n\n          if (lowerEnd == null || localLower < lowerEnd) {\n            lowerEnd = localLower;\n          }\n\n          if (upperEnd == null || localUpper > upperEnd) {\n            upperEnd = localUpper;\n          }\n        }\n\n        var dataValueDomain = makeDomain(valueByDataKey);\n\n        if (dataValueDomain != null) {\n          lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);\n          upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);\n        }\n      });\n    });\n  }\n\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    data.forEach(item => {\n      var dataValueDomain = makeDomain(getValueByDataKey(item, axisSettings.dataKey));\n\n      if (dataValueDomain != null) {\n        lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);\n        upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);\n      }\n    });\n  }\n\n  if (isWellBehavedNumber(lowerEnd) && isWellBehavedNumber(upperEnd)) {\n    return [lowerEnd, upperEnd];\n  }\n\n  return undefined;\n};\nvar selectDomainOfAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\n\nfunction onlyAllowNumbersAndStringsAndDates(item) {\n  var {\n    value\n  } = item;\n\n  if (isNumOrStr(value) || value instanceof Date) {\n    return value;\n  }\n\n  return undefined;\n}\n\nvar computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {\n  var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter(v => v != null);\n\n  if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {\n    /*\n     * 1. In an absence of dataKey, Recharts will use array indexes as its categorical domain\n     * 2. When category axis has duplicated text, serial numbers are used to generate scale\n     */\n    return range(0, allDataSquished.length);\n  }\n\n  if (axisSettings.allowDuplicatedCategory) {\n    return categoricalDomain;\n  }\n\n  return Array.from(new Set(categoricalDomain));\n};\n\nexport var selectReferenceDots = state => state.referenceElements.dots;\nexport var filterReferenceElements = (elements, axisType, axisId) => {\n  return elements.filter(el => el.ifOverflow === 'extendDomain').filter(el => {\n    if (axisType === 'xAxis') {\n      return el.xAxisId === axisId;\n    }\n\n    return el.yAxisId === axisId;\n  });\n};\nexport var selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceAreas = state => state.referenceElements.areas;\nexport var selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceLines = state => state.referenceElements.lines;\nexport var selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);\nexport var combineDotsDomain = (dots, axisType) => {\n  if (dots == null) {\n    return undefined;\n  }\n\n  var allCoords = onlyAllowNumbers(dots.map(dot => axisType === 'xAxis' ? dot.x : dot.y));\n\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);\nexport var combineAreasDomain = (areas, axisType) => {\n  if (areas == null) {\n    return undefined;\n  }\n\n  var allCoords = onlyAllowNumbers(areas.flatMap(area => [axisType === 'xAxis' ? area.x1 : area.y1, axisType === 'xAxis' ? area.x2 : area.y2]));\n\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);\n\nfunction extractXCoordinates(line) {\n  var _line$segment;\n\n  if (line.x != null) {\n    return onlyAllowNumbers([line.x]);\n  }\n\n  var segmentCoordinates = (_line$segment = line.segment) === null || _line$segment === void 0 ? void 0 : _line$segment.map(s => s.x);\n\n  if (segmentCoordinates == null || segmentCoordinates.length === 0) {\n    return [];\n  }\n\n  return onlyAllowNumbers(segmentCoordinates);\n}\n\nfunction extractYCoordinates(line) {\n  var _line$segment2;\n\n  if (line.y != null) {\n    return onlyAllowNumbers([line.y]);\n  }\n\n  var segmentCoordinates = (_line$segment2 = line.segment) === null || _line$segment2 === void 0 ? void 0 : _line$segment2.map(s => s.y);\n\n  if (segmentCoordinates == null || segmentCoordinates.length === 0) {\n    return [];\n  }\n\n  return onlyAllowNumbers(segmentCoordinates);\n}\n\nexport var combineLinesDomain = (lines, axisType) => {\n  if (lines == null) {\n    return undefined;\n  }\n\n  var allCoords = lines.flatMap(line => axisType === 'xAxis' ? extractXCoordinates(line) : extractYCoordinates(line));\n\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceLinesDomain = createSelector([selectReferenceLinesByAxis, pickAxisType], combineLinesDomain);\nvar selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {\n  return mergeDomains(dotsDomain, areasDomain, linesDomain);\n});\nexport var combineNumericalDomain = (axisSettings, domainDefinition, domainFromUserPreference, domainOfStackGroups, dataAndErrorBarsDomain, referenceElementsDomain, layout, axisType) => {\n  if (domainFromUserPreference != null) {\n    // We're done! No need to compute anything else.\n    return domainFromUserPreference;\n  }\n\n  var shouldIncludeDomainOfStackGroups = layout === 'vertical' && axisType === 'xAxis' || layout === 'horizontal' && axisType === 'yAxis';\n  var mergedDomains = shouldIncludeDomainOfStackGroups ? mergeDomains(domainOfStackGroups, referenceElementsDomain, dataAndErrorBarsDomain) : mergeDomains(referenceElementsDomain, dataAndErrorBarsDomain);\n  return parseNumericalUserDomain(domainDefinition, mergedDomains, axisSettings.allowDataOverflow);\n};\nexport var selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainFromUserPreference, selectDomainOfStackGroups, selectDomainOfAllAppliedNumericalValuesIncludingErrorValues, selectReferenceElementsDomain, selectChartLayout, pickAxisType], combineNumericalDomain, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\n/**\n * Expand by design maps everything between 0 and 1,\n * there is nothing to compute.\n * See https://d3js.org/d3-shape/stack#stack-offsets\n */\n\nvar expandDomain = [0, 1];\nexport var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {\n  if ((axisSettings == null || displayedData == null || displayedData.length === 0) && numericalDomain === undefined) {\n    return undefined;\n  }\n\n  var {\n    dataKey,\n    type\n  } = axisSettings;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n\n  if (isCategorical && dataKey == null) {\n    var _displayedData$length;\n\n    return range(0, (_displayedData$length = displayedData === null || displayedData === void 0 ? void 0 : displayedData.length) !== null && _displayedData$length !== void 0 ? _displayedData$length : 0);\n  }\n\n  if (type === 'category') {\n    return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);\n  }\n\n  if (stackOffsetType === 'expand') {\n    return expandDomain;\n  }\n\n  return numericalDomain;\n};\nexport var selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);\n\nfunction isSupportedScaleName(name) {\n  return name in d3Scales;\n}\n\nexport var combineRealScaleType = (axisConfig, hasBar, chartType) => {\n  if (axisConfig == null) {\n    return undefined;\n  }\n\n  var {\n    scale,\n    type\n  } = axisConfig;\n\n  if (scale === 'auto') {\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return 'point';\n    }\n\n    if (type === 'category') {\n      return 'band';\n    }\n\n    return 'linear';\n  }\n\n  if (typeof scale === 'string') {\n    var name = \"scale\".concat(upperFirst(scale));\n    return isSupportedScaleName(name) ? name : 'point';\n  }\n\n  return undefined;\n};\nexport var selectRealScaleType = createSelector([selectBaseAxis, selectHasBar, selectChartName], combineRealScaleType);\nexport function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {\n  if (axisDomain == null || axisRange == null) {\n    return undefined;\n  }\n\n  if (typeof axis.scale === 'function') {\n    return rechartsScaleFactory(axis.scale, axisDomain, axisRange);\n  }\n\n  return rechartsScaleFactory(realScaleType, axisDomain, axisRange);\n}\nexport var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {\n  var domainDefinition = getDomainDefinition(axisSettings);\n\n  if (realScaleType !== 'auto' && realScaleType !== 'linear') {\n    return undefined;\n  }\n\n  if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === 'auto' || domainDefinition[1] === 'auto') && isWellFormedNumberDomain(axisDomain)) {\n    return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n\n  if (axisSettings != null && axisSettings.tickCount && axisSettings.type === 'number' && isWellFormedNumberDomain(axisDomain)) {\n    return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n\n  return undefined;\n};\nexport var selectNiceTicks = createSelector([selectAxisDomain, selectRenderableAxisSettings, selectRealScaleType], combineNiceTicks);\nexport var combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {\n  if (\n  /*\n   * Angle axis for some reason uses nice ticks when rendering axis tick labels,\n   * but doesn't use nice ticks for extending domain like all the other axes do.\n   * Not really sure why? Is there a good reason,\n   * or is it just because someone added support for nice ticks to the other axes and forgot this one?\n   */\n  axisType !== 'angleAxis' && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === 'number' && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0) {\n    var _niceTicks$, _niceTicks;\n\n    var minFromDomain = domain[0];\n    var minFromTicks = (_niceTicks$ = niceTicks[0]) !== null && _niceTicks$ !== void 0 ? _niceTicks$ : 0;\n    var maxFromDomain = domain[1];\n    var maxFromTicks = (_niceTicks = niceTicks[niceTicks.length - 1]) !== null && _niceTicks !== void 0 ? _niceTicks : 0;\n    return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];\n  }\n\n  return domain;\n};\nexport var selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);\n/**\n * Returns the smallest gap, between two numbers in the data, as a ratio of the whole range (max - min).\n * Ignores domain provided by user and only considers domain from data.\n *\n * The result is a number between 0 and 1.\n */\n\nexport var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {\n  if (!axisSettings || axisSettings.type !== 'number') {\n    return undefined;\n  }\n\n  var smallestDistanceBetweenValues = Infinity;\n  var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map(d => d.value))).sort((a, b) => a - b);\n  var first = sortedValues[0];\n  var last = sortedValues[sortedValues.length - 1];\n\n  if (first == null || last == null) {\n    return Infinity;\n  }\n\n  var diff = last - first;\n\n  if (diff === 0) {\n    return Infinity;\n  } // Only do n - 1 distance calculations because there's only n - 1 distances between n values.\n\n\n  for (var i = 0; i < sortedValues.length - 1; i++) {\n    var curr = sortedValues[i];\n    var next = sortedValues[i + 1];\n\n    if (curr == null || next == null) {\n      continue;\n    }\n\n    var distance = next - curr;\n    smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);\n  }\n\n  return smallestDistanceBetweenValues / diff;\n});\nvar selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, _4, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {\n  if (!isWellBehavedNumber(smallestDistanceInPercent)) {\n    return 0;\n  }\n\n  var rangeWidth = layout === 'vertical' ? offset.height : offset.width;\n\n  if (padding === 'gap') {\n    return smallestDistanceInPercent * rangeWidth / 2;\n  }\n\n  if (padding === 'no-gap') {\n    var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);\n    var halfBand = smallestDistanceInPercent * rangeWidth / 2;\n    return halfBand - gap - (halfBand - gap) / rangeWidth * gap;\n  }\n\n  return 0;\n});\nexport var selectCalculatedXAxisPadding = (state, axisId, isPanorama) => {\n  var xAxisSettings = selectXAxisSettings(state, axisId);\n\n  if (xAxisSettings == null || typeof xAxisSettings.padding !== 'string') {\n    return 0;\n  }\n\n  return selectCalculatedPadding(state, 'xAxis', axisId, isPanorama, xAxisSettings.padding);\n};\nexport var selectCalculatedYAxisPadding = (state, axisId, isPanorama) => {\n  var yAxisSettings = selectYAxisSettings(state, axisId);\n\n  if (yAxisSettings == null || typeof yAxisSettings.padding !== 'string') {\n    return 0;\n  }\n\n  return selectCalculatedPadding(state, 'yAxis', axisId, isPanorama, yAxisSettings.padding);\n};\nvar selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {\n  var _padding$left, _padding$right;\n\n  if (xAxisSettings == null) {\n    return {\n      left: 0,\n      right: 0\n    };\n  }\n\n  var {\n    padding\n  } = xAxisSettings;\n\n  if (typeof padding === 'string') {\n    return {\n      left: calculated,\n      right: calculated\n    };\n  }\n\n  return {\n    left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,\n    right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated\n  };\n});\nvar selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {\n  var _padding$top, _padding$bottom;\n\n  if (yAxisSettings == null) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n\n  var {\n    padding\n  } = yAxisSettings;\n\n  if (typeof padding === 'string') {\n    return {\n      top: calculated,\n      bottom: calculated\n    };\n  }\n\n  return {\n    top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,\n    bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated\n  };\n});\nexport var combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref4;\n\n  if (isPanorama) {\n    return [brushPadding.left, brushDimensions.width - brushPadding.right];\n  }\n\n  return [offset.left + padding.left, offset.left + offset.width - padding.right];\n});\nexport var combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref5;\n\n  if (isPanorama) {\n    return [brushDimensions.height - brushPadding.bottom, brushPadding.top];\n  }\n\n  if (layout === 'horizontal') {\n    return [offset.top + offset.height - padding.bottom, offset.top + padding.top];\n  }\n\n  return [offset.top + padding.top, offset.top + offset.height - padding.bottom];\n});\nexport var selectAxisRange = (state, axisType, axisId, isPanorama) => {\n  var _selectZAxisSettings;\n\n  switch (axisType) {\n    case 'xAxis':\n      return combineXAxisRange(state, axisId, isPanorama);\n\n    case 'yAxis':\n      return combineYAxisRange(state, axisId, isPanorama);\n\n    case 'zAxis':\n      return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;\n\n    case 'angleAxis':\n      return selectAngleAxisRange(state);\n\n    case 'radiusAxis':\n      return selectRadiusAxisRange(state, axisId);\n\n    default:\n      return undefined;\n  }\n};\nexport var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);\nvar selectCheckedAxisDomain = createSelector([selectRealScaleType, selectAxisDomainIncludingNiceTicks], combineCheckedDomain);\nexport var selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectCheckedAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectErrorBarsSettings = createSelector([selectCartesianItemsSettings, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);\n\nfunction compareIds(a, b) {\n  if (a.id < b.id) {\n    return -1;\n  }\n\n  if (a.id > b.id) {\n    return 1;\n  }\n\n  return 0;\n}\n\nvar pickAxisOrientation = (_state, orientation) => orientation;\n\nvar pickMirror = (_state, _orientation, mirror) => mirror;\n\nvar selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\n\nvar getXAxisSize = (offset, axisSettings) => {\n  return {\n    width: offset.width,\n    height: axisSettings.height\n  };\n};\n\nvar getYAxisSize = (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n};\n\nexport var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);\n\nvar combineXAxisPositionStartingPoint = (offset, orientation, chartHeight) => {\n  switch (orientation) {\n    case 'top':\n      return offset.top;\n\n    case 'bottom':\n      return chartHeight - offset.bottom;\n\n    default:\n      return 0;\n  }\n};\n\nvar combineYAxisPositionStartingPoint = (offset, orientation, chartWidth) => {\n  switch (orientation) {\n    case 'left':\n      return offset.left;\n\n    case 'right':\n      return chartWidth - offset.right;\n\n    default:\n      return 0;\n  }\n};\n\nexport var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getXAxisSize(offset, axis);\n\n    if (position == null) {\n      position = combineXAxisPositionStartingPoint(offset, orientation, chartHeight);\n    }\n\n    var needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.height;\n    position += (needSpace ? -1 : 1) * axisSize.height;\n  });\n  return steps;\n});\nexport var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getYAxisSize(offset, axis);\n\n    if (position == null) {\n      position = combineYAxisPositionStartingPoint(offset, orientation, chartWidth);\n    }\n\n    var needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.width;\n    position += (needSpace ? -1 : 1) * axisSize.width;\n  });\n  return steps;\n});\n\nvar selectXAxisOffsetSteps = (state, axisId) => {\n  var axisSettings = selectXAxisSettings(state, axisId);\n\n  if (axisSettings == null) {\n    return undefined;\n  }\n\n  return selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n};\n\nexport var selectXAxisPosition = createSelector([selectChartOffsetInternal, selectXAxisSettings, selectXAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {\n  if (axisSettings == null) {\n    return undefined;\n  }\n\n  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];\n\n  if (stepOfThisAxis == null) {\n    return {\n      x: offset.left,\n      y: 0\n    };\n  }\n\n  return {\n    x: offset.left,\n    y: stepOfThisAxis\n  };\n});\n\nvar selectYAxisOffsetSteps = (state, axisId) => {\n  var axisSettings = selectYAxisSettings(state, axisId);\n\n  if (axisSettings == null) {\n    return undefined;\n  }\n\n  return selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n};\n\nexport var selectYAxisPosition = createSelector([selectChartOffsetInternal, selectYAxisSettings, selectYAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {\n  if (axisSettings == null) {\n    return undefined;\n  }\n\n  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];\n\n  if (stepOfThisAxis == null) {\n    return {\n      x: 0,\n      y: offset.top\n    };\n  }\n\n  return {\n    x: stepOfThisAxis,\n    y: offset.top\n  };\n});\nexport var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n});\nexport var selectCartesianAxisSize = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSize(state, axisId).width;\n      }\n\n    case 'yAxis':\n      {\n        return selectYAxisSize(state, axisId).height;\n      }\n\n    default:\n      {\n        return undefined;\n      }\n  }\n};\nexport var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n\n  var {\n    allowDuplicatedCategory,\n    type,\n    dataKey\n  } = axis;\n  var isCategorical = isCategoricalAxis(chartLayout, axisType);\n  var allData = appliedValues.map(av => av.value);\n\n  if (dataKey && isCategorical && type === 'category' && allowDuplicatedCategory && hasDuplicate(allData)) {\n    return allData;\n  }\n\n  return undefined;\n};\nexport var selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);\nexport var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {\n  if (axis == null || axis.dataKey == null) {\n    return undefined;\n  }\n\n  var {\n    type,\n    scale\n  } = axis;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n\n  if (isCategorical && (type === 'number' || scale !== 'auto')) {\n    return appliedValues.map(d => d.value);\n  }\n\n  return undefined;\n};\nexport var selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectRenderableAxisSettings, pickAxisType], combineCategoricalDomain);\nexport var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  return {\n    angle: axis.angle,\n    interval: axis.interval,\n    minTickGap: axis.minTickGap,\n    orientation: axis.orientation,\n    tick: axis.tick,\n    tickCount: axis.tickCount,\n    tickFormatter: axis.tickFormatter,\n    ticks: axis.ticks,\n    type: axis.type,\n    unit: axis.unit,\n    axisType,\n    categoricalDomain,\n    duplicateDomain,\n    isCategorical,\n    niceTicks,\n    range: axisRange,\n    realScaleType,\n    scale\n  };\n});\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\n\nexport var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    type,\n    ticks,\n    tickCount\n  } = axis;\n  var offsetForBand = // @ts-expect-error This is testing for `scaleBand` but for band axis the type is reported as `band` so this looks like a dead code with a workaround elsewhere?\n  realScaleType === 'scaleBand' && typeof scale.bandwidth === 'function' ? scale.bandwidth() / 2 : 2;\n  var offset = type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset; // The ticks set by user should only affect the ticks adjacent to axis line\n\n  var ticksOrNiceTicks = ticks || niceTicks;\n\n  if (ticksOrNiceTicks) {\n    return ticksOrNiceTicks.map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      var scaled = scale.map(scaleContent);\n\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n\n      return {\n        index,\n        coordinate: scaled + offset,\n        value: entry,\n        offset\n      };\n    }).filter(isNotNil);\n  } // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  if (scale.ticks) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use Date as index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\nexport var selectTicksOfAxis = createSelector([selectChartLayout, selectRenderableAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\n\nexport var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {\n    return undefined;\n  }\n\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    tickCount\n  } = axis;\n  var offset = 0;\n  offset = axisType === 'angleAxis' && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset; // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  if (scale.ticks) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use unknown as index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\nexport var selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectRenderableAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);\n/**\n * This is the internal representation of an axis along with its scale function.\n * Here we have already computed the scale function for the axis,\n * and replaced the union type of scale (string | function) with just the function type.\n */\n\nexport var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\nvar selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectZAxisWithScale = createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\n/**\n * We are also going to need to implement polar chart directions if we want to support keyboard controls for those.\n */\n\nexport var selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {\n  switch (layout) {\n    case 'horizontal':\n      {\n        return allXAxes.some(axis => axis.reversed) ? 'right-to-left' : 'left-to-right';\n      }\n\n    case 'vertical':\n      {\n        return allYAxes.some(axis => axis.reversed) ? 'bottom-to-top' : 'top-to-bottom';\n      }\n    // TODO: make this better. For now, right arrow triggers \"forward\", left arrow \"back\"\n    // however, the tooltip moves an unintuitive direction because of how the indices are rendered\n\n    case 'centric':\n    case 'radial':\n      {\n        return 'left-to-right';\n      }\n\n    default:\n      {\n        return undefined;\n      }\n  }\n});","map":{"version":3,"names":["ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","createSelector","range","d3Scales","selectChartLayout","getDomainOfStackGroups","getStackedData","getValueByDataKey","isCategoricalAxis","selectChartDataWithIndexes","selectChartDataWithIndexesIfNotInPanoramaPosition4","isWellFormedNumberDomain","numericalDomainSpecifiedWithoutRequiringData","parseNumericalUserDomain","getPercentValue","hasDuplicate","isNan","isNotNil","isNumOrStr","mathSign","upperFirst","isWellBehavedNumber","getNiceTickValues","getTickValuesFixedDomain","selectChartHeight","selectChartWidth","selectAllXAxes","selectAllYAxes","selectChartOffsetInternal","selectBrushDimensions","selectBrushSettings","selectBarCategoryGap","selectChartName","selectReverseStackOrder","selectStackOffsetType","selectAngleAxis","selectAngleAxisRange","selectRadiusAxis","selectRadiusAxisRange","pickAxisType","pickAxisId","combineAxisRangeWithReverse","DEFAULT_Y_AXIS_WIDTH","getStackSeriesIdentifier","combineDisplayedStackedData","isStacked","numberDomainEqualityCheck","emptyArraysAreEqualCheck","selectTooltipAxisType","selectTooltipAxisId","rechartsScaleFactory","combineCheckedDomain","defaultNumericDomain","implicitXAxis","allowDataOverflow","allowDecimals","allowDuplicatedCategory","angle","dataKey","undefined","domain","height","hide","id","includeHidden","interval","minTickGap","mirror","name","orientation","padding","left","right","reversed","scale","tick","tickCount","tickFormatter","ticks","type","unit","selectXAxisSettingsNoDefaults","state","axisId","cartesianAxis","xAxis","selectXAxisSettings","axis","implicitYAxis","top","bottom","width","selectYAxisSettingsNoDefaults","yAxis","selectYAxisSettings","implicitZAxis","selectZAxisSettings","zAxis","selectBaseAxis","axisType","Error","concat","selectCartesianAxisSettings","selectRenderableAxisSettings","selectHasBar","graphicalItems","cartesianItems","some","item","polarItems","itemAxisPredicate","xAxisId","yAxisId","zAxisId","angleAxisId","radiusAxisId","selectUnfilteredCartesianItems","selectAxisPredicate","combineGraphicalItemsSettings","axisSettings","axisPredicate","selectCartesianItemsSettings","memoizeOptions","resultEqualityCheck","selectStackedCartesianItemsSettings","filterGraphicalNotStackedItems","stackId","selectCartesianItemsSettingsExceptStacked","combineGraphicalItemsData","map","data","Boolean","flat","selectCartesianGraphicalItemsData","combineDisplayedData","graphicalItemsData","_ref","chartData","dataStartIndex","dataEndIndex","slice","selectDisplayedData","combineAppliedValues","items","flatMap","entry","selectAllAppliedValues","isErrorBarRelevantForAxisType","errorBar","direction","makeNumber","val","Date","n","makeDomain","Array","isArray","attempt","onlyAllowNumbers","getErrorDomainByDataKey","appliedValue","relevantErrorBars","eb","errorValue","lowBound","highBound","selectTooltipAxis","selectTooltipAxisDataKey","selectDisplayedStackedData","combineStackGroups","displayedData","stackOffsetType","reverseStackOrder","initialItemsGroups","itemsGroup","reduce","acc","stack","fromEntries","entries","_ref2","orderedGraphicalItems","reverse","dataKeys","stackedData","selectStackGroups","combineDomainOfStackGroups","stackGroups","_ref3","domainFromUserPreference","domainOfStackGroups","selectAllowsDataOverflow","getDomainDefinition","_axisSettings$domain","allValues","Math","min","max","selectDomainDefinition","selectDomainFromUserPreference","selectDomainOfStackGroups","selectAllErrorBarSettings","errorBars","combineRelevantErrorBarSettings","cartesianItemsSettings","allErrorBarSettings","mergeDomains","_len","domains","_key","allDomains","combineDomainOfAllAppliedNumericalValuesIncludingErrorValues","lowerEnd","upperEnd","_errorBars$item$id","_axisSettings$dataKey","valueByDataKey","errorDomain","localLower","localUpper","dataValueDomain","selectDomainOfAllAppliedNumericalValuesIncludingErrorValues","onlyAllowNumbersAndStringsAndDates","computeDomainOfTypeCategory","allDataSquished","isCategorical","categoricalDomain","v","from","Set","selectReferenceDots","referenceElements","dots","filterReferenceElements","elements","el","ifOverflow","selectReferenceDotsByAxis","selectReferenceAreas","areas","selectReferenceAreasByAxis","selectReferenceLines","lines","selectReferenceLinesByAxis","combineDotsDomain","allCoords","dot","x","y","selectReferenceDotsDomain","combineAreasDomain","area","x1","y1","x2","y2","selectReferenceAreasDomain","extractXCoordinates","line","_line$segment","segmentCoordinates","segment","s","extractYCoordinates","_line$segment2","combineLinesDomain","selectReferenceLinesDomain","selectReferenceElementsDomain","dotsDomain","linesDomain","areasDomain","combineNumericalDomain","domainDefinition","dataAndErrorBarsDomain","referenceElementsDomain","layout","shouldIncludeDomainOfStackGroups","mergedDomains","selectNumericalDomain","expandDomain","combineAxisDomain","allAppliedValues","numericalDomain","_displayedData$length","selectAxisDomain","isSupportedScaleName","combineRealScaleType","axisConfig","hasBar","chartType","indexOf","selectRealScaleType","combineScaleFunction","realScaleType","axisDomain","axisRange","combineNiceTicks","selectNiceTicks","combineAxisDomainWithNiceTicks","niceTicks","_niceTicks$","_niceTicks","minFromDomain","minFromTicks","maxFromDomain","maxFromTicks","selectAxisDomainIncludingNiceTicks","selectSmallestDistanceBetweenValues","smallestDistanceBetweenValues","Infinity","sortedValues","d","sort","a","b","first","last","diff","curr","next","distance","selectCalculatedPadding","_1","_2","_3","_4","smallestDistanceInPercent","barCategoryGap","offset","rangeWidth","gap","halfBand","selectCalculatedXAxisPadding","isPanorama","xAxisSettings","selectCalculatedYAxisPadding","yAxisSettings","selectXAxisPadding","calculated","_padding$left","_padding$right","selectYAxisPadding","_padding$top","_padding$bottom","combineXAxisRange","_state","_axisId","brushDimensions","_ref4","brushPadding","combineYAxisRange","_ref5","selectAxisRange","_selectZAxisSettings","selectAxisRangeWithReverse","selectCheckedAxisDomain","selectAxisScale","selectErrorBarsSettings","compareIds","pickAxisOrientation","pickMirror","_orientation","selectAllXAxesWithOffsetType","allAxes","selectAllYAxesWithOffsetType","getXAxisSize","getYAxisSize","selectXAxisSize","combineXAxisPositionStartingPoint","chartHeight","combineYAxisPositionStartingPoint","chartWidth","selectAllXAxesOffsetSteps","allAxesWithSameOffsetType","steps","position","axisSize","needSpace","selectAllYAxesOffsetSteps","selectXAxisOffsetSteps","selectXAxisPosition","_","allSteps","stepOfThisAxis","selectYAxisOffsetSteps","selectYAxisPosition","selectYAxisSize","selectCartesianAxisSize","combineDuplicateDomain","chartLayout","appliedValues","allData","av","selectDuplicateDomain","combineCategoricalDomain","selectCategoricalDomain","selectAxisPropsNeededForCartesianGridTicksGenerator","duplicateDomain","combineAxisTicks","offsetForBand","bandwidth","ticksOrNiceTicks","index","scaleContent","scaled","coordinate","selectTicksOfAxis","combineGraphicalItemTicks","selectTicksOfGraphicalItem","selectAxisWithScale","selectZAxisScale","selectZAxisWithScale","_axisType","selectChartDirection","allXAxes","allYAxes"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/state/selectors/axisSelectors.js"],"sourcesContent":["function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { createSelector } from 'reselect';\nimport range from 'es-toolkit/compat/range';\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { getDomainOfStackGroups, getStackedData, getValueByDataKey, isCategoricalAxis } from '../../util/ChartUtils';\nimport { selectChartDataWithIndexes, selectChartDataWithIndexesIfNotInPanoramaPosition4 } from './dataSelectors';\nimport { isWellFormedNumberDomain, numericalDomainSpecifiedWithoutRequiringData, parseNumericalUserDomain } from '../../util/isDomainSpecifiedByUser';\nimport { getPercentValue, hasDuplicate, isNan, isNotNil, isNumOrStr, mathSign, upperFirst } from '../../util/DataUtils';\nimport { isWellBehavedNumber } from '../../util/isWellBehavedNumber';\nimport { getNiceTickValues, getTickValuesFixedDomain } from '../../util/scale';\nimport { selectChartHeight, selectChartWidth } from './containerSelectors';\nimport { selectAllXAxes, selectAllYAxes } from './selectAllAxes';\nimport { selectChartOffsetInternal } from './selectChartOffsetInternal';\nimport { selectBrushDimensions, selectBrushSettings } from './brushSelectors';\nimport { selectBarCategoryGap, selectChartName, selectReverseStackOrder, selectStackOffsetType } from './rootPropsSelectors';\nimport { selectAngleAxis, selectAngleAxisRange, selectRadiusAxis, selectRadiusAxisRange } from './polarAxisSelectors';\nimport { pickAxisType } from './pickAxisType';\nimport { pickAxisId } from './pickAxisId';\nimport { combineAxisRangeWithReverse } from './combiners/combineAxisRangeWithReverse';\nimport { DEFAULT_Y_AXIS_WIDTH } from '../../util/Constants';\nimport { getStackSeriesIdentifier } from '../../util/stacks/getStackSeriesIdentifier';\nimport { combineDisplayedStackedData } from './combiners/combineDisplayedStackedData';\nimport { isStacked } from '../types/StackedGraphicalItem';\nimport { numberDomainEqualityCheck } from './numberDomainEqualityCheck';\nimport { emptyArraysAreEqualCheck } from './arrayEqualityCheck';\nimport { selectTooltipAxisType } from './selectTooltipAxisType';\nimport { selectTooltipAxisId } from './selectTooltipAxisId';\nimport { rechartsScaleFactory } from '../../util/scale/RechartsScale';\nimport { combineCheckedDomain } from './combiners/combineCheckedDomain';\nexport var defaultNumericDomain = [0, 'auto'];\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\nexport var implicitXAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: undefined,\n  height: 30,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'bottom',\n  padding: {\n    left: 0,\n    right: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'category',\n  unit: undefined\n};\nexport var selectXAxisSettingsNoDefaults = (state, axisId) => {\n  return state.cartesianAxis.xAxis[axisId];\n};\nexport var selectXAxisSettings = (state, axisId) => {\n  var axis = selectXAxisSettingsNoDefaults(state, axisId);\n  if (axis == null) {\n    return implicitXAxis;\n  }\n  return axis;\n};\n\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\nexport var implicitYAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: defaultNumericDomain,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'left',\n  padding: {\n    top: 0,\n    bottom: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'number',\n  unit: undefined,\n  width: DEFAULT_Y_AXIS_WIDTH\n};\nexport var selectYAxisSettingsNoDefaults = (state, axisId) => {\n  return state.cartesianAxis.yAxis[axisId];\n};\nexport var selectYAxisSettings = (state, axisId) => {\n  var axis = selectYAxisSettingsNoDefaults(state, axisId);\n  if (axis == null) {\n    return implicitYAxis;\n  }\n  return axis;\n};\nexport var implicitZAxis = {\n  domain: [0, 'auto'],\n  includeHidden: false,\n  reversed: false,\n  allowDataOverflow: false,\n  allowDuplicatedCategory: false,\n  dataKey: undefined,\n  id: 0,\n  name: '',\n  range: [64, 64],\n  scale: 'auto',\n  type: 'number',\n  unit: ''\n};\nexport var selectZAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.zAxis[axisId];\n  if (axis == null) {\n    return implicitZAxis;\n  }\n  return axis;\n};\nexport var selectBaseAxis = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    case 'zAxis':\n      {\n        return selectZAxisSettings(state, axisId);\n      }\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\nvar selectCartesianAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\n/**\n * Selects either an X or Y axis. Doesn't work with Z axis - for that, instead use selectBaseAxis.\n * @param state Root state\n * @param axisType xAxis | yAxis\n * @param axisId xAxisId | yAxisId\n * @returns axis settings object\n */\nexport var selectRenderableAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\n/**\n * @param state RechartsRootState\n * @return boolean true if there is at least one Bar or RadialBar\n */\nexport var selectHasBar = state => state.graphicalItems.cartesianItems.some(item => item.type === 'bar') || state.graphicalItems.polarItems.some(item => item.type === 'radialBar');\n\n/**\n * Filters CartesianGraphicalItemSettings by the relevant axis ID\n * @param axisType 'xAxis' | 'yAxis' | 'zAxis' | 'radiusAxis' | 'angleAxis'\n * @param axisId from props, defaults to 0\n *\n * @returns Predicate function that return true for CartesianGraphicalItemSettings that are relevant to the specified axis\n */\nexport function itemAxisPredicate(axisType, axisId) {\n  return item => {\n    switch (axisType) {\n      case 'xAxis':\n        // This is sensitive to the data type, as 0 !== '0'. I wonder if we should be more flexible. How does 2.x branch behave? TODO write test for that\n        return 'xAxisId' in item && item.xAxisId === axisId;\n      case 'yAxis':\n        return 'yAxisId' in item && item.yAxisId === axisId;\n      case 'zAxis':\n        return 'zAxisId' in item && item.zAxisId === axisId;\n      case 'angleAxis':\n        return 'angleAxisId' in item && item.angleAxisId === axisId;\n      case 'radiusAxis':\n        return 'radiusAxisId' in item && item.radiusAxisId === axisId;\n      default:\n        return false;\n    }\n  };\n}\n\n// TODO appears there is a bug where this selector is called from polar context, find and fix it.\nexport var selectUnfilteredCartesianItems = state => state.graphicalItems.cartesianItems;\nvar selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);\nexport var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter(item => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {\n    return true;\n  }\n  return !item.hide;\n});\nexport var selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings, {\n  memoizeOptions: {\n    resultEqualityCheck: emptyArraysAreEqualCheck\n  }\n});\nexport var selectStackedCartesianItemsSettings = createSelector([selectCartesianItemsSettings], cartesianItems => {\n  return cartesianItems.filter(item => item.type === 'area' || item.type === 'bar').filter(isStacked);\n});\nexport var filterGraphicalNotStackedItems = cartesianItems => cartesianItems.filter(item => !('stackId' in item) || item.stackId === undefined);\nvar selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);\nexport var combineGraphicalItemsData = cartesianItems => cartesianItems.map(item => item.data).filter(Boolean).flat(1);\n\n/**\n * This is a \"cheap\" selector - it returns the data but doesn't iterate them, so it is not sensitive on the array length.\n * Also does not apply dataKey yet.\n * @param state RechartsRootState\n * @returns data defined on the chart graphical items, such as Line or Scatter or Pie, and filtered with appropriate dataKey\n */\nexport var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData, {\n  memoizeOptions: {\n    resultEqualityCheck: emptyArraysAreEqualCheck\n  }\n});\nexport var combineDisplayedData = (graphicalItemsData, _ref) => {\n  var {\n    chartData = [],\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n  if (graphicalItemsData.length > 0) {\n    /*\n     * There is no slicing when data is defined on graphical items. Why?\n     * Because Brush ignores data defined on graphical items,\n     * and does not render.\n     * So Brush will never show up in a Scatter chart for example.\n     * This is something we will need to fix.\n     *\n     * Now, when the root chart data is not defined, the dataEndIndex is 0,\n     * which means the itemsData will be sliced to an empty array anyway.\n     * But that's an implementation detail, and we can fix that too.\n     *\n     * Also, in absence of Axis dataKey, we use the dataKey from each item, respectively.\n     * This is the usual pattern for numerical axis, that is the one where bars go up:\n     * users don't specify any dataKey by default and expect the axis to \"just match the data\".\n     */\n    return graphicalItemsData;\n  }\n  return chartData.slice(dataStartIndex, dataEndIndex + 1);\n};\n\n/**\n * This selector will return all data there is in the chart: graphical items, chart root, all together.\n * Useful for figuring out an axis domain (because that needs to know of everything),\n * not useful for rendering individual graphical elements (because they need to know which data is theirs and which is not).\n *\n * This function will discard the original indexes, so it is also not useful for anything that depends on ordering.\n */\nexport var selectDisplayedData = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanoramaPosition4], combineDisplayedData);\nexport var combineAppliedValues = (data, axisSettings, items) => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    return data.map(item => ({\n      value: getValueByDataKey(item, axisSettings.dataKey)\n    }));\n  }\n  if (items.length > 0) {\n    return items.map(item => item.dataKey).flatMap(dataKey => data.map(entry => ({\n      value: getValueByDataKey(entry, dataKey)\n    })));\n  }\n  return data.map(entry => ({\n    value: entry\n  }));\n};\n\n/**\n * This selector will return all values with the appropriate dataKey applied on them.\n * Which dataKey is appropriate depends on where it is defined.\n *\n * This is an expensive selector - it will iterate all data and compute their value using the provided dataKey.\n */\nexport var selectAllAppliedValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);\nexport function isErrorBarRelevantForAxisType(axisType, errorBar) {\n  switch (axisType) {\n    case 'xAxis':\n      return errorBar.direction === 'x';\n    case 'yAxis':\n      return errorBar.direction === 'y';\n    default:\n      return false;\n  }\n}\nfunction makeNumber(val) {\n  if (isNumOrStr(val) || val instanceof Date) {\n    var n = Number(val);\n    if (isWellBehavedNumber(n)) {\n      return n;\n    }\n  }\n  return undefined;\n}\nfunction makeDomain(val) {\n  if (Array.isArray(val)) {\n    var attempt = [makeNumber(val[0]), makeNumber(val[1])];\n    if (isWellFormedNumberDomain(attempt)) {\n      return attempt;\n    }\n    return undefined;\n  }\n  var n = makeNumber(val);\n  if (n == null) {\n    return undefined;\n  }\n  return [n, n];\n}\nfunction onlyAllowNumbers(data) {\n  return data.map(makeNumber).filter(isNotNil);\n}\n\n/**\n * @param entry One item in the 'data' array. Could be anything really - this is defined externally. This is the raw, before dataKey application\n * @param appliedValue This is the result of applying the 'main' dataKey on the `entry`.\n * @param relevantErrorBars Error bars that are relevant for the current axis and layout and all that.\n * @return either undefined or an array of ErrorValue\n */\nexport function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {\n  if (!relevantErrorBars || typeof appliedValue !== 'number' || isNan(appliedValue)) {\n    return [];\n  }\n  if (!relevantErrorBars.length) {\n    return [];\n  }\n  return onlyAllowNumbers(relevantErrorBars.flatMap(eb => {\n    var errorValue = getValueByDataKey(entry, eb.dataKey);\n    var lowBound, highBound;\n    if (Array.isArray(errorValue)) {\n      [lowBound, highBound] = errorValue;\n    } else {\n      lowBound = highBound = errorValue;\n    }\n    if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {\n      return undefined;\n    }\n    return [appliedValue - lowBound, appliedValue + highBound];\n  }));\n}\nexport var selectTooltipAxis = state => {\n  var axisType = selectTooltipAxisType(state);\n  var axisId = selectTooltipAxisId(state);\n  return selectRenderableAxisSettings(state, axisType, axisId);\n};\nexport var selectTooltipAxisDataKey = createSelector([selectTooltipAxis], axis => axis === null || axis === void 0 ? void 0 : axis.dataKey);\nexport var selectDisplayedStackedData = createSelector([selectStackedCartesianItemsSettings, selectChartDataWithIndexesIfNotInPanoramaPosition4, selectTooltipAxis], combineDisplayedStackedData);\nexport var combineStackGroups = (displayedData, items, stackOffsetType, reverseStackOrder) => {\n  var initialItemsGroups = {};\n  var itemsGroup = items.reduce((acc, item) => {\n    if (item.stackId == null) {\n      return acc;\n    }\n    var stack = acc[item.stackId];\n    if (stack == null) {\n      stack = [];\n    }\n    stack.push(item);\n    acc[item.stackId] = stack;\n    return acc;\n  }, initialItemsGroups);\n  return Object.fromEntries(Object.entries(itemsGroup).map(_ref2 => {\n    var [stackId, graphicalItems] = _ref2;\n    var orderedGraphicalItems = reverseStackOrder ? [...graphicalItems].reverse() : graphicalItems;\n    var dataKeys = orderedGraphicalItems.map(getStackSeriesIdentifier);\n    return [stackId, {\n      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that\n      stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),\n      graphicalItems: orderedGraphicalItems\n    }];\n  }));\n};\n\n/**\n * Stack groups are groups of graphical items that stack on each other.\n * Stack is a function of axis type (X, Y), axis ID, and stack ID.\n * Graphical items that do not have a stack ID are not going to be present in stack groups.\n */\nexport var selectStackGroups = createSelector([selectDisplayedStackedData, selectStackedCartesianItemsSettings, selectStackOffsetType, selectReverseStackOrder], combineStackGroups);\nexport var combineDomainOfStackGroups = (stackGroups, _ref3, axisType, domainFromUserPreference) => {\n  var {\n    dataStartIndex,\n    dataEndIndex\n  } = _ref3;\n  if (domainFromUserPreference != null) {\n    // User has specified a domain, so we respect that and we can skip computing anything else\n    return undefined;\n  }\n  if (axisType === 'zAxis') {\n    // ZAxis ignores stacks\n    return undefined;\n  }\n  var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);\n  if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {\n    return undefined;\n  }\n  return domainOfStackGroups;\n};\nvar selectAllowsDataOverflow = createSelector([selectBaseAxis], axisSettings => axisSettings.allowDataOverflow);\nexport var getDomainDefinition = axisSettings => {\n  var _axisSettings$domain;\n  if (axisSettings == null || !('domain' in axisSettings)) {\n    return defaultNumericDomain;\n  }\n  if (axisSettings.domain != null) {\n    return axisSettings.domain;\n  }\n  if ('ticks' in axisSettings && axisSettings.ticks != null) {\n    if (axisSettings.type === 'number') {\n      var allValues = onlyAllowNumbers(axisSettings.ticks);\n      return [Math.min(...allValues), Math.max(...allValues)];\n    }\n    if (axisSettings.type === 'category') {\n      return axisSettings.ticks.map(String);\n    }\n  }\n  return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;\n};\nexport var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);\n\n/**\n * Under certain circumstances, we can determine the domain without looking at the data at all.\n * This is the case when the domain is explicitly specified as numbers, or when it is specified\n * as 'auto' or 'dataMin'/'dataMax' and data overflow is not allowed.\n *\n * In that case, this function will return the domain, otherwise it returns undefined.\n *\n * This is an optimization to avoid unnecessary data processing.\n * @param state\n * @param axisType\n * @param axisId\n * @param isPanorama\n */\nexport var selectDomainFromUserPreference = createSelector([selectDomainDefinition, selectAllowsDataOverflow], numericalDomainSpecifiedWithoutRequiringData);\nexport var selectDomainOfStackGroups = createSelector([selectStackGroups, selectChartDataWithIndexes, pickAxisType, selectDomainFromUserPreference], combineDomainOfStackGroups, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\nexport var selectAllErrorBarSettings = state => state.errorBars;\nvar combineRelevantErrorBarSettings = (cartesianItemsSettings, allErrorBarSettings, axisType) => {\n  return cartesianItemsSettings.flatMap(item => {\n    return allErrorBarSettings[item.id];\n  }).filter(Boolean).filter(e => {\n    return isErrorBarRelevantForAxisType(axisType, e);\n  });\n};\nexport var mergeDomains = function mergeDomains() {\n  for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {\n    domains[_key] = arguments[_key];\n  }\n  var allDomains = domains.filter(Boolean);\n  if (allDomains.length === 0) {\n    return undefined;\n  }\n  var allValues = allDomains.flat();\n  var min = Math.min(...allValues);\n  var max = Math.max(...allValues);\n  return [min, max];\n};\nexport var combineDomainOfAllAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, errorBars, axisType) => {\n  var lowerEnd, upperEnd;\n  if (items.length > 0) {\n    data.forEach(entry => {\n      items.forEach(item => {\n        var _errorBars$item$id, _axisSettings$dataKey;\n        var relevantErrorBars = (_errorBars$item$id = errorBars[item.id]) === null || _errorBars$item$id === void 0 ? void 0 : _errorBars$item$id.filter(errorBar => isErrorBarRelevantForAxisType(axisType, errorBar));\n        var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);\n        var errorDomain = getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars);\n        if (errorDomain.length >= 2) {\n          var localLower = Math.min(...errorDomain);\n          var localUpper = Math.max(...errorDomain);\n          if (lowerEnd == null || localLower < lowerEnd) {\n            lowerEnd = localLower;\n          }\n          if (upperEnd == null || localUpper > upperEnd) {\n            upperEnd = localUpper;\n          }\n        }\n        var dataValueDomain = makeDomain(valueByDataKey);\n        if (dataValueDomain != null) {\n          lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);\n          upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);\n        }\n      });\n    });\n  }\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    data.forEach(item => {\n      var dataValueDomain = makeDomain(getValueByDataKey(item, axisSettings.dataKey));\n      if (dataValueDomain != null) {\n        lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);\n        upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);\n      }\n    });\n  }\n  if (isWellBehavedNumber(lowerEnd) && isWellBehavedNumber(upperEnd)) {\n    return [lowerEnd, upperEnd];\n  }\n  return undefined;\n};\nvar selectDomainOfAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\nfunction onlyAllowNumbersAndStringsAndDates(item) {\n  var {\n    value\n  } = item;\n  if (isNumOrStr(value) || value instanceof Date) {\n    return value;\n  }\n  return undefined;\n}\nvar computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {\n  var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter(v => v != null);\n  if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {\n    /*\n     * 1. In an absence of dataKey, Recharts will use array indexes as its categorical domain\n     * 2. When category axis has duplicated text, serial numbers are used to generate scale\n     */\n    return range(0, allDataSquished.length);\n  }\n  if (axisSettings.allowDuplicatedCategory) {\n    return categoricalDomain;\n  }\n  return Array.from(new Set(categoricalDomain));\n};\nexport var selectReferenceDots = state => state.referenceElements.dots;\nexport var filterReferenceElements = (elements, axisType, axisId) => {\n  return elements.filter(el => el.ifOverflow === 'extendDomain').filter(el => {\n    if (axisType === 'xAxis') {\n      return el.xAxisId === axisId;\n    }\n    return el.yAxisId === axisId;\n  });\n};\nexport var selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceAreas = state => state.referenceElements.areas;\nexport var selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceLines = state => state.referenceElements.lines;\nexport var selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);\nexport var combineDotsDomain = (dots, axisType) => {\n  if (dots == null) {\n    return undefined;\n  }\n  var allCoords = onlyAllowNumbers(dots.map(dot => axisType === 'xAxis' ? dot.x : dot.y));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);\nexport var combineAreasDomain = (areas, axisType) => {\n  if (areas == null) {\n    return undefined;\n  }\n  var allCoords = onlyAllowNumbers(areas.flatMap(area => [axisType === 'xAxis' ? area.x1 : area.y1, axisType === 'xAxis' ? area.x2 : area.y2]));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);\nfunction extractXCoordinates(line) {\n  var _line$segment;\n  if (line.x != null) {\n    return onlyAllowNumbers([line.x]);\n  }\n  var segmentCoordinates = (_line$segment = line.segment) === null || _line$segment === void 0 ? void 0 : _line$segment.map(s => s.x);\n  if (segmentCoordinates == null || segmentCoordinates.length === 0) {\n    return [];\n  }\n  return onlyAllowNumbers(segmentCoordinates);\n}\nfunction extractYCoordinates(line) {\n  var _line$segment2;\n  if (line.y != null) {\n    return onlyAllowNumbers([line.y]);\n  }\n  var segmentCoordinates = (_line$segment2 = line.segment) === null || _line$segment2 === void 0 ? void 0 : _line$segment2.map(s => s.y);\n  if (segmentCoordinates == null || segmentCoordinates.length === 0) {\n    return [];\n  }\n  return onlyAllowNumbers(segmentCoordinates);\n}\nexport var combineLinesDomain = (lines, axisType) => {\n  if (lines == null) {\n    return undefined;\n  }\n  var allCoords = lines.flatMap(line => axisType === 'xAxis' ? extractXCoordinates(line) : extractYCoordinates(line));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceLinesDomain = createSelector([selectReferenceLinesByAxis, pickAxisType], combineLinesDomain);\nvar selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {\n  return mergeDomains(dotsDomain, areasDomain, linesDomain);\n});\nexport var combineNumericalDomain = (axisSettings, domainDefinition, domainFromUserPreference, domainOfStackGroups, dataAndErrorBarsDomain, referenceElementsDomain, layout, axisType) => {\n  if (domainFromUserPreference != null) {\n    // We're done! No need to compute anything else.\n    return domainFromUserPreference;\n  }\n  var shouldIncludeDomainOfStackGroups = layout === 'vertical' && axisType === 'xAxis' || layout === 'horizontal' && axisType === 'yAxis';\n  var mergedDomains = shouldIncludeDomainOfStackGroups ? mergeDomains(domainOfStackGroups, referenceElementsDomain, dataAndErrorBarsDomain) : mergeDomains(referenceElementsDomain, dataAndErrorBarsDomain);\n  return parseNumericalUserDomain(domainDefinition, mergedDomains, axisSettings.allowDataOverflow);\n};\nexport var selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainFromUserPreference, selectDomainOfStackGroups, selectDomainOfAllAppliedNumericalValuesIncludingErrorValues, selectReferenceElementsDomain, selectChartLayout, pickAxisType], combineNumericalDomain, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\n\n/**\n * Expand by design maps everything between 0 and 1,\n * there is nothing to compute.\n * See https://d3js.org/d3-shape/stack#stack-offsets\n */\nvar expandDomain = [0, 1];\nexport var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {\n  if ((axisSettings == null || displayedData == null || displayedData.length === 0) && numericalDomain === undefined) {\n    return undefined;\n  }\n  var {\n    dataKey,\n    type\n  } = axisSettings;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  if (isCategorical && dataKey == null) {\n    var _displayedData$length;\n    return range(0, (_displayedData$length = displayedData === null || displayedData === void 0 ? void 0 : displayedData.length) !== null && _displayedData$length !== void 0 ? _displayedData$length : 0);\n  }\n  if (type === 'category') {\n    return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);\n  }\n  if (stackOffsetType === 'expand') {\n    return expandDomain;\n  }\n  return numericalDomain;\n};\nexport var selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);\nfunction isSupportedScaleName(name) {\n  return name in d3Scales;\n}\nexport var combineRealScaleType = (axisConfig, hasBar, chartType) => {\n  if (axisConfig == null) {\n    return undefined;\n  }\n  var {\n    scale,\n    type\n  } = axisConfig;\n  if (scale === 'auto') {\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return 'point';\n    }\n    if (type === 'category') {\n      return 'band';\n    }\n    return 'linear';\n  }\n  if (typeof scale === 'string') {\n    var name = \"scale\".concat(upperFirst(scale));\n    return isSupportedScaleName(name) ? name : 'point';\n  }\n  return undefined;\n};\nexport var selectRealScaleType = createSelector([selectBaseAxis, selectHasBar, selectChartName], combineRealScaleType);\nexport function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {\n  if (axisDomain == null || axisRange == null) {\n    return undefined;\n  }\n  if (typeof axis.scale === 'function') {\n    return rechartsScaleFactory(axis.scale, axisDomain, axisRange);\n  }\n  return rechartsScaleFactory(realScaleType, axisDomain, axisRange);\n}\nexport var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {\n  var domainDefinition = getDomainDefinition(axisSettings);\n  if (realScaleType !== 'auto' && realScaleType !== 'linear') {\n    return undefined;\n  }\n  if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === 'auto' || domainDefinition[1] === 'auto') && isWellFormedNumberDomain(axisDomain)) {\n    return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n  if (axisSettings != null && axisSettings.tickCount && axisSettings.type === 'number' && isWellFormedNumberDomain(axisDomain)) {\n    return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n  return undefined;\n};\nexport var selectNiceTicks = createSelector([selectAxisDomain, selectRenderableAxisSettings, selectRealScaleType], combineNiceTicks);\nexport var combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {\n  if (\n  /*\n   * Angle axis for some reason uses nice ticks when rendering axis tick labels,\n   * but doesn't use nice ticks for extending domain like all the other axes do.\n   * Not really sure why? Is there a good reason,\n   * or is it just because someone added support for nice ticks to the other axes and forgot this one?\n   */\n  axisType !== 'angleAxis' && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === 'number' && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0) {\n    var _niceTicks$, _niceTicks;\n    var minFromDomain = domain[0];\n    var minFromTicks = (_niceTicks$ = niceTicks[0]) !== null && _niceTicks$ !== void 0 ? _niceTicks$ : 0;\n    var maxFromDomain = domain[1];\n    var maxFromTicks = (_niceTicks = niceTicks[niceTicks.length - 1]) !== null && _niceTicks !== void 0 ? _niceTicks : 0;\n    return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];\n  }\n  return domain;\n};\nexport var selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);\n\n/**\n * Returns the smallest gap, between two numbers in the data, as a ratio of the whole range (max - min).\n * Ignores domain provided by user and only considers domain from data.\n *\n * The result is a number between 0 and 1.\n */\nexport var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {\n  if (!axisSettings || axisSettings.type !== 'number') {\n    return undefined;\n  }\n  var smallestDistanceBetweenValues = Infinity;\n  var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map(d => d.value))).sort((a, b) => a - b);\n  var first = sortedValues[0];\n  var last = sortedValues[sortedValues.length - 1];\n  if (first == null || last == null) {\n    return Infinity;\n  }\n  var diff = last - first;\n  if (diff === 0) {\n    return Infinity;\n  }\n  // Only do n - 1 distance calculations because there's only n - 1 distances between n values.\n  for (var i = 0; i < sortedValues.length - 1; i++) {\n    var curr = sortedValues[i];\n    var next = sortedValues[i + 1];\n    if (curr == null || next == null) {\n      continue;\n    }\n    var distance = next - curr;\n    smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);\n  }\n  return smallestDistanceBetweenValues / diff;\n});\nvar selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, _4, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {\n  if (!isWellBehavedNumber(smallestDistanceInPercent)) {\n    return 0;\n  }\n  var rangeWidth = layout === 'vertical' ? offset.height : offset.width;\n  if (padding === 'gap') {\n    return smallestDistanceInPercent * rangeWidth / 2;\n  }\n  if (padding === 'no-gap') {\n    var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);\n    var halfBand = smallestDistanceInPercent * rangeWidth / 2;\n    return halfBand - gap - (halfBand - gap) / rangeWidth * gap;\n  }\n  return 0;\n});\nexport var selectCalculatedXAxisPadding = (state, axisId, isPanorama) => {\n  var xAxisSettings = selectXAxisSettings(state, axisId);\n  if (xAxisSettings == null || typeof xAxisSettings.padding !== 'string') {\n    return 0;\n  }\n  return selectCalculatedPadding(state, 'xAxis', axisId, isPanorama, xAxisSettings.padding);\n};\nexport var selectCalculatedYAxisPadding = (state, axisId, isPanorama) => {\n  var yAxisSettings = selectYAxisSettings(state, axisId);\n  if (yAxisSettings == null || typeof yAxisSettings.padding !== 'string') {\n    return 0;\n  }\n  return selectCalculatedPadding(state, 'yAxis', axisId, isPanorama, yAxisSettings.padding);\n};\nvar selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {\n  var _padding$left, _padding$right;\n  if (xAxisSettings == null) {\n    return {\n      left: 0,\n      right: 0\n    };\n  }\n  var {\n    padding\n  } = xAxisSettings;\n  if (typeof padding === 'string') {\n    return {\n      left: calculated,\n      right: calculated\n    };\n  }\n  return {\n    left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,\n    right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated\n  };\n});\nvar selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {\n  var _padding$top, _padding$bottom;\n  if (yAxisSettings == null) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n  var {\n    padding\n  } = yAxisSettings;\n  if (typeof padding === 'string') {\n    return {\n      top: calculated,\n      bottom: calculated\n    };\n  }\n  return {\n    top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,\n    bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated\n  };\n});\nexport var combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref4;\n  if (isPanorama) {\n    return [brushPadding.left, brushDimensions.width - brushPadding.right];\n  }\n  return [offset.left + padding.left, offset.left + offset.width - padding.right];\n});\nexport var combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref5;\n  if (isPanorama) {\n    return [brushDimensions.height - brushPadding.bottom, brushPadding.top];\n  }\n  if (layout === 'horizontal') {\n    return [offset.top + offset.height - padding.bottom, offset.top + padding.top];\n  }\n  return [offset.top + padding.top, offset.top + offset.height - padding.bottom];\n});\nexport var selectAxisRange = (state, axisType, axisId, isPanorama) => {\n  var _selectZAxisSettings;\n  switch (axisType) {\n    case 'xAxis':\n      return combineXAxisRange(state, axisId, isPanorama);\n    case 'yAxis':\n      return combineYAxisRange(state, axisId, isPanorama);\n    case 'zAxis':\n      return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;\n    case 'angleAxis':\n      return selectAngleAxisRange(state);\n    case 'radiusAxis':\n      return selectRadiusAxisRange(state, axisId);\n    default:\n      return undefined;\n  }\n};\nexport var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);\nvar selectCheckedAxisDomain = createSelector([selectRealScaleType, selectAxisDomainIncludingNiceTicks], combineCheckedDomain);\nexport var selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectCheckedAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectErrorBarsSettings = createSelector([selectCartesianItemsSettings, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);\nfunction compareIds(a, b) {\n  if (a.id < b.id) {\n    return -1;\n  }\n  if (a.id > b.id) {\n    return 1;\n  }\n  return 0;\n}\nvar pickAxisOrientation = (_state, orientation) => orientation;\nvar pickMirror = (_state, _orientation, mirror) => mirror;\nvar selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar getXAxisSize = (offset, axisSettings) => {\n  return {\n    width: offset.width,\n    height: axisSettings.height\n  };\n};\nvar getYAxisSize = (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n};\nexport var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);\nvar combineXAxisPositionStartingPoint = (offset, orientation, chartHeight) => {\n  switch (orientation) {\n    case 'top':\n      return offset.top;\n    case 'bottom':\n      return chartHeight - offset.bottom;\n    default:\n      return 0;\n  }\n};\nvar combineYAxisPositionStartingPoint = (offset, orientation, chartWidth) => {\n  switch (orientation) {\n    case 'left':\n      return offset.left;\n    case 'right':\n      return chartWidth - offset.right;\n    default:\n      return 0;\n  }\n};\nexport var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getXAxisSize(offset, axis);\n    if (position == null) {\n      position = combineXAxisPositionStartingPoint(offset, orientation, chartHeight);\n    }\n    var needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.height;\n    position += (needSpace ? -1 : 1) * axisSize.height;\n  });\n  return steps;\n});\nexport var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getYAxisSize(offset, axis);\n    if (position == null) {\n      position = combineYAxisPositionStartingPoint(offset, orientation, chartWidth);\n    }\n    var needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.width;\n    position += (needSpace ? -1 : 1) * axisSize.width;\n  });\n  return steps;\n});\nvar selectXAxisOffsetSteps = (state, axisId) => {\n  var axisSettings = selectXAxisSettings(state, axisId);\n  if (axisSettings == null) {\n    return undefined;\n  }\n  return selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n};\nexport var selectXAxisPosition = createSelector([selectChartOffsetInternal, selectXAxisSettings, selectXAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {\n  if (axisSettings == null) {\n    return undefined;\n  }\n  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];\n  if (stepOfThisAxis == null) {\n    return {\n      x: offset.left,\n      y: 0\n    };\n  }\n  return {\n    x: offset.left,\n    y: stepOfThisAxis\n  };\n});\nvar selectYAxisOffsetSteps = (state, axisId) => {\n  var axisSettings = selectYAxisSettings(state, axisId);\n  if (axisSettings == null) {\n    return undefined;\n  }\n  return selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n};\nexport var selectYAxisPosition = createSelector([selectChartOffsetInternal, selectYAxisSettings, selectYAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {\n  if (axisSettings == null) {\n    return undefined;\n  }\n  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];\n  if (stepOfThisAxis == null) {\n    return {\n      x: 0,\n      y: offset.top\n    };\n  }\n  return {\n    x: stepOfThisAxis,\n    y: offset.top\n  };\n});\nexport var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n});\nexport var selectCartesianAxisSize = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSize(state, axisId).width;\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSize(state, axisId).height;\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n};\nexport var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n  var {\n    allowDuplicatedCategory,\n    type,\n    dataKey\n  } = axis;\n  var isCategorical = isCategoricalAxis(chartLayout, axisType);\n  var allData = appliedValues.map(av => av.value);\n  if (dataKey && isCategorical && type === 'category' && allowDuplicatedCategory && hasDuplicate(allData)) {\n    return allData;\n  }\n  return undefined;\n};\nexport var selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);\nexport var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {\n  if (axis == null || axis.dataKey == null) {\n    return undefined;\n  }\n  var {\n    type,\n    scale\n  } = axis;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  if (isCategorical && (type === 'number' || scale !== 'auto')) {\n    return appliedValues.map(d => d.value);\n  }\n  return undefined;\n};\nexport var selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectRenderableAxisSettings, pickAxisType], combineCategoricalDomain);\nexport var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  return {\n    angle: axis.angle,\n    interval: axis.interval,\n    minTickGap: axis.minTickGap,\n    orientation: axis.orientation,\n    tick: axis.tick,\n    tickCount: axis.tickCount,\n    tickFormatter: axis.tickFormatter,\n    ticks: axis.ticks,\n    type: axis.type,\n    unit: axis.unit,\n    axisType,\n    categoricalDomain,\n    duplicateDomain,\n    isCategorical,\n    niceTicks,\n    range: axisRange,\n    realScaleType,\n    scale\n  };\n});\n\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\nexport var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    type,\n    ticks,\n    tickCount\n  } = axis;\n  var offsetForBand =\n  // @ts-expect-error This is testing for `scaleBand` but for band axis the type is reported as `band` so this looks like a dead code with a workaround elsewhere?\n  realScaleType === 'scaleBand' && typeof scale.bandwidth === 'function' ? scale.bandwidth() / 2 : 2;\n  var offset = type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  var ticksOrNiceTicks = ticks || niceTicks;\n  if (ticksOrNiceTicks) {\n    return ticksOrNiceTicks.map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      var scaled = scale.map(scaleContent);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        index,\n        coordinate: scaled + offset,\n        value: entry,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n  if (scale.ticks) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use Date as index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\nexport var selectTicksOfAxis = createSelector([selectChartLayout, selectRenderableAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);\n\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\nexport var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    tickCount\n  } = axis;\n  var offset = 0;\n  offset = axisType === 'angleAxis' && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n  if (scale.ticks) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use unknown as index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\nexport var selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectRenderableAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);\n\n/**\n * This is the internal representation of an axis along with its scale function.\n * Here we have already computed the scale function for the axis,\n * and replaced the union type of scale (string | function) with just the function type.\n */\n\nexport var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\nvar selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectZAxisWithScale = createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\n\n/**\n * We are also going to need to implement polar chart directions if we want to support keyboard controls for those.\n */\n\nexport var selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {\n  switch (layout) {\n    case 'horizontal':\n      {\n        return allXAxes.some(axis => axis.reversed) ? 'right-to-left' : 'left-to-right';\n      }\n    case 'vertical':\n      {\n        return allYAxes.some(axis => axis.reversed) ? 'bottom-to-top' : 'top-to-bottom';\n      }\n    // TODO: make this better. For now, right arrow triggers \"forward\", left arrow \"back\"\n    // however, the tooltip moves an unintuitive direction because of how the indices are rendered\n    case 'centric':\n    case 'radial':\n      {\n        return 'left-to-right';\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n});"],"mappings":"AAAA,SAASA,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;EAAE,IAAIC,CAAC,GAAGC,MAAM,CAACC,IAAP,CAAYJ,CAAZ,CAAR;;EAAwB,IAAIG,MAAM,CAACE,qBAAX,EAAkC;IAAE,IAAIC,CAAC,GAAGH,MAAM,CAACE,qBAAP,CAA6BL,CAA7B,CAAR;IAAyCC,CAAC,KAAKK,CAAC,GAAGA,CAAC,CAACC,MAAF,CAAS,UAAUN,CAAV,EAAa;MAAE,OAAOE,MAAM,CAACK,wBAAP,CAAgCR,CAAhC,EAAmCC,CAAnC,EAAsCQ,UAA7C;IAA0D,CAAlF,CAAT,CAAD,EAAgGP,CAAC,CAACQ,IAAF,CAAOC,KAAP,CAAaT,CAAb,EAAgBI,CAAhB,CAAhG;EAAqH;;EAAC,OAAOJ,CAAP;AAAW;;AAC/P,SAASU,aAAT,CAAuBZ,CAAvB,EAA0B;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,SAAS,CAACC,MAA9B,EAAsCb,CAAC,EAAvC,EAA2C;IAAE,IAAIC,CAAC,GAAG,QAAQW,SAAS,CAACZ,CAAD,CAAjB,GAAuBY,SAAS,CAACZ,CAAD,CAAhC,GAAsC,EAA9C;IAAkDA,CAAC,GAAG,CAAJ,GAAQF,OAAO,CAACI,MAAM,CAACD,CAAD,CAAP,EAAY,CAAC,CAAb,CAAP,CAAuBa,OAAvB,CAA+B,UAAUd,CAAV,EAAa;MAAEe,eAAe,CAAChB,CAAD,EAAIC,CAAJ,EAAOC,CAAC,CAACD,CAAD,CAAR,CAAf;IAA8B,CAA5E,CAAR,GAAwFE,MAAM,CAACc,yBAAP,GAAmCd,MAAM,CAACe,gBAAP,CAAwBlB,CAAxB,EAA2BG,MAAM,CAACc,yBAAP,CAAiCf,CAAjC,CAA3B,CAAnC,GAAqGH,OAAO,CAACI,MAAM,CAACD,CAAD,CAAP,CAAP,CAAmBa,OAAnB,CAA2B,UAAUd,CAAV,EAAa;MAAEE,MAAM,CAACgB,cAAP,CAAsBnB,CAAtB,EAAyBC,CAAzB,EAA4BE,MAAM,CAACK,wBAAP,CAAgCN,CAAhC,EAAmCD,CAAnC,CAA5B;IAAqE,CAA/G,CAA7L;EAAgT;;EAAC,OAAOD,CAAP;AAAW;;AACvb,SAASgB,eAAT,CAAyBhB,CAAzB,EAA4BC,CAA5B,EAA+BC,CAA/B,EAAkC;EAAE,OAAO,CAACD,CAAC,GAAGmB,cAAc,CAACnB,CAAD,CAAnB,KAA2BD,CAA3B,GAA+BG,MAAM,CAACgB,cAAP,CAAsBnB,CAAtB,EAAyBC,CAAzB,EAA4B;IAAEoB,KAAK,EAAEnB,CAAT;IAAYO,UAAU,EAAE,CAAC,CAAzB;IAA4Ba,YAAY,EAAE,CAAC,CAA3C;IAA8CC,QAAQ,EAAE,CAAC;EAAzD,CAA5B,CAA/B,GAA2HvB,CAAC,CAACC,CAAD,CAAD,GAAOC,CAAlI,EAAqIF,CAA5I;AAAgJ;;AACpL,SAASoB,cAAT,CAAwBlB,CAAxB,EAA2B;EAAE,IAAIsB,CAAC,GAAGC,YAAY,CAACvB,CAAD,EAAI,QAAJ,CAApB;;EAAmC,OAAO,YAAY,OAAOsB,CAAnB,GAAuBA,CAAvB,GAA2BA,CAAC,GAAG,EAAtC;AAA2C;;AAC3G,SAASC,YAAT,CAAsBvB,CAAtB,EAAyBD,CAAzB,EAA4B;EAAE,IAAI,YAAY,OAAOC,CAAnB,IAAwB,CAACA,CAA7B,EAAgC,OAAOA,CAAP;EAAU,IAAIF,CAAC,GAAGE,CAAC,CAACwB,MAAM,CAACC,WAAR,CAAT;;EAA+B,IAAI,KAAK,CAAL,KAAW3B,CAAf,EAAkB;IAAE,IAAIwB,CAAC,GAAGxB,CAAC,CAAC4B,IAAF,CAAO1B,CAAP,EAAUD,CAAC,IAAI,SAAf,CAAR;IAAmC,IAAI,YAAY,OAAOuB,CAAvB,EAA0B,OAAOA,CAAP;IAAU,MAAM,IAAIK,SAAJ,CAAc,8CAAd,CAAN;EAAsE;;EAAC,OAAO,CAAC,aAAa5B,CAAb,GAAiB6B,MAAjB,GAA0BC,MAA3B,EAAmC7B,CAAnC,CAAP;AAA+C;;AACxT,SAAS8B,cAAT,QAA+B,UAA/B;AACA,OAAOC,KAAP,MAAkB,yBAAlB;AACA,OAAO,KAAKC,QAAZ,MAA0B,yBAA1B;AACA,SAASC,iBAAT,QAAkC,kCAAlC;AACA,SAASC,sBAAT,EAAiCC,cAAjC,EAAiDC,iBAAjD,EAAoEC,iBAApE,QAA6F,uBAA7F;AACA,SAASC,0BAAT,EAAqCC,kDAArC,QAA+F,iBAA/F;AACA,SAASC,wBAAT,EAAmCC,4CAAnC,EAAiFC,wBAAjF,QAAiH,oCAAjH;AACA,SAASC,eAAT,EAA0BC,YAA1B,EAAwCC,KAAxC,EAA+CC,QAA/C,EAAyDC,UAAzD,EAAqEC,QAArE,EAA+EC,UAA/E,QAAiG,sBAAjG;AACA,SAASC,mBAAT,QAAoC,gCAApC;AACA,SAASC,iBAAT,EAA4BC,wBAA5B,QAA4D,kBAA5D;AACA,SAASC,iBAAT,EAA4BC,gBAA5B,QAAoD,sBAApD;AACA,SAASC,cAAT,EAAyBC,cAAzB,QAA+C,iBAA/C;AACA,SAASC,yBAAT,QAA0C,6BAA1C;AACA,SAASC,qBAAT,EAAgCC,mBAAhC,QAA2D,kBAA3D;AACA,SAASC,oBAAT,EAA+BC,eAA/B,EAAgDC,uBAAhD,EAAyEC,qBAAzE,QAAsG,sBAAtG;AACA,SAASC,eAAT,EAA0BC,oBAA1B,EAAgDC,gBAAhD,EAAkEC,qBAAlE,QAA+F,sBAA/F;AACA,SAASC,YAAT,QAA6B,gBAA7B;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,2BAAT,QAA4C,yCAA5C;AACA,SAASC,oBAAT,QAAqC,sBAArC;AACA,SAASC,wBAAT,QAAyC,4CAAzC;AACA,SAASC,2BAAT,QAA4C,yCAA5C;AACA,SAASC,SAAT,QAA0B,+BAA1B;AACA,SAASC,yBAAT,QAA0C,6BAA1C;AACA,SAASC,wBAAT,QAAyC,sBAAzC;AACA,SAASC,qBAAT,QAAsC,yBAAtC;AACA,SAASC,mBAAT,QAAoC,uBAApC;AACA,SAASC,oBAAT,QAAqC,gCAArC;AACA,SAASC,oBAAT,QAAqC,kCAArC;AACA,OAAO,IAAIC,oBAAoB,GAAG,CAAC,CAAD,EAAI,MAAJ,CAA3B;AACP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,aAAa,GAAG;EACzBC,iBAAiB,EAAE,KADM;EAEzBC,aAAa,EAAE,IAFU;EAGzBC,uBAAuB,EAAE,IAHA;EAIzBC,KAAK,EAAE,CAJkB;EAKzBC,OAAO,EAAEC,SALgB;EAMzBC,MAAM,EAAED,SANiB;EAOzBE,MAAM,EAAE,EAPiB;EAQzBC,IAAI,EAAE,IARmB;EASzBC,EAAE,EAAE,CATqB;EAUzBC,aAAa,EAAE,KAVU;EAWzBC,QAAQ,EAAE,aAXe;EAYzBC,UAAU,EAAE,CAZa;EAazBC,MAAM,EAAE,KAbiB;EAczBC,IAAI,EAAET,SAdmB;EAezBU,WAAW,EAAE,QAfY;EAgBzBC,OAAO,EAAE;IACPC,IAAI,EAAE,CADC;IAEPC,KAAK,EAAE;EAFA,CAhBgB;EAoBzBC,QAAQ,EAAE,KApBe;EAqBzBC,KAAK,EAAE,MArBkB;EAsBzBC,IAAI,EAAE,IAtBmB;EAuBzBC,SAAS,EAAE,CAvBc;EAwBzBC,aAAa,EAAElB,SAxBU;EAyBzBmB,KAAK,EAAEnB,SAzBkB;EA0BzBoB,IAAI,EAAE,UA1BmB;EA2BzBC,IAAI,EAAErB;AA3BmB,CAApB;AA6BP,OAAO,IAAIsB,6BAA6B,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;EAC5D,OAAOD,KAAK,CAACE,aAAN,CAAoBC,KAApB,CAA0BF,MAA1B,CAAP;AACD,CAFM;AAGP,OAAO,IAAIG,mBAAmB,GAAG,CAACJ,KAAD,EAAQC,MAAR,KAAmB;EAClD,IAAII,IAAI,GAAGN,6BAA6B,CAACC,KAAD,EAAQC,MAAR,CAAxC;;EACA,IAAII,IAAI,IAAI,IAAZ,EAAkB;IAChB,OAAOlC,aAAP;EACD;;EACD,OAAOkC,IAAP;AACD,CANM;AAQP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,aAAa,GAAG;EACzBlC,iBAAiB,EAAE,KADM;EAEzBC,aAAa,EAAE,IAFU;EAGzBC,uBAAuB,EAAE,IAHA;EAIzBC,KAAK,EAAE,CAJkB;EAKzBC,OAAO,EAAEC,SALgB;EAMzBC,MAAM,EAAER,oBANiB;EAOzBU,IAAI,EAAE,IAPmB;EAQzBC,EAAE,EAAE,CARqB;EASzBC,aAAa,EAAE,KATU;EAUzBC,QAAQ,EAAE,aAVe;EAWzBC,UAAU,EAAE,CAXa;EAYzBC,MAAM,EAAE,KAZiB;EAazBC,IAAI,EAAET,SAbmB;EAczBU,WAAW,EAAE,MAdY;EAezBC,OAAO,EAAE;IACPmB,GAAG,EAAE,CADE;IAEPC,MAAM,EAAE;EAFD,CAfgB;EAmBzBjB,QAAQ,EAAE,KAnBe;EAoBzBC,KAAK,EAAE,MApBkB;EAqBzBC,IAAI,EAAE,IArBmB;EAsBzBC,SAAS,EAAE,CAtBc;EAuBzBC,aAAa,EAAElB,SAvBU;EAwBzBmB,KAAK,EAAEnB,SAxBkB;EAyBzBoB,IAAI,EAAE,QAzBmB;EA0BzBC,IAAI,EAAErB,SA1BmB;EA2BzBgC,KAAK,EAAEjD;AA3BkB,CAApB;AA6BP,OAAO,IAAIkD,6BAA6B,GAAG,CAACV,KAAD,EAAQC,MAAR,KAAmB;EAC5D,OAAOD,KAAK,CAACE,aAAN,CAAoBS,KAApB,CAA0BV,MAA1B,CAAP;AACD,CAFM;AAGP,OAAO,IAAIW,mBAAmB,GAAG,CAACZ,KAAD,EAAQC,MAAR,KAAmB;EAClD,IAAII,IAAI,GAAGK,6BAA6B,CAACV,KAAD,EAAQC,MAAR,CAAxC;;EACA,IAAII,IAAI,IAAI,IAAZ,EAAkB;IAChB,OAAOC,aAAP;EACD;;EACD,OAAOD,IAAP;AACD,CANM;AAOP,OAAO,IAAIQ,aAAa,GAAG;EACzBnC,MAAM,EAAE,CAAC,CAAD,EAAI,MAAJ,CADiB;EAEzBI,aAAa,EAAE,KAFU;EAGzBS,QAAQ,EAAE,KAHe;EAIzBnB,iBAAiB,EAAE,KAJM;EAKzBE,uBAAuB,EAAE,KALA;EAMzBE,OAAO,EAAEC,SANgB;EAOzBI,EAAE,EAAE,CAPqB;EAQzBK,IAAI,EAAE,EARmB;EASzBlE,KAAK,EAAE,CAAC,EAAD,EAAK,EAAL,CATkB;EAUzBwE,KAAK,EAAE,MAVkB;EAWzBK,IAAI,EAAE,QAXmB;EAYzBC,IAAI,EAAE;AAZmB,CAApB;AAcP,OAAO,IAAIgB,mBAAmB,GAAG,CAACd,KAAD,EAAQC,MAAR,KAAmB;EAClD,IAAII,IAAI,GAAGL,KAAK,CAACE,aAAN,CAAoBa,KAApB,CAA0Bd,MAA1B,CAAX;;EACA,IAAII,IAAI,IAAI,IAAZ,EAAkB;IAChB,OAAOQ,aAAP;EACD;;EACD,OAAOR,IAAP;AACD,CANM;AAOP,OAAO,IAAIW,cAAc,GAAG,CAAChB,KAAD,EAAQiB,QAAR,EAAkBhB,MAAlB,KAA6B;EACvD,QAAQgB,QAAR;IACE,KAAK,OAAL;MACE;QACE,OAAOb,mBAAmB,CAACJ,KAAD,EAAQC,MAAR,CAA1B;MACD;;IACH,KAAK,OAAL;MACE;QACE,OAAOW,mBAAmB,CAACZ,KAAD,EAAQC,MAAR,CAA1B;MACD;;IACH,KAAK,OAAL;MACE;QACE,OAAOa,mBAAmB,CAACd,KAAD,EAAQC,MAAR,CAA1B;MACD;;IACH,KAAK,WAAL;MACE;QACE,OAAOhD,eAAe,CAAC+C,KAAD,EAAQC,MAAR,CAAtB;MACD;;IACH,KAAK,YAAL;MACE;QACE,OAAO9C,gBAAgB,CAAC6C,KAAD,EAAQC,MAAR,CAAvB;MACD;;IACH;MACE,MAAM,IAAIiB,KAAJ,CAAU,yBAAyBC,MAAzB,CAAgCF,QAAhC,CAAV,CAAN;EAtBJ;AAwBD,CAzBM;;AA0BP,IAAIG,2BAA2B,GAAG,CAACpB,KAAD,EAAQiB,QAAR,EAAkBhB,MAAlB,KAA6B;EAC7D,QAAQgB,QAAR;IACE,KAAK,OAAL;MACE;QACE,OAAOb,mBAAmB,CAACJ,KAAD,EAAQC,MAAR,CAA1B;MACD;;IACH,KAAK,OAAL;MACE;QACE,OAAOW,mBAAmB,CAACZ,KAAD,EAAQC,MAAR,CAA1B;MACD;;IACH;MACE,MAAM,IAAIiB,KAAJ,CAAU,yBAAyBC,MAAzB,CAAgCF,QAAhC,CAAV,CAAN;EAVJ;AAYD,CAbD;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAII,4BAA4B,GAAG,CAACrB,KAAD,EAAQiB,QAAR,EAAkBhB,MAAlB,KAA6B;EACrE,QAAQgB,QAAR;IACE,KAAK,OAAL;MACE;QACE,OAAOb,mBAAmB,CAACJ,KAAD,EAAQC,MAAR,CAA1B;MACD;;IACH,KAAK,OAAL;MACE;QACE,OAAOW,mBAAmB,CAACZ,KAAD,EAAQC,MAAR,CAA1B;MACD;;IACH,KAAK,WAAL;MACE;QACE,OAAOhD,eAAe,CAAC+C,KAAD,EAAQC,MAAR,CAAtB;MACD;;IACH,KAAK,YAAL;MACE;QACE,OAAO9C,gBAAgB,CAAC6C,KAAD,EAAQC,MAAR,CAAvB;MACD;;IACH;MACE,MAAM,IAAIiB,KAAJ,CAAU,yBAAyBC,MAAzB,CAAgCF,QAAhC,CAAV,CAAN;EAlBJ;AAoBD,CArBM;AAuBP;AACA;AACA;AACA;;AACA,OAAO,IAAIK,YAAY,GAAGtB,KAAK,IAAIA,KAAK,CAACuB,cAAN,CAAqBC,cAArB,CAAoCC,IAApC,CAAyCC,IAAI,IAAIA,IAAI,CAAC7B,IAAL,KAAc,KAA/D,KAAyEG,KAAK,CAACuB,cAAN,CAAqBI,UAArB,CAAgCF,IAAhC,CAAqCC,IAAI,IAAIA,IAAI,CAAC7B,IAAL,KAAc,WAA3D,CAArG;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS+B,iBAAT,CAA2BX,QAA3B,EAAqChB,MAArC,EAA6C;EAClD,OAAOyB,IAAI,IAAI;IACb,QAAQT,QAAR;MACE,KAAK,OAAL;QACE;QACA,OAAO,aAAaS,IAAb,IAAqBA,IAAI,CAACG,OAAL,KAAiB5B,MAA7C;;MACF,KAAK,OAAL;QACE,OAAO,aAAayB,IAAb,IAAqBA,IAAI,CAACI,OAAL,KAAiB7B,MAA7C;;MACF,KAAK,OAAL;QACE,OAAO,aAAayB,IAAb,IAAqBA,IAAI,CAACK,OAAL,KAAiB9B,MAA7C;;MACF,KAAK,WAAL;QACE,OAAO,iBAAiByB,IAAjB,IAAyBA,IAAI,CAACM,WAAL,KAAqB/B,MAArD;;MACF,KAAK,YAAL;QACE,OAAO,kBAAkByB,IAAlB,IAA0BA,IAAI,CAACO,YAAL,KAAsBhC,MAAvD;;MACF;QACE,OAAO,KAAP;IAbJ;EAeD,CAhBD;AAiBD,C,CAED;;AACA,OAAO,IAAIiC,8BAA8B,GAAGlC,KAAK,IAAIA,KAAK,CAACuB,cAAN,CAAqBC,cAAnE;AACP,IAAIW,mBAAmB,GAAGpH,cAAc,CAAC,CAACsC,YAAD,EAAeC,UAAf,CAAD,EAA6BsE,iBAA7B,CAAxC;AACA,OAAO,IAAIQ,6BAA6B,GAAG,CAACb,cAAD,EAAiBc,YAAjB,EAA+BC,aAA/B,KAAiDf,cAAc,CAACjI,MAAf,CAAsBgJ,aAAtB,EAAqChJ,MAArC,CAA4CoI,IAAI,IAAI;EAC9I,IAAI,CAACW,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAACvD,aAA1E,MAA6F,IAAjG,EAAuG;IACrG,OAAO,IAAP;EACD;;EACD,OAAO,CAAC4C,IAAI,CAAC9C,IAAb;AACD,CAL2F,CAArF;AAMP,OAAO,IAAI2D,4BAA4B,GAAGxH,cAAc,CAAC,CAACmH,8BAAD,EAAiClB,cAAjC,EAAiDmB,mBAAjD,CAAD,EAAwEC,6BAAxE,EAAuG;EAC7JI,cAAc,EAAE;IACdC,mBAAmB,EAAE5E;EADP;AAD6I,CAAvG,CAAjD;AAKP,OAAO,IAAI6E,mCAAmC,GAAG3H,cAAc,CAAC,CAACwH,4BAAD,CAAD,EAAiCf,cAAc,IAAI;EAChH,OAAOA,cAAc,CAAClI,MAAf,CAAsBoI,IAAI,IAAIA,IAAI,CAAC7B,IAAL,KAAc,MAAd,IAAwB6B,IAAI,CAAC7B,IAAL,KAAc,KAApE,EAA2EvG,MAA3E,CAAkFqE,SAAlF,CAAP;AACD,CAF8D,CAAxD;AAGP,OAAO,IAAIgF,8BAA8B,GAAGnB,cAAc,IAAIA,cAAc,CAAClI,MAAf,CAAsBoI,IAAI,IAAI,EAAE,aAAaA,IAAf,KAAwBA,IAAI,CAACkB,OAAL,KAAiBnE,SAAvE,CAAvD;AACP,IAAIoE,yCAAyC,GAAG9H,cAAc,CAAC,CAACwH,4BAAD,CAAD,EAAiCI,8BAAjC,CAA9D;AACA,OAAO,IAAIG,yBAAyB,GAAGtB,cAAc,IAAIA,cAAc,CAACuB,GAAf,CAAmBrB,IAAI,IAAIA,IAAI,CAACsB,IAAhC,EAAsC1J,MAAtC,CAA6C2J,OAA7C,EAAsDC,IAAtD,CAA2D,CAA3D,CAAlD;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,iCAAiC,GAAGpI,cAAc,CAAC,CAACwH,4BAAD,CAAD,EAAiCO,yBAAjC,EAA4D;EACvHN,cAAc,EAAE;IACdC,mBAAmB,EAAE5E;EADP;AADuG,CAA5D,CAAtD;AAKP,OAAO,IAAIuF,oBAAoB,GAAG,CAACC,kBAAD,EAAqBC,IAArB,KAA8B;EAC9D,IAAI;IACFC,SAAS,GAAG,EADV;IAEFC,cAFE;IAGFC;EAHE,IAIAH,IAJJ;;EAKA,IAAID,kBAAkB,CAACxJ,MAAnB,GAA4B,CAAhC,EAAmC;IACjC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,OAAOwJ,kBAAP;EACD;;EACD,OAAOE,SAAS,CAACG,KAAV,CAAgBF,cAAhB,EAAgCC,YAAY,GAAG,CAA/C,CAAP;AACD,CAzBM;AA2BP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIE,mBAAmB,GAAG5I,cAAc,CAAC,CAACoI,iCAAD,EAAoC3H,kDAApC,CAAD,EAA0F4H,oBAA1F,CAAxC;AACP,OAAO,IAAIQ,oBAAoB,GAAG,CAACZ,IAAD,EAAOX,YAAP,EAAqBwB,KAArB,KAA+B;EAC/D,IAAI,CAACxB,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAAC7D,OAA1E,KAAsF,IAA1F,EAAgG;IAC9F,OAAOwE,IAAI,CAACD,GAAL,CAASrB,IAAI,KAAK;MACvBtH,KAAK,EAAEiB,iBAAiB,CAACqG,IAAD,EAAOW,YAAY,CAAC7D,OAApB;IADD,CAAL,CAAb,CAAP;EAGD;;EACD,IAAIqF,KAAK,CAAChK,MAAN,GAAe,CAAnB,EAAsB;IACpB,OAAOgK,KAAK,CAACd,GAAN,CAAUrB,IAAI,IAAIA,IAAI,CAAClD,OAAvB,EAAgCsF,OAAhC,CAAwCtF,OAAO,IAAIwE,IAAI,CAACD,GAAL,CAASgB,KAAK,KAAK;MAC3E3J,KAAK,EAAEiB,iBAAiB,CAAC0I,KAAD,EAAQvF,OAAR;IADmD,CAAL,CAAd,CAAnD,CAAP;EAGD;;EACD,OAAOwE,IAAI,CAACD,GAAL,CAASgB,KAAK,KAAK;IACxB3J,KAAK,EAAE2J;EADiB,CAAL,CAAd,CAAP;AAGD,CAdM;AAgBP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,sBAAsB,GAAGjJ,cAAc,CAAC,CAAC4I,mBAAD,EAAsB3C,cAAtB,EAAsCuB,4BAAtC,CAAD,EAAsEqB,oBAAtE,CAA3C;AACP,OAAO,SAASK,6BAAT,CAAuChD,QAAvC,EAAiDiD,QAAjD,EAA2D;EAChE,QAAQjD,QAAR;IACE,KAAK,OAAL;MACE,OAAOiD,QAAQ,CAACC,SAAT,KAAuB,GAA9B;;IACF,KAAK,OAAL;MACE,OAAOD,QAAQ,CAACC,SAAT,KAAuB,GAA9B;;IACF;MACE,OAAO,KAAP;EANJ;AAQD;;AACD,SAASC,UAAT,CAAoBC,GAApB,EAAyB;EACvB,IAAIrI,UAAU,CAACqI,GAAD,CAAV,IAAmBA,GAAG,YAAYC,IAAtC,EAA4C;IAC1C,IAAIC,CAAC,GAAGzJ,MAAM,CAACuJ,GAAD,CAAd;;IACA,IAAIlI,mBAAmB,CAACoI,CAAD,CAAvB,EAA4B;MAC1B,OAAOA,CAAP;IACD;EACF;;EACD,OAAO9F,SAAP;AACD;;AACD,SAAS+F,UAAT,CAAoBH,GAApB,EAAyB;EACvB,IAAII,KAAK,CAACC,OAAN,CAAcL,GAAd,CAAJ,EAAwB;IACtB,IAAIM,OAAO,GAAG,CAACP,UAAU,CAACC,GAAG,CAAC,CAAD,CAAJ,CAAX,EAAqBD,UAAU,CAACC,GAAG,CAAC,CAAD,CAAJ,CAA/B,CAAd;;IACA,IAAI5I,wBAAwB,CAACkJ,OAAD,CAA5B,EAAuC;MACrC,OAAOA,OAAP;IACD;;IACD,OAAOlG,SAAP;EACD;;EACD,IAAI8F,CAAC,GAAGH,UAAU,CAACC,GAAD,CAAlB;;EACA,IAAIE,CAAC,IAAI,IAAT,EAAe;IACb,OAAO9F,SAAP;EACD;;EACD,OAAO,CAAC8F,CAAD,EAAIA,CAAJ,CAAP;AACD;;AACD,SAASK,gBAAT,CAA0B5B,IAA1B,EAAgC;EAC9B,OAAOA,IAAI,CAACD,GAAL,CAASqB,UAAT,EAAqB9K,MAArB,CAA4ByC,QAA5B,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAAS8I,uBAAT,CAAiCd,KAAjC,EAAwCe,YAAxC,EAAsDC,iBAAtD,EAAyE;EAC9E,IAAI,CAACA,iBAAD,IAAsB,OAAOD,YAAP,KAAwB,QAA9C,IAA0DhJ,KAAK,CAACgJ,YAAD,CAAnE,EAAmF;IACjF,OAAO,EAAP;EACD;;EACD,IAAI,CAACC,iBAAiB,CAAClL,MAAvB,EAA+B;IAC7B,OAAO,EAAP;EACD;;EACD,OAAO+K,gBAAgB,CAACG,iBAAiB,CAACjB,OAAlB,CAA0BkB,EAAE,IAAI;IACtD,IAAIC,UAAU,GAAG5J,iBAAiB,CAAC0I,KAAD,EAAQiB,EAAE,CAACxG,OAAX,CAAlC;IACA,IAAI0G,QAAJ,EAAcC,SAAd;;IACA,IAAIV,KAAK,CAACC,OAAN,CAAcO,UAAd,CAAJ,EAA+B;MAC7B,CAACC,QAAD,EAAWC,SAAX,IAAwBF,UAAxB;IACD,CAFD,MAEO;MACLC,QAAQ,GAAGC,SAAS,GAAGF,UAAvB;IACD;;IACD,IAAI,CAAC9I,mBAAmB,CAAC+I,QAAD,CAApB,IAAkC,CAAC/I,mBAAmB,CAACgJ,SAAD,CAA1D,EAAuE;MACrE,OAAO1G,SAAP;IACD;;IACD,OAAO,CAACqG,YAAY,GAAGI,QAAhB,EAA0BJ,YAAY,GAAGK,SAAzC,CAAP;EACD,CAZuB,CAAD,CAAvB;AAaD;AACD,OAAO,IAAIC,iBAAiB,GAAGpF,KAAK,IAAI;EACtC,IAAIiB,QAAQ,GAAGnD,qBAAqB,CAACkC,KAAD,CAApC;EACA,IAAIC,MAAM,GAAGlC,mBAAmB,CAACiC,KAAD,CAAhC;EACA,OAAOqB,4BAA4B,CAACrB,KAAD,EAAQiB,QAAR,EAAkBhB,MAAlB,CAAnC;AACD,CAJM;AAKP,OAAO,IAAIoF,wBAAwB,GAAGtK,cAAc,CAAC,CAACqK,iBAAD,CAAD,EAAsB/E,IAAI,IAAIA,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAAC7B,OAA/E,CAA7C;AACP,OAAO,IAAI8G,0BAA0B,GAAGvK,cAAc,CAAC,CAAC2H,mCAAD,EAAsClH,kDAAtC,EAA0F4J,iBAA1F,CAAD,EAA+G1H,2BAA/G,CAA/C;AACP,OAAO,IAAI6H,kBAAkB,GAAG,CAACC,aAAD,EAAgB3B,KAAhB,EAAuB4B,eAAvB,EAAwCC,iBAAxC,KAA8D;EAC5F,IAAIC,kBAAkB,GAAG,EAAzB;EACA,IAAIC,UAAU,GAAG/B,KAAK,CAACgC,MAAN,CAAa,CAACC,GAAD,EAAMpE,IAAN,KAAe;IAC3C,IAAIA,IAAI,CAACkB,OAAL,IAAgB,IAApB,EAA0B;MACxB,OAAOkD,GAAP;IACD;;IACD,IAAIC,KAAK,GAAGD,GAAG,CAACpE,IAAI,CAACkB,OAAN,CAAf;;IACA,IAAImD,KAAK,IAAI,IAAb,EAAmB;MACjBA,KAAK,GAAG,EAAR;IACD;;IACDA,KAAK,CAACtM,IAAN,CAAWiI,IAAX;IACAoE,GAAG,CAACpE,IAAI,CAACkB,OAAN,CAAH,GAAoBmD,KAApB;IACA,OAAOD,GAAP;EACD,CAXgB,EAWdH,kBAXc,CAAjB;EAYA,OAAOzM,MAAM,CAAC8M,WAAP,CAAmB9M,MAAM,CAAC+M,OAAP,CAAeL,UAAf,EAA2B7C,GAA3B,CAA+BmD,KAAK,IAAI;IAChE,IAAI,CAACtD,OAAD,EAAUrB,cAAV,IAA4B2E,KAAhC;IACA,IAAIC,qBAAqB,GAAGT,iBAAiB,GAAG,CAAC,GAAGnE,cAAJ,EAAoB6E,OAApB,EAAH,GAAmC7E,cAAhF;IACA,IAAI8E,QAAQ,GAAGF,qBAAqB,CAACpD,GAAtB,CAA0BtF,wBAA1B,CAAf;IACA,OAAO,CAACmF,OAAD,EAAU;MACf;MACA0D,WAAW,EAAElL,cAAc,CAACoK,aAAD,EAAgBa,QAAhB,EAA0BZ,eAA1B,CAFZ;MAGflE,cAAc,EAAE4E;IAHD,CAAV,CAAP;EAKD,CATyB,CAAnB,CAAP;AAUD,CAxBM;AA0BP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAII,iBAAiB,GAAGxL,cAAc,CAAC,CAACuK,0BAAD,EAA6B5C,mCAA7B,EAAkE1F,qBAAlE,EAAyFD,uBAAzF,CAAD,EAAoHwI,kBAApH,CAAtC;AACP,OAAO,IAAIiB,0BAA0B,GAAG,CAACC,WAAD,EAAcC,KAAd,EAAqBzF,QAArB,EAA+B0F,wBAA/B,KAA4D;EAClG,IAAI;IACFnD,cADE;IAEFC;EAFE,IAGAiD,KAHJ;;EAIA,IAAIC,wBAAwB,IAAI,IAAhC,EAAsC;IACpC;IACA,OAAOlI,SAAP;EACD;;EACD,IAAIwC,QAAQ,KAAK,OAAjB,EAA0B;IACxB;IACA,OAAOxC,SAAP;EACD;;EACD,IAAImI,mBAAmB,GAAGzL,sBAAsB,CAACsL,WAAD,EAAcjD,cAAd,EAA8BC,YAA9B,CAAhD;;EACA,IAAImD,mBAAmB,IAAI,IAAvB,IAA+BA,mBAAmB,CAAC,CAAD,CAAnB,KAA2B,CAA1D,IAA+DA,mBAAmB,CAAC,CAAD,CAAnB,KAA2B,CAA9F,EAAiG;IAC/F,OAAOnI,SAAP;EACD;;EACD,OAAOmI,mBAAP;AACD,CAlBM;AAmBP,IAAIC,wBAAwB,GAAG9L,cAAc,CAAC,CAACiG,cAAD,CAAD,EAAmBqB,YAAY,IAAIA,YAAY,CAACjE,iBAAhD,CAA7C;AACA,OAAO,IAAI0I,mBAAmB,GAAGzE,YAAY,IAAI;EAC/C,IAAI0E,oBAAJ;;EACA,IAAI1E,YAAY,IAAI,IAAhB,IAAwB,EAAE,YAAYA,YAAd,CAA5B,EAAyD;IACvD,OAAOnE,oBAAP;EACD;;EACD,IAAImE,YAAY,CAAC3D,MAAb,IAAuB,IAA3B,EAAiC;IAC/B,OAAO2D,YAAY,CAAC3D,MAApB;EACD;;EACD,IAAI,WAAW2D,YAAX,IAA2BA,YAAY,CAACzC,KAAb,IAAsB,IAArD,EAA2D;IACzD,IAAIyC,YAAY,CAACxC,IAAb,KAAsB,QAA1B,EAAoC;MAClC,IAAImH,SAAS,GAAGpC,gBAAgB,CAACvC,YAAY,CAACzC,KAAd,CAAhC;MACA,OAAO,CAACqH,IAAI,CAACC,GAAL,CAAS,GAAGF,SAAZ,CAAD,EAAyBC,IAAI,CAACE,GAAL,CAAS,GAAGH,SAAZ,CAAzB,CAAP;IACD;;IACD,IAAI3E,YAAY,CAACxC,IAAb,KAAsB,UAA1B,EAAsC;MACpC,OAAOwC,YAAY,CAACzC,KAAb,CAAmBmD,GAAnB,CAAuBlI,MAAvB,CAAP;IACD;EACF;;EACD,OAAO,CAACkM,oBAAoB,GAAG1E,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAAC3D,MAAjG,MAA6G,IAA7G,IAAqHqI,oBAAoB,KAAK,KAAK,CAAnJ,GAAuJA,oBAAvJ,GAA8K7I,oBAArL;AACD,CAlBM;AAmBP,OAAO,IAAIkJ,sBAAsB,GAAGrM,cAAc,CAAC,CAACiG,cAAD,CAAD,EAAmB8F,mBAAnB,CAA3C;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIO,8BAA8B,GAAGtM,cAAc,CAAC,CAACqM,sBAAD,EAAyBP,wBAAzB,CAAD,EAAqDnL,4CAArD,CAAnD;AACP,OAAO,IAAI4L,yBAAyB,GAAGvM,cAAc,CAAC,CAACwL,iBAAD,EAAoBhL,0BAApB,EAAgD8B,YAAhD,EAA8DgK,8BAA9D,CAAD,EAAgGb,0BAAhG,EAA4H;EAC/KhE,cAAc,EAAE;IACdC,mBAAmB,EAAE7E;EADP;AAD+J,CAA5H,CAA9C;AAKP,OAAO,IAAI2J,yBAAyB,GAAGvH,KAAK,IAAIA,KAAK,CAACwH,SAA/C;;AACP,IAAIC,+BAA+B,GAAG,CAACC,sBAAD,EAAyBC,mBAAzB,EAA8C1G,QAA9C,KAA2D;EAC/F,OAAOyG,sBAAsB,CAAC5D,OAAvB,CAA+BpC,IAAI,IAAI;IAC5C,OAAOiG,mBAAmB,CAACjG,IAAI,CAAC7C,EAAN,CAA1B;EACD,CAFM,EAEJvF,MAFI,CAEG2J,OAFH,EAEY3J,MAFZ,CAEmBP,CAAC,IAAI;IAC7B,OAAOkL,6BAA6B,CAAChD,QAAD,EAAWlI,CAAX,CAApC;EACD,CAJM,CAAP;AAKD,CAND;;AAOA,OAAO,IAAI6O,YAAY,GAAG,SAASA,YAAT,GAAwB;EAChD,KAAK,IAAIC,IAAI,GAAGjO,SAAS,CAACC,MAArB,EAA6BiO,OAAO,GAAG,IAAIrD,KAAJ,CAAUoD,IAAV,CAAvC,EAAwDE,IAAI,GAAG,CAApE,EAAuEA,IAAI,GAAGF,IAA9E,EAAoFE,IAAI,EAAxF,EAA4F;IAC1FD,OAAO,CAACC,IAAD,CAAP,GAAgBnO,SAAS,CAACmO,IAAD,CAAzB;EACD;;EACD,IAAIC,UAAU,GAAGF,OAAO,CAACxO,MAAR,CAAe2J,OAAf,CAAjB;;EACA,IAAI+E,UAAU,CAACnO,MAAX,KAAsB,CAA1B,EAA6B;IAC3B,OAAO4E,SAAP;EACD;;EACD,IAAIuI,SAAS,GAAGgB,UAAU,CAAC9E,IAAX,EAAhB;EACA,IAAIgE,GAAG,GAAGD,IAAI,CAACC,GAAL,CAAS,GAAGF,SAAZ,CAAV;EACA,IAAIG,GAAG,GAAGF,IAAI,CAACE,GAAL,CAAS,GAAGH,SAAZ,CAAV;EACA,OAAO,CAACE,GAAD,EAAMC,GAAN,CAAP;AACD,CAZM;AAaP,OAAO,IAAIc,4DAA4D,GAAG,CAACjF,IAAD,EAAOX,YAAP,EAAqBwB,KAArB,EAA4B2D,SAA5B,EAAuCvG,QAAvC,KAAoD;EAC5H,IAAIiH,QAAJ,EAAcC,QAAd;;EACA,IAAItE,KAAK,CAAChK,MAAN,GAAe,CAAnB,EAAsB;IACpBmJ,IAAI,CAAClJ,OAAL,CAAaiK,KAAK,IAAI;MACpBF,KAAK,CAAC/J,OAAN,CAAc4H,IAAI,IAAI;QACpB,IAAI0G,kBAAJ,EAAwBC,qBAAxB;;QACA,IAAItD,iBAAiB,GAAG,CAACqD,kBAAkB,GAAGZ,SAAS,CAAC9F,IAAI,CAAC7C,EAAN,CAA/B,MAA8C,IAA9C,IAAsDuJ,kBAAkB,KAAK,KAAK,CAAlF,GAAsF,KAAK,CAA3F,GAA+FA,kBAAkB,CAAC9O,MAAnB,CAA0B4K,QAAQ,IAAID,6BAA6B,CAAChD,QAAD,EAAWiD,QAAX,CAAnE,CAAvH;QACA,IAAIoE,cAAc,GAAGjN,iBAAiB,CAAC0I,KAAD,EAAQ,CAACsE,qBAAqB,GAAGhG,YAAY,CAAC7D,OAAtC,MAAmD,IAAnD,IAA2D6J,qBAAqB,KAAK,KAAK,CAA1F,GAA8FA,qBAA9F,GAAsH3G,IAAI,CAAClD,OAAnI,CAAtC;QACA,IAAI+J,WAAW,GAAG1D,uBAAuB,CAACd,KAAD,EAAQuE,cAAR,EAAwBvD,iBAAxB,CAAzC;;QACA,IAAIwD,WAAW,CAAC1O,MAAZ,IAAsB,CAA1B,EAA6B;UAC3B,IAAI2O,UAAU,GAAGvB,IAAI,CAACC,GAAL,CAAS,GAAGqB,WAAZ,CAAjB;UACA,IAAIE,UAAU,GAAGxB,IAAI,CAACE,GAAL,CAAS,GAAGoB,WAAZ,CAAjB;;UACA,IAAIL,QAAQ,IAAI,IAAZ,IAAoBM,UAAU,GAAGN,QAArC,EAA+C;YAC7CA,QAAQ,GAAGM,UAAX;UACD;;UACD,IAAIL,QAAQ,IAAI,IAAZ,IAAoBM,UAAU,GAAGN,QAArC,EAA+C;YAC7CA,QAAQ,GAAGM,UAAX;UACD;QACF;;QACD,IAAIC,eAAe,GAAGlE,UAAU,CAAC8D,cAAD,CAAhC;;QACA,IAAII,eAAe,IAAI,IAAvB,EAA6B;UAC3BR,QAAQ,GAAGA,QAAQ,IAAI,IAAZ,GAAmBQ,eAAe,CAAC,CAAD,CAAlC,GAAwCzB,IAAI,CAACC,GAAL,CAASgB,QAAT,EAAmBQ,eAAe,CAAC,CAAD,CAAlC,CAAnD;UACAP,QAAQ,GAAGA,QAAQ,IAAI,IAAZ,GAAmBO,eAAe,CAAC,CAAD,CAAlC,GAAwCzB,IAAI,CAACE,GAAL,CAASgB,QAAT,EAAmBO,eAAe,CAAC,CAAD,CAAlC,CAAnD;QACD;MACF,CApBD;IAqBD,CAtBD;EAuBD;;EACD,IAAI,CAACrG,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAAC7D,OAA1E,KAAsF,IAA1F,EAAgG;IAC9FwE,IAAI,CAAClJ,OAAL,CAAa4H,IAAI,IAAI;MACnB,IAAIgH,eAAe,GAAGlE,UAAU,CAACnJ,iBAAiB,CAACqG,IAAD,EAAOW,YAAY,CAAC7D,OAApB,CAAlB,CAAhC;;MACA,IAAIkK,eAAe,IAAI,IAAvB,EAA6B;QAC3BR,QAAQ,GAAGA,QAAQ,IAAI,IAAZ,GAAmBQ,eAAe,CAAC,CAAD,CAAlC,GAAwCzB,IAAI,CAACC,GAAL,CAASgB,QAAT,EAAmBQ,eAAe,CAAC,CAAD,CAAlC,CAAnD;QACAP,QAAQ,GAAGA,QAAQ,IAAI,IAAZ,GAAmBO,eAAe,CAAC,CAAD,CAAlC,GAAwCzB,IAAI,CAACE,GAAL,CAASgB,QAAT,EAAmBO,eAAe,CAAC,CAAD,CAAlC,CAAnD;MACD;IACF,CAND;EAOD;;EACD,IAAIvM,mBAAmB,CAAC+L,QAAD,CAAnB,IAAiC/L,mBAAmB,CAACgM,QAAD,CAAxD,EAAoE;IAClE,OAAO,CAACD,QAAD,EAAWC,QAAX,CAAP;EACD;;EACD,OAAO1J,SAAP;AACD,CAxCM;AAyCP,IAAIkK,2DAA2D,GAAG5N,cAAc,CAAC,CAAC4I,mBAAD,EAAsB3C,cAAtB,EAAsC6B,yCAAtC,EAAiF0E,yBAAjF,EAA4GlK,YAA5G,CAAD,EAA4H4K,4DAA5H,EAA0L;EACxQzF,cAAc,EAAE;IACdC,mBAAmB,EAAE7E;EADP;AADwP,CAA1L,CAAhF;;AAKA,SAASgL,kCAAT,CAA4ClH,IAA5C,EAAkD;EAChD,IAAI;IACFtH;EADE,IAEAsH,IAFJ;;EAGA,IAAI1F,UAAU,CAAC5B,KAAD,CAAV,IAAqBA,KAAK,YAAYkK,IAA1C,EAAgD;IAC9C,OAAOlK,KAAP;EACD;;EACD,OAAOqE,SAAP;AACD;;AACD,IAAIoK,2BAA2B,GAAG,CAACC,eAAD,EAAkBzG,YAAlB,EAAgC0G,aAAhC,KAAkD;EAClF,IAAIC,iBAAiB,GAAGF,eAAe,CAAC/F,GAAhB,CAAoB6F,kCAApB,EAAwDtP,MAAxD,CAA+D2P,CAAC,IAAIA,CAAC,IAAI,IAAzE,CAAxB;;EACA,IAAIF,aAAa,KAAK1G,YAAY,CAAC7D,OAAb,IAAwB,IAAxB,IAAgC6D,YAAY,CAAC/D,uBAAb,IAAwCzC,YAAY,CAACmN,iBAAD,CAAzF,CAAjB,EAAgI;IAC9H;AACJ;AACA;AACA;IACI,OAAOhO,KAAK,CAAC,CAAD,EAAI8N,eAAe,CAACjP,MAApB,CAAZ;EACD;;EACD,IAAIwI,YAAY,CAAC/D,uBAAjB,EAA0C;IACxC,OAAO0K,iBAAP;EACD;;EACD,OAAOvE,KAAK,CAACyE,IAAN,CAAW,IAAIC,GAAJ,CAAQH,iBAAR,CAAX,CAAP;AACD,CAbD;;AAcA,OAAO,IAAII,mBAAmB,GAAGpJ,KAAK,IAAIA,KAAK,CAACqJ,iBAAN,CAAwBC,IAA3D;AACP,OAAO,IAAIC,uBAAuB,GAAG,CAACC,QAAD,EAAWvI,QAAX,EAAqBhB,MAArB,KAAgC;EACnE,OAAOuJ,QAAQ,CAAClQ,MAAT,CAAgBmQ,EAAE,IAAIA,EAAE,CAACC,UAAH,KAAkB,cAAxC,EAAwDpQ,MAAxD,CAA+DmQ,EAAE,IAAI;IAC1E,IAAIxI,QAAQ,KAAK,OAAjB,EAA0B;MACxB,OAAOwI,EAAE,CAAC5H,OAAH,KAAe5B,MAAtB;IACD;;IACD,OAAOwJ,EAAE,CAAC3H,OAAH,KAAe7B,MAAtB;EACD,CALM,CAAP;AAMD,CAPM;AAQP,OAAO,IAAI0J,yBAAyB,GAAG5O,cAAc,CAAC,CAACqO,mBAAD,EAAsB/L,YAAtB,EAAoCC,UAApC,CAAD,EAAkDiM,uBAAlD,CAA9C;AACP,OAAO,IAAIK,oBAAoB,GAAG5J,KAAK,IAAIA,KAAK,CAACqJ,iBAAN,CAAwBQ,KAA5D;AACP,OAAO,IAAIC,0BAA0B,GAAG/O,cAAc,CAAC,CAAC6O,oBAAD,EAAuBvM,YAAvB,EAAqCC,UAArC,CAAD,EAAmDiM,uBAAnD,CAA/C;AACP,OAAO,IAAIQ,oBAAoB,GAAG/J,KAAK,IAAIA,KAAK,CAACqJ,iBAAN,CAAwBW,KAA5D;AACP,OAAO,IAAIC,0BAA0B,GAAGlP,cAAc,CAAC,CAACgP,oBAAD,EAAuB1M,YAAvB,EAAqCC,UAArC,CAAD,EAAmDiM,uBAAnD,CAA/C;AACP,OAAO,IAAIW,iBAAiB,GAAG,CAACZ,IAAD,EAAOrI,QAAP,KAAoB;EACjD,IAAIqI,IAAI,IAAI,IAAZ,EAAkB;IAChB,OAAO7K,SAAP;EACD;;EACD,IAAI0L,SAAS,GAAGvF,gBAAgB,CAAC0E,IAAI,CAACvG,GAAL,CAASqH,GAAG,IAAInJ,QAAQ,KAAK,OAAb,GAAuBmJ,GAAG,CAACC,CAA3B,GAA+BD,GAAG,CAACE,CAAnD,CAAD,CAAhC;;EACA,IAAIH,SAAS,CAACtQ,MAAV,KAAqB,CAAzB,EAA4B;IAC1B,OAAO4E,SAAP;EACD;;EACD,OAAO,CAACwI,IAAI,CAACC,GAAL,CAAS,GAAGiD,SAAZ,CAAD,EAAyBlD,IAAI,CAACE,GAAL,CAAS,GAAGgD,SAAZ,CAAzB,CAAP;AACD,CATM;AAUP,IAAII,yBAAyB,GAAGxP,cAAc,CAAC4O,yBAAD,EAA4BtM,YAA5B,EAA0C6M,iBAA1C,CAA9C;AACA,OAAO,IAAIM,kBAAkB,GAAG,CAACX,KAAD,EAAQ5I,QAAR,KAAqB;EACnD,IAAI4I,KAAK,IAAI,IAAb,EAAmB;IACjB,OAAOpL,SAAP;EACD;;EACD,IAAI0L,SAAS,GAAGvF,gBAAgB,CAACiF,KAAK,CAAC/F,OAAN,CAAc2G,IAAI,IAAI,CAACxJ,QAAQ,KAAK,OAAb,GAAuBwJ,IAAI,CAACC,EAA5B,GAAiCD,IAAI,CAACE,EAAvC,EAA2C1J,QAAQ,KAAK,OAAb,GAAuBwJ,IAAI,CAACG,EAA5B,GAAiCH,IAAI,CAACI,EAAjF,CAAtB,CAAD,CAAhC;;EACA,IAAIV,SAAS,CAACtQ,MAAV,KAAqB,CAAzB,EAA4B;IAC1B,OAAO4E,SAAP;EACD;;EACD,OAAO,CAACwI,IAAI,CAACC,GAAL,CAAS,GAAGiD,SAAZ,CAAD,EAAyBlD,IAAI,CAACE,GAAL,CAAS,GAAGgD,SAAZ,CAAzB,CAAP;AACD,CATM;AAUP,IAAIW,0BAA0B,GAAG/P,cAAc,CAAC,CAAC+O,0BAAD,EAA6BzM,YAA7B,CAAD,EAA6CmN,kBAA7C,CAA/C;;AACA,SAASO,mBAAT,CAA6BC,IAA7B,EAAmC;EACjC,IAAIC,aAAJ;;EACA,IAAID,IAAI,CAACX,CAAL,IAAU,IAAd,EAAoB;IAClB,OAAOzF,gBAAgB,CAAC,CAACoG,IAAI,CAACX,CAAN,CAAD,CAAvB;EACD;;EACD,IAAIa,kBAAkB,GAAG,CAACD,aAAa,GAAGD,IAAI,CAACG,OAAtB,MAAmC,IAAnC,IAA2CF,aAAa,KAAK,KAAK,CAAlE,GAAsE,KAAK,CAA3E,GAA+EA,aAAa,CAAClI,GAAd,CAAkBqI,CAAC,IAAIA,CAAC,CAACf,CAAzB,CAAxG;;EACA,IAAIa,kBAAkB,IAAI,IAAtB,IAA8BA,kBAAkB,CAACrR,MAAnB,KAA8B,CAAhE,EAAmE;IACjE,OAAO,EAAP;EACD;;EACD,OAAO+K,gBAAgB,CAACsG,kBAAD,CAAvB;AACD;;AACD,SAASG,mBAAT,CAA6BL,IAA7B,EAAmC;EACjC,IAAIM,cAAJ;;EACA,IAAIN,IAAI,CAACV,CAAL,IAAU,IAAd,EAAoB;IAClB,OAAO1F,gBAAgB,CAAC,CAACoG,IAAI,CAACV,CAAN,CAAD,CAAvB;EACD;;EACD,IAAIY,kBAAkB,GAAG,CAACI,cAAc,GAAGN,IAAI,CAACG,OAAvB,MAAoC,IAApC,IAA4CG,cAAc,KAAK,KAAK,CAApE,GAAwE,KAAK,CAA7E,GAAiFA,cAAc,CAACvI,GAAf,CAAmBqI,CAAC,IAAIA,CAAC,CAACd,CAA1B,CAA1G;;EACA,IAAIY,kBAAkB,IAAI,IAAtB,IAA8BA,kBAAkB,CAACrR,MAAnB,KAA8B,CAAhE,EAAmE;IACjE,OAAO,EAAP;EACD;;EACD,OAAO+K,gBAAgB,CAACsG,kBAAD,CAAvB;AACD;;AACD,OAAO,IAAIK,kBAAkB,GAAG,CAACvB,KAAD,EAAQ/I,QAAR,KAAqB;EACnD,IAAI+I,KAAK,IAAI,IAAb,EAAmB;IACjB,OAAOvL,SAAP;EACD;;EACD,IAAI0L,SAAS,GAAGH,KAAK,CAAClG,OAAN,CAAckH,IAAI,IAAI/J,QAAQ,KAAK,OAAb,GAAuB8J,mBAAmB,CAACC,IAAD,CAA1C,GAAmDK,mBAAmB,CAACL,IAAD,CAA5F,CAAhB;;EACA,IAAIb,SAAS,CAACtQ,MAAV,KAAqB,CAAzB,EAA4B;IAC1B,OAAO4E,SAAP;EACD;;EACD,OAAO,CAACwI,IAAI,CAACC,GAAL,CAAS,GAAGiD,SAAZ,CAAD,EAAyBlD,IAAI,CAACE,GAAL,CAAS,GAAGgD,SAAZ,CAAzB,CAAP;AACD,CATM;AAUP,IAAIqB,0BAA0B,GAAGzQ,cAAc,CAAC,CAACkP,0BAAD,EAA6B5M,YAA7B,CAAD,EAA6CkO,kBAA7C,CAA/C;AACA,IAAIE,6BAA6B,GAAG1Q,cAAc,CAACwP,yBAAD,EAA4BiB,0BAA5B,EAAwDV,0BAAxD,EAAoF,CAACY,UAAD,EAAaC,WAAb,EAA0BC,WAA1B,KAA0C;EAC9K,OAAOhE,YAAY,CAAC8D,UAAD,EAAaE,WAAb,EAA0BD,WAA1B,CAAnB;AACD,CAFiD,CAAlD;AAGA,OAAO,IAAIE,sBAAsB,GAAG,CAACxJ,YAAD,EAAeyJ,gBAAf,EAAiCnF,wBAAjC,EAA2DC,mBAA3D,EAAgFmF,sBAAhF,EAAwGC,uBAAxG,EAAiIC,MAAjI,EAAyIhL,QAAzI,KAAsJ;EACxL,IAAI0F,wBAAwB,IAAI,IAAhC,EAAsC;IACpC;IACA,OAAOA,wBAAP;EACD;;EACD,IAAIuF,gCAAgC,GAAGD,MAAM,KAAK,UAAX,IAAyBhL,QAAQ,KAAK,OAAtC,IAAiDgL,MAAM,KAAK,YAAX,IAA2BhL,QAAQ,KAAK,OAAhI;EACA,IAAIkL,aAAa,GAAGD,gCAAgC,GAAGtE,YAAY,CAAChB,mBAAD,EAAsBoF,uBAAtB,EAA+CD,sBAA/C,CAAf,GAAwFnE,YAAY,CAACoE,uBAAD,EAA0BD,sBAA1B,CAAxJ;EACA,OAAOpQ,wBAAwB,CAACmQ,gBAAD,EAAmBK,aAAnB,EAAkC9J,YAAY,CAACjE,iBAA/C,CAA/B;AACD,CARM;AASP,OAAO,IAAIgO,qBAAqB,GAAGrR,cAAc,CAAC,CAACiG,cAAD,EAAiBoG,sBAAjB,EAAyCC,8BAAzC,EAAyEC,yBAAzE,EAAoGqB,2DAApG,EAAiK8C,6BAAjK,EAAgMvQ,iBAAhM,EAAmNmC,YAAnN,CAAD,EAAmOwO,sBAAnO,EAA2P;EAC1SrJ,cAAc,EAAE;IACdC,mBAAmB,EAAE7E;EADP;AAD0R,CAA3P,CAA1C;AAMP;AACA;AACA;AACA;AACA;;AACA,IAAIyO,YAAY,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAnB;AACA,OAAO,IAAIC,iBAAiB,GAAG,CAACjK,YAAD,EAAe4J,MAAf,EAAuBzG,aAAvB,EAAsC+G,gBAAtC,EAAwD9G,eAAxD,EAAyExE,QAAzE,EAAmFuL,eAAnF,KAAuG;EACpI,IAAI,CAACnK,YAAY,IAAI,IAAhB,IAAwBmD,aAAa,IAAI,IAAzC,IAAiDA,aAAa,CAAC3L,MAAd,KAAyB,CAA3E,KAAiF2S,eAAe,KAAK/N,SAAzG,EAAoH;IAClH,OAAOA,SAAP;EACD;;EACD,IAAI;IACFD,OADE;IAEFqB;EAFE,IAGAwC,YAHJ;EAIA,IAAI0G,aAAa,GAAGzN,iBAAiB,CAAC2Q,MAAD,EAAShL,QAAT,CAArC;;EACA,IAAI8H,aAAa,IAAIvK,OAAO,IAAI,IAAhC,EAAsC;IACpC,IAAIiO,qBAAJ;;IACA,OAAOzR,KAAK,CAAC,CAAD,EAAI,CAACyR,qBAAqB,GAAGjH,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,aAAa,CAAC3L,MAArG,MAAiH,IAAjH,IAAyH4S,qBAAqB,KAAK,KAAK,CAAxJ,GAA4JA,qBAA5J,GAAoL,CAAxL,CAAZ;EACD;;EACD,IAAI5M,IAAI,KAAK,UAAb,EAAyB;IACvB,OAAOgJ,2BAA2B,CAAC0D,gBAAD,EAAmBlK,YAAnB,EAAiC0G,aAAjC,CAAlC;EACD;;EACD,IAAItD,eAAe,KAAK,QAAxB,EAAkC;IAChC,OAAO4G,YAAP;EACD;;EACD,OAAOG,eAAP;AACD,CApBM;AAqBP,OAAO,IAAIE,gBAAgB,GAAG3R,cAAc,CAAC,CAACiG,cAAD,EAAiB9F,iBAAjB,EAAoCyI,mBAApC,EAAyDK,sBAAzD,EAAiFhH,qBAAjF,EAAwGK,YAAxG,EAAsH+O,qBAAtH,CAAD,EAA+IE,iBAA/I,CAArC;;AACP,SAASK,oBAAT,CAA8BzN,IAA9B,EAAoC;EAClC,OAAOA,IAAI,IAAIjE,QAAf;AACD;;AACD,OAAO,IAAI2R,oBAAoB,GAAG,CAACC,UAAD,EAAaC,MAAb,EAAqBC,SAArB,KAAmC;EACnE,IAAIF,UAAU,IAAI,IAAlB,EAAwB;IACtB,OAAOpO,SAAP;EACD;;EACD,IAAI;IACFe,KADE;IAEFK;EAFE,IAGAgN,UAHJ;;EAIA,IAAIrN,KAAK,KAAK,MAAd,EAAsB;IACpB,IAAIK,IAAI,KAAK,UAAT,IAAuBkN,SAAvB,KAAqCA,SAAS,CAACC,OAAV,CAAkB,WAAlB,KAAkC,CAAlC,IAAuCD,SAAS,CAACC,OAAV,CAAkB,WAAlB,KAAkC,CAAzE,IAA8ED,SAAS,CAACC,OAAV,CAAkB,eAAlB,KAAsC,CAAtC,IAA2C,CAACF,MAA/J,CAAJ,EAA4K;MAC1K,OAAO,OAAP;IACD;;IACD,IAAIjN,IAAI,KAAK,UAAb,EAAyB;MACvB,OAAO,MAAP;IACD;;IACD,OAAO,QAAP;EACD;;EACD,IAAI,OAAOL,KAAP,KAAiB,QAArB,EAA+B;IAC7B,IAAIN,IAAI,GAAG,QAAQiC,MAAR,CAAejF,UAAU,CAACsD,KAAD,CAAzB,CAAX;IACA,OAAOmN,oBAAoB,CAACzN,IAAD,CAApB,GAA6BA,IAA7B,GAAoC,OAA3C;EACD;;EACD,OAAOT,SAAP;AACD,CAtBM;AAuBP,OAAO,IAAIwO,mBAAmB,GAAGlS,cAAc,CAAC,CAACiG,cAAD,EAAiBM,YAAjB,EAA+BxE,eAA/B,CAAD,EAAkD8P,oBAAlD,CAAxC;AACP,OAAO,SAASM,oBAAT,CAA8B7M,IAA9B,EAAoC8M,aAApC,EAAmDC,UAAnD,EAA+DC,SAA/D,EAA0E;EAC/E,IAAID,UAAU,IAAI,IAAd,IAAsBC,SAAS,IAAI,IAAvC,EAA6C;IAC3C,OAAO5O,SAAP;EACD;;EACD,IAAI,OAAO4B,IAAI,CAACb,KAAZ,KAAsB,UAA1B,EAAsC;IACpC,OAAOxB,oBAAoB,CAACqC,IAAI,CAACb,KAAN,EAAa4N,UAAb,EAAyBC,SAAzB,CAA3B;EACD;;EACD,OAAOrP,oBAAoB,CAACmP,aAAD,EAAgBC,UAAhB,EAA4BC,SAA5B,CAA3B;AACD;AACD,OAAO,IAAIC,gBAAgB,GAAG,CAACF,UAAD,EAAa/K,YAAb,EAA2B8K,aAA3B,KAA6C;EACzE,IAAIrB,gBAAgB,GAAGhF,mBAAmB,CAACzE,YAAD,CAA1C;;EACA,IAAI8K,aAAa,KAAK,MAAlB,IAA4BA,aAAa,KAAK,QAAlD,EAA4D;IAC1D,OAAO1O,SAAP;EACD;;EACD,IAAI4D,YAAY,IAAI,IAAhB,IAAwBA,YAAY,CAAC3C,SAArC,IAAkD+E,KAAK,CAACC,OAAN,CAAcoH,gBAAd,CAAlD,KAAsFA,gBAAgB,CAAC,CAAD,CAAhB,KAAwB,MAAxB,IAAkCA,gBAAgB,CAAC,CAAD,CAAhB,KAAwB,MAAhJ,KAA2JrQ,wBAAwB,CAAC2R,UAAD,CAAvL,EAAqM;IACnM,OAAOhR,iBAAiB,CAACgR,UAAD,EAAa/K,YAAY,CAAC3C,SAA1B,EAAqC2C,YAAY,CAAChE,aAAlD,CAAxB;EACD;;EACD,IAAIgE,YAAY,IAAI,IAAhB,IAAwBA,YAAY,CAAC3C,SAArC,IAAkD2C,YAAY,CAACxC,IAAb,KAAsB,QAAxE,IAAoFpE,wBAAwB,CAAC2R,UAAD,CAAhH,EAA8H;IAC5H,OAAO/Q,wBAAwB,CAAC+Q,UAAD,EAAa/K,YAAY,CAAC3C,SAA1B,EAAqC2C,YAAY,CAAChE,aAAlD,CAA/B;EACD;;EACD,OAAOI,SAAP;AACD,CAZM;AAaP,OAAO,IAAI8O,eAAe,GAAGxS,cAAc,CAAC,CAAC2R,gBAAD,EAAmBrL,4BAAnB,EAAiD4L,mBAAjD,CAAD,EAAwEK,gBAAxE,CAApC;AACP,OAAO,IAAIE,8BAA8B,GAAG,CAACnL,YAAD,EAAe3D,MAAf,EAAuB+O,SAAvB,EAAkCxM,QAAlC,KAA+C;EACzF;EACA;AACF;AACA;AACA;AACA;AACA;EACEA,QAAQ,KAAK,WAAb,IAA4B,CAACoB,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAACxC,IAA1E,MAAoF,QAAhH,IAA4HpE,wBAAwB,CAACiD,MAAD,CAApJ,IAAgK+F,KAAK,CAACC,OAAN,CAAc+I,SAAd,CAAhK,IAA4LA,SAAS,CAAC5T,MAAV,GAAmB,CAP/M,EAOkN;IAChN,IAAI6T,WAAJ,EAAiBC,UAAjB;;IACA,IAAIC,aAAa,GAAGlP,MAAM,CAAC,CAAD,CAA1B;IACA,IAAImP,YAAY,GAAG,CAACH,WAAW,GAAGD,SAAS,CAAC,CAAD,CAAxB,MAAiC,IAAjC,IAAyCC,WAAW,KAAK,KAAK,CAA9D,GAAkEA,WAAlE,GAAgF,CAAnG;IACA,IAAII,aAAa,GAAGpP,MAAM,CAAC,CAAD,CAA1B;IACA,IAAIqP,YAAY,GAAG,CAACJ,UAAU,GAAGF,SAAS,CAACA,SAAS,CAAC5T,MAAV,GAAmB,CAApB,CAAvB,MAAmD,IAAnD,IAA2D8T,UAAU,KAAK,KAAK,CAA/E,GAAmFA,UAAnF,GAAgG,CAAnH;IACA,OAAO,CAAC1G,IAAI,CAACC,GAAL,CAAS0G,aAAT,EAAwBC,YAAxB,CAAD,EAAwC5G,IAAI,CAACE,GAAL,CAAS2G,aAAT,EAAwBC,YAAxB,CAAxC,CAAP;EACD;;EACD,OAAOrP,MAAP;AACD,CAjBM;AAkBP,OAAO,IAAIsP,kCAAkC,GAAGjT,cAAc,CAAC,CAACiG,cAAD,EAAiB0L,gBAAjB,EAAmCa,eAAnC,EAAoDlQ,YAApD,CAAD,EAAoEmQ,8BAApE,CAAvD;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIS,mCAAmC,GAAGlT,cAAc,CAACiJ,sBAAD,EAAyBhD,cAAzB,EAAyC,CAAC8H,eAAD,EAAkBzG,YAAlB,KAAmC;EACzI,IAAI,CAACA,YAAD,IAAiBA,YAAY,CAACxC,IAAb,KAAsB,QAA3C,EAAqD;IACnD,OAAOpB,SAAP;EACD;;EACD,IAAIyP,6BAA6B,GAAGC,QAApC;EACA,IAAIC,YAAY,GAAG3J,KAAK,CAACyE,IAAN,CAAWtE,gBAAgB,CAACkE,eAAe,CAAC/F,GAAhB,CAAoBsL,CAAC,IAAIA,CAAC,CAACjU,KAA3B,CAAD,CAA3B,EAAgEkU,IAAhE,CAAqE,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAnF,CAAnB;EACA,IAAIC,KAAK,GAAGL,YAAY,CAAC,CAAD,CAAxB;EACA,IAAIM,IAAI,GAAGN,YAAY,CAACA,YAAY,CAACvU,MAAb,GAAsB,CAAvB,CAAvB;;EACA,IAAI4U,KAAK,IAAI,IAAT,IAAiBC,IAAI,IAAI,IAA7B,EAAmC;IACjC,OAAOP,QAAP;EACD;;EACD,IAAIQ,IAAI,GAAGD,IAAI,GAAGD,KAAlB;;EACA,IAAIE,IAAI,KAAK,CAAb,EAAgB;IACd,OAAOR,QAAP;EACD,CAdwI,CAezI;;;EACA,KAAK,IAAI5T,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6T,YAAY,CAACvU,MAAb,GAAsB,CAA1C,EAA6CU,CAAC,EAA9C,EAAkD;IAChD,IAAIqU,IAAI,GAAGR,YAAY,CAAC7T,CAAD,CAAvB;IACA,IAAIsU,IAAI,GAAGT,YAAY,CAAC7T,CAAC,GAAG,CAAL,CAAvB;;IACA,IAAIqU,IAAI,IAAI,IAAR,IAAgBC,IAAI,IAAI,IAA5B,EAAkC;MAChC;IACD;;IACD,IAAIC,QAAQ,GAAGD,IAAI,GAAGD,IAAtB;IACAV,6BAA6B,GAAGjH,IAAI,CAACC,GAAL,CAASgH,6BAAT,EAAwCY,QAAxC,CAAhC;EACD;;EACD,OAAOZ,6BAA6B,GAAGS,IAAvC;AACD,CA1B8D,CAAxD;AA2BP,IAAII,uBAAuB,GAAGhU,cAAc,CAACkT,mCAAD,EAAsC/S,iBAAtC,EAAyD2B,oBAAzD,EAA+EH,yBAA/E,EAA0G,CAACsS,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,EAAiB/P,OAAjB,KAA6BA,OAAvI,EAAgJ,CAACgQ,yBAAD,EAA4BnD,MAA5B,EAAoCoD,cAApC,EAAoDC,MAApD,EAA4DlQ,OAA5D,KAAwE;EAClQ,IAAI,CAACjD,mBAAmB,CAACiT,yBAAD,CAAxB,EAAqD;IACnD,OAAO,CAAP;EACD;;EACD,IAAIG,UAAU,GAAGtD,MAAM,KAAK,UAAX,GAAwBqD,MAAM,CAAC3Q,MAA/B,GAAwC2Q,MAAM,CAAC7O,KAAhE;;EACA,IAAIrB,OAAO,KAAK,KAAhB,EAAuB;IACrB,OAAOgQ,yBAAyB,GAAGG,UAA5B,GAAyC,CAAhD;EACD;;EACD,IAAInQ,OAAO,KAAK,QAAhB,EAA0B;IACxB,IAAIoQ,GAAG,GAAG5T,eAAe,CAACyT,cAAD,EAAiBD,yBAAyB,GAAGG,UAA7C,CAAzB;IACA,IAAIE,QAAQ,GAAGL,yBAAyB,GAAGG,UAA5B,GAAyC,CAAxD;IACA,OAAOE,QAAQ,GAAGD,GAAX,GAAiB,CAACC,QAAQ,GAAGD,GAAZ,IAAmBD,UAAnB,GAAgCC,GAAxD;EACD;;EACD,OAAO,CAAP;AACD,CAd2C,CAA5C;AAeA,OAAO,IAAIE,4BAA4B,GAAG,CAAC1P,KAAD,EAAQC,MAAR,EAAgB0P,UAAhB,KAA+B;EACvE,IAAIC,aAAa,GAAGxP,mBAAmB,CAACJ,KAAD,EAAQC,MAAR,CAAvC;;EACA,IAAI2P,aAAa,IAAI,IAAjB,IAAyB,OAAOA,aAAa,CAACxQ,OAArB,KAAiC,QAA9D,EAAwE;IACtE,OAAO,CAAP;EACD;;EACD,OAAO2P,uBAAuB,CAAC/O,KAAD,EAAQ,OAAR,EAAiBC,MAAjB,EAAyB0P,UAAzB,EAAqCC,aAAa,CAACxQ,OAAnD,CAA9B;AACD,CANM;AAOP,OAAO,IAAIyQ,4BAA4B,GAAG,CAAC7P,KAAD,EAAQC,MAAR,EAAgB0P,UAAhB,KAA+B;EACvE,IAAIG,aAAa,GAAGlP,mBAAmB,CAACZ,KAAD,EAAQC,MAAR,CAAvC;;EACA,IAAI6P,aAAa,IAAI,IAAjB,IAAyB,OAAOA,aAAa,CAAC1Q,OAArB,KAAiC,QAA9D,EAAwE;IACtE,OAAO,CAAP;EACD;;EACD,OAAO2P,uBAAuB,CAAC/O,KAAD,EAAQ,OAAR,EAAiBC,MAAjB,EAAyB0P,UAAzB,EAAqCG,aAAa,CAAC1Q,OAAnD,CAA9B;AACD,CANM;AAOP,IAAI2Q,kBAAkB,GAAGhV,cAAc,CAACqF,mBAAD,EAAsBsP,4BAAtB,EAAoD,CAACE,aAAD,EAAgBI,UAAhB,KAA+B;EACxH,IAAIC,aAAJ,EAAmBC,cAAnB;;EACA,IAAIN,aAAa,IAAI,IAArB,EAA2B;IACzB,OAAO;MACLvQ,IAAI,EAAE,CADD;MAELC,KAAK,EAAE;IAFF,CAAP;EAID;;EACD,IAAI;IACFF;EADE,IAEAwQ,aAFJ;;EAGA,IAAI,OAAOxQ,OAAP,KAAmB,QAAvB,EAAiC;IAC/B,OAAO;MACLC,IAAI,EAAE2Q,UADD;MAEL1Q,KAAK,EAAE0Q;IAFF,CAAP;EAID;;EACD,OAAO;IACL3Q,IAAI,EAAE,CAAC,CAAC4Q,aAAa,GAAG7Q,OAAO,CAACC,IAAzB,MAAmC,IAAnC,IAA2C4Q,aAAa,KAAK,KAAK,CAAlE,GAAsEA,aAAtE,GAAsF,CAAvF,IAA4FD,UAD7F;IAEL1Q,KAAK,EAAE,CAAC,CAAC4Q,cAAc,GAAG9Q,OAAO,CAACE,KAA1B,MAAqC,IAArC,IAA6C4Q,cAAc,KAAK,KAAK,CAArE,GAAyEA,cAAzE,GAA0F,CAA3F,IAAgGF;EAFlG,CAAP;AAID,CArBsC,CAAvC;AAsBA,IAAIG,kBAAkB,GAAGpV,cAAc,CAAC6F,mBAAD,EAAsBiP,4BAAtB,EAAoD,CAACC,aAAD,EAAgBE,UAAhB,KAA+B;EACxH,IAAII,YAAJ,EAAkBC,eAAlB;;EACA,IAAIP,aAAa,IAAI,IAArB,EAA2B;IACzB,OAAO;MACLvP,GAAG,EAAE,CADA;MAELC,MAAM,EAAE;IAFH,CAAP;EAID;;EACD,IAAI;IACFpB;EADE,IAEA0Q,aAFJ;;EAGA,IAAI,OAAO1Q,OAAP,KAAmB,QAAvB,EAAiC;IAC/B,OAAO;MACLmB,GAAG,EAAEyP,UADA;MAELxP,MAAM,EAAEwP;IAFH,CAAP;EAID;;EACD,OAAO;IACLzP,GAAG,EAAE,CAAC,CAAC6P,YAAY,GAAGhR,OAAO,CAACmB,GAAxB,MAAiC,IAAjC,IAAyC6P,YAAY,KAAK,KAAK,CAA/D,GAAmEA,YAAnE,GAAkF,CAAnF,IAAwFJ,UADxF;IAELxP,MAAM,EAAE,CAAC,CAAC6P,eAAe,GAAGjR,OAAO,CAACoB,MAA3B,MAAuC,IAAvC,IAA+C6P,eAAe,KAAK,KAAK,CAAxE,GAA4EA,eAA5E,GAA8F,CAA/F,IAAoGL;EAFvG,CAAP;AAID,CArBsC,CAAvC;AAsBA,OAAO,IAAIM,iBAAiB,GAAGvV,cAAc,CAAC,CAAC2B,yBAAD,EAA4BqT,kBAA5B,EAAgDpT,qBAAhD,EAAuEC,mBAAvE,EAA4F,CAAC2T,MAAD,EAASC,OAAT,EAAkBb,UAAlB,KAAiCA,UAA7H,CAAD,EAA2I,CAACL,MAAD,EAASlQ,OAAT,EAAkBqR,eAAlB,EAAmCC,KAAnC,EAA0Cf,UAA1C,KAAyD;EAC/O,IAAI;IACFvQ,OAAO,EAAEuR;EADP,IAEAD,KAFJ;;EAGA,IAAIf,UAAJ,EAAgB;IACd,OAAO,CAACgB,YAAY,CAACtR,IAAd,EAAoBoR,eAAe,CAAChQ,KAAhB,GAAwBkQ,YAAY,CAACrR,KAAzD,CAAP;EACD;;EACD,OAAO,CAACgQ,MAAM,CAACjQ,IAAP,GAAcD,OAAO,CAACC,IAAvB,EAA6BiQ,MAAM,CAACjQ,IAAP,GAAciQ,MAAM,CAAC7O,KAArB,GAA6BrB,OAAO,CAACE,KAAlE,CAAP;AACD,CAR4C,CAAtC;AASP,OAAO,IAAIsR,iBAAiB,GAAG7V,cAAc,CAAC,CAAC2B,yBAAD,EAA4BxB,iBAA5B,EAA+CiV,kBAA/C,EAAmExT,qBAAnE,EAA0FC,mBAA1F,EAA+G,CAAC2T,MAAD,EAASC,OAAT,EAAkBb,UAAlB,KAAiCA,UAAhJ,CAAD,EAA8J,CAACL,MAAD,EAASrD,MAAT,EAAiB7M,OAAjB,EAA0BqR,eAA1B,EAA2CI,KAA3C,EAAkDlB,UAAlD,KAAiE;EAC1Q,IAAI;IACFvQ,OAAO,EAAEuR;EADP,IAEAE,KAFJ;;EAGA,IAAIlB,UAAJ,EAAgB;IACd,OAAO,CAACc,eAAe,CAAC9R,MAAhB,GAAyBgS,YAAY,CAACnQ,MAAvC,EAA+CmQ,YAAY,CAACpQ,GAA5D,CAAP;EACD;;EACD,IAAI0L,MAAM,KAAK,YAAf,EAA6B;IAC3B,OAAO,CAACqD,MAAM,CAAC/O,GAAP,GAAa+O,MAAM,CAAC3Q,MAApB,GAA6BS,OAAO,CAACoB,MAAtC,EAA8C8O,MAAM,CAAC/O,GAAP,GAAanB,OAAO,CAACmB,GAAnE,CAAP;EACD;;EACD,OAAO,CAAC+O,MAAM,CAAC/O,GAAP,GAAanB,OAAO,CAACmB,GAAtB,EAA2B+O,MAAM,CAAC/O,GAAP,GAAa+O,MAAM,CAAC3Q,MAApB,GAA6BS,OAAO,CAACoB,MAAhE,CAAP;AACD,CAX4C,CAAtC;AAYP,OAAO,IAAIsQ,eAAe,GAAG,CAAC9Q,KAAD,EAAQiB,QAAR,EAAkBhB,MAAlB,EAA0B0P,UAA1B,KAAyC;EACpE,IAAIoB,oBAAJ;;EACA,QAAQ9P,QAAR;IACE,KAAK,OAAL;MACE,OAAOqP,iBAAiB,CAACtQ,KAAD,EAAQC,MAAR,EAAgB0P,UAAhB,CAAxB;;IACF,KAAK,OAAL;MACE,OAAOiB,iBAAiB,CAAC5Q,KAAD,EAAQC,MAAR,EAAgB0P,UAAhB,CAAxB;;IACF,KAAK,OAAL;MACE,OAAO,CAACoB,oBAAoB,GAAGjQ,mBAAmB,CAACd,KAAD,EAAQC,MAAR,CAA3C,MAAgE,IAAhE,IAAwE8Q,oBAAoB,KAAK,KAAK,CAAtG,GAA0G,KAAK,CAA/G,GAAmHA,oBAAoB,CAAC/V,KAA/I;;IACF,KAAK,WAAL;MACE,OAAOkC,oBAAoB,CAAC8C,KAAD,CAA3B;;IACF,KAAK,YAAL;MACE,OAAO5C,qBAAqB,CAAC4C,KAAD,EAAQC,MAAR,CAA5B;;IACF;MACE,OAAOxB,SAAP;EAZJ;AAcD,CAhBM;AAiBP,OAAO,IAAIuS,0BAA0B,GAAGjW,cAAc,CAAC,CAACiG,cAAD,EAAiB8P,eAAjB,CAAD,EAAoCvT,2BAApC,CAA/C;AACP,IAAI0T,uBAAuB,GAAGlW,cAAc,CAAC,CAACkS,mBAAD,EAAsBe,kCAAtB,CAAD,EAA4D/P,oBAA5D,CAA5C;AACA,OAAO,IAAIiT,eAAe,GAAGnW,cAAc,CAAC,CAACiG,cAAD,EAAiBiM,mBAAjB,EAAsCgE,uBAAtC,EAA+DD,0BAA/D,CAAD,EAA6F9D,oBAA7F,CAApC;AACP,OAAO,IAAIiE,uBAAuB,GAAGpW,cAAc,CAAC,CAACwH,4BAAD,EAA+BgF,yBAA/B,EAA0DlK,YAA1D,CAAD,EAA0EoK,+BAA1E,CAA5C;;AACP,SAAS2J,UAAT,CAAoB7C,CAApB,EAAuBC,CAAvB,EAA0B;EACxB,IAAID,CAAC,CAAC1P,EAAF,GAAO2P,CAAC,CAAC3P,EAAb,EAAiB;IACf,OAAO,CAAC,CAAR;EACD;;EACD,IAAI0P,CAAC,CAAC1P,EAAF,GAAO2P,CAAC,CAAC3P,EAAb,EAAiB;IACf,OAAO,CAAP;EACD;;EACD,OAAO,CAAP;AACD;;AACD,IAAIwS,mBAAmB,GAAG,CAACd,MAAD,EAASpR,WAAT,KAAyBA,WAAnD;;AACA,IAAImS,UAAU,GAAG,CAACf,MAAD,EAASgB,YAAT,EAAuBtS,MAAvB,KAAkCA,MAAnD;;AACA,IAAIuS,4BAA4B,GAAGzW,cAAc,CAACyB,cAAD,EAAiB6U,mBAAjB,EAAsCC,UAAtC,EAAkD,CAACG,OAAD,EAAUtS,WAAV,EAAuBF,MAAvB,KAAkCwS,OAAO,CAACnY,MAAR,CAAe+G,IAAI,IAAIA,IAAI,CAAClB,WAAL,KAAqBA,WAA5C,EAAyD7F,MAAzD,CAAgE+G,IAAI,IAAIA,IAAI,CAACpB,MAAL,KAAgBA,MAAxF,EAAgGqP,IAAhG,CAAqG8C,UAArG,CAApF,CAAjD;AACA,IAAIM,4BAA4B,GAAG3W,cAAc,CAAC0B,cAAD,EAAiB4U,mBAAjB,EAAsCC,UAAtC,EAAkD,CAACG,OAAD,EAAUtS,WAAV,EAAuBF,MAAvB,KAAkCwS,OAAO,CAACnY,MAAR,CAAe+G,IAAI,IAAIA,IAAI,CAAClB,WAAL,KAAqBA,WAA5C,EAAyD7F,MAAzD,CAAgE+G,IAAI,IAAIA,IAAI,CAACpB,MAAL,KAAgBA,MAAxF,EAAgGqP,IAAhG,CAAqG8C,UAArG,CAApF,CAAjD;;AACA,IAAIO,YAAY,GAAG,CAACrC,MAAD,EAASjN,YAAT,KAA0B;EAC3C,OAAO;IACL5B,KAAK,EAAE6O,MAAM,CAAC7O,KADT;IAEL9B,MAAM,EAAE0D,YAAY,CAAC1D;EAFhB,CAAP;AAID,CALD;;AAMA,IAAIiT,YAAY,GAAG,CAACtC,MAAD,EAASjN,YAAT,KAA0B;EAC3C,IAAI5B,KAAK,GAAG,OAAO4B,YAAY,CAAC5B,KAApB,KAA8B,QAA9B,GAAyC4B,YAAY,CAAC5B,KAAtD,GAA8DjD,oBAA1E;EACA,OAAO;IACLiD,KADK;IAEL9B,MAAM,EAAE2Q,MAAM,CAAC3Q;EAFV,CAAP;AAID,CAND;;AAOA,OAAO,IAAIkT,eAAe,GAAG9W,cAAc,CAAC2B,yBAAD,EAA4B0D,mBAA5B,EAAiDuR,YAAjD,CAApC;;AACP,IAAIG,iCAAiC,GAAG,CAACxC,MAAD,EAASnQ,WAAT,EAAsB4S,WAAtB,KAAsC;EAC5E,QAAQ5S,WAAR;IACE,KAAK,KAAL;MACE,OAAOmQ,MAAM,CAAC/O,GAAd;;IACF,KAAK,QAAL;MACE,OAAOwR,WAAW,GAAGzC,MAAM,CAAC9O,MAA5B;;IACF;MACE,OAAO,CAAP;EANJ;AAQD,CATD;;AAUA,IAAIwR,iCAAiC,GAAG,CAAC1C,MAAD,EAASnQ,WAAT,EAAsB8S,UAAtB,KAAqC;EAC3E,QAAQ9S,WAAR;IACE,KAAK,MAAL;MACE,OAAOmQ,MAAM,CAACjQ,IAAd;;IACF,KAAK,OAAL;MACE,OAAO4S,UAAU,GAAG3C,MAAM,CAAChQ,KAA3B;;IACF;MACE,OAAO,CAAP;EANJ;AAQD,CATD;;AAUA,OAAO,IAAI4S,yBAAyB,GAAGnX,cAAc,CAACuB,iBAAD,EAAoBI,yBAApB,EAA+C8U,4BAA/C,EAA6EH,mBAA7E,EAAkGC,UAAlG,EAA8G,CAACS,WAAD,EAAczC,MAAd,EAAsB6C,yBAAtB,EAAiDhT,WAAjD,EAA8DF,MAA9D,KAAyE;EAC1O,IAAImT,KAAK,GAAG,EAAZ;EACA,IAAIC,QAAJ;EACAF,yBAAyB,CAACrY,OAA1B,CAAkCuG,IAAI,IAAI;IACxC,IAAIiS,QAAQ,GAAGX,YAAY,CAACrC,MAAD,EAASjP,IAAT,CAA3B;;IACA,IAAIgS,QAAQ,IAAI,IAAhB,EAAsB;MACpBA,QAAQ,GAAGP,iCAAiC,CAACxC,MAAD,EAASnQ,WAAT,EAAsB4S,WAAtB,CAA5C;IACD;;IACD,IAAIQ,SAAS,GAAGpT,WAAW,KAAK,KAAhB,IAAyB,CAACF,MAA1B,IAAoCE,WAAW,KAAK,QAAhB,IAA4BF,MAAhF;IACAmT,KAAK,CAAC/R,IAAI,CAACxB,EAAN,CAAL,GAAiBwT,QAAQ,GAAGvX,MAAM,CAACyX,SAAD,CAAN,GAAoBD,QAAQ,CAAC3T,MAAzD;IACA0T,QAAQ,IAAI,CAACE,SAAS,GAAG,CAAC,CAAJ,GAAQ,CAAlB,IAAuBD,QAAQ,CAAC3T,MAA5C;EACD,CARD;EASA,OAAOyT,KAAP;AACD,CAboD,CAA9C;AAcP,OAAO,IAAII,yBAAyB,GAAGzX,cAAc,CAACwB,gBAAD,EAAmBG,yBAAnB,EAA8CgV,4BAA9C,EAA4EL,mBAA5E,EAAiGC,UAAjG,EAA6G,CAACW,UAAD,EAAa3C,MAAb,EAAqB6C,yBAArB,EAAgDhT,WAAhD,EAA6DF,MAA7D,KAAwE;EACxO,IAAImT,KAAK,GAAG,EAAZ;EACA,IAAIC,QAAJ;EACAF,yBAAyB,CAACrY,OAA1B,CAAkCuG,IAAI,IAAI;IACxC,IAAIiS,QAAQ,GAAGV,YAAY,CAACtC,MAAD,EAASjP,IAAT,CAA3B;;IACA,IAAIgS,QAAQ,IAAI,IAAhB,EAAsB;MACpBA,QAAQ,GAAGL,iCAAiC,CAAC1C,MAAD,EAASnQ,WAAT,EAAsB8S,UAAtB,CAA5C;IACD;;IACD,IAAIM,SAAS,GAAGpT,WAAW,KAAK,MAAhB,IAA0B,CAACF,MAA3B,IAAqCE,WAAW,KAAK,OAAhB,IAA2BF,MAAhF;IACAmT,KAAK,CAAC/R,IAAI,CAACxB,EAAN,CAAL,GAAiBwT,QAAQ,GAAGvX,MAAM,CAACyX,SAAD,CAAN,GAAoBD,QAAQ,CAAC7R,KAAzD;IACA4R,QAAQ,IAAI,CAACE,SAAS,GAAG,CAAC,CAAJ,GAAQ,CAAlB,IAAuBD,QAAQ,CAAC7R,KAA5C;EACD,CARD;EASA,OAAO2R,KAAP;AACD,CAboD,CAA9C;;AAcP,IAAIK,sBAAsB,GAAG,CAACzS,KAAD,EAAQC,MAAR,KAAmB;EAC9C,IAAIoC,YAAY,GAAGjC,mBAAmB,CAACJ,KAAD,EAAQC,MAAR,CAAtC;;EACA,IAAIoC,YAAY,IAAI,IAApB,EAA0B;IACxB,OAAO5D,SAAP;EACD;;EACD,OAAOyT,yBAAyB,CAAClS,KAAD,EAAQqC,YAAY,CAAClD,WAArB,EAAkCkD,YAAY,CAACpD,MAA/C,CAAhC;AACD,CAND;;AAOA,OAAO,IAAIyT,mBAAmB,GAAG3X,cAAc,CAAC,CAAC2B,yBAAD,EAA4B0D,mBAA5B,EAAiDqS,sBAAjD,EAAyE,CAACE,CAAD,EAAI1S,MAAJ,KAAeA,MAAxF,CAAD,EAAkG,CAACqP,MAAD,EAASjN,YAAT,EAAuBuQ,QAAvB,EAAiC3S,MAAjC,KAA4C;EAC3L,IAAIoC,YAAY,IAAI,IAApB,EAA0B;IACxB,OAAO5D,SAAP;EACD;;EACD,IAAIoU,cAAc,GAAGD,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC3S,MAAD,CAAjF;;EACA,IAAI4S,cAAc,IAAI,IAAtB,EAA4B;IAC1B,OAAO;MACLxI,CAAC,EAAEiF,MAAM,CAACjQ,IADL;MAELiL,CAAC,EAAE;IAFE,CAAP;EAID;;EACD,OAAO;IACLD,CAAC,EAAEiF,MAAM,CAACjQ,IADL;IAELiL,CAAC,EAAEuI;EAFE,CAAP;AAID,CAf8C,CAAxC;;AAgBP,IAAIC,sBAAsB,GAAG,CAAC9S,KAAD,EAAQC,MAAR,KAAmB;EAC9C,IAAIoC,YAAY,GAAGzB,mBAAmB,CAACZ,KAAD,EAAQC,MAAR,CAAtC;;EACA,IAAIoC,YAAY,IAAI,IAApB,EAA0B;IACxB,OAAO5D,SAAP;EACD;;EACD,OAAO+T,yBAAyB,CAACxS,KAAD,EAAQqC,YAAY,CAAClD,WAArB,EAAkCkD,YAAY,CAACpD,MAA/C,CAAhC;AACD,CAND;;AAOA,OAAO,IAAI8T,mBAAmB,GAAGhY,cAAc,CAAC,CAAC2B,yBAAD,EAA4BkE,mBAA5B,EAAiDkS,sBAAjD,EAAyE,CAACH,CAAD,EAAI1S,MAAJ,KAAeA,MAAxF,CAAD,EAAkG,CAACqP,MAAD,EAASjN,YAAT,EAAuBuQ,QAAvB,EAAiC3S,MAAjC,KAA4C;EAC3L,IAAIoC,YAAY,IAAI,IAApB,EAA0B;IACxB,OAAO5D,SAAP;EACD;;EACD,IAAIoU,cAAc,GAAGD,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC3S,MAAD,CAAjF;;EACA,IAAI4S,cAAc,IAAI,IAAtB,EAA4B;IAC1B,OAAO;MACLxI,CAAC,EAAE,CADE;MAELC,CAAC,EAAEgF,MAAM,CAAC/O;IAFL,CAAP;EAID;;EACD,OAAO;IACL8J,CAAC,EAAEwI,cADE;IAELvI,CAAC,EAAEgF,MAAM,CAAC/O;EAFL,CAAP;AAID,CAf8C,CAAxC;AAgBP,OAAO,IAAIyS,eAAe,GAAGjY,cAAc,CAAC2B,yBAAD,EAA4BkE,mBAA5B,EAAiD,CAAC0O,MAAD,EAASjN,YAAT,KAA0B;EACpH,IAAI5B,KAAK,GAAG,OAAO4B,YAAY,CAAC5B,KAApB,KAA8B,QAA9B,GAAyC4B,YAAY,CAAC5B,KAAtD,GAA8DjD,oBAA1E;EACA,OAAO;IACLiD,KADK;IAEL9B,MAAM,EAAE2Q,MAAM,CAAC3Q;EAFV,CAAP;AAID,CAN0C,CAApC;AAOP,OAAO,IAAIsU,uBAAuB,GAAG,CAACjT,KAAD,EAAQiB,QAAR,EAAkBhB,MAAlB,KAA6B;EAChE,QAAQgB,QAAR;IACE,KAAK,OAAL;MACE;QACE,OAAO4Q,eAAe,CAAC7R,KAAD,EAAQC,MAAR,CAAf,CAA+BQ,KAAtC;MACD;;IACH,KAAK,OAAL;MACE;QACE,OAAOuS,eAAe,CAAChT,KAAD,EAAQC,MAAR,CAAf,CAA+BtB,MAAtC;MACD;;IACH;MACE;QACE,OAAOF,SAAP;MACD;EAZL;AAcD,CAfM;AAgBP,OAAO,IAAIyU,sBAAsB,GAAG,CAACC,WAAD,EAAcC,aAAd,EAA6B/S,IAA7B,EAAmCY,QAAnC,KAAgD;EAClF,IAAIZ,IAAI,IAAI,IAAZ,EAAkB;IAChB,OAAO5B,SAAP;EACD;;EACD,IAAI;IACFH,uBADE;IAEFuB,IAFE;IAGFrB;EAHE,IAIA6B,IAJJ;EAKA,IAAI0I,aAAa,GAAGzN,iBAAiB,CAAC6X,WAAD,EAAclS,QAAd,CAArC;EACA,IAAIoS,OAAO,GAAGD,aAAa,CAACrQ,GAAd,CAAkBuQ,EAAE,IAAIA,EAAE,CAAClZ,KAA3B,CAAd;;EACA,IAAIoE,OAAO,IAAIuK,aAAX,IAA4BlJ,IAAI,KAAK,UAArC,IAAmDvB,uBAAnD,IAA8EzC,YAAY,CAACwX,OAAD,CAA9F,EAAyG;IACvG,OAAOA,OAAP;EACD;;EACD,OAAO5U,SAAP;AACD,CAfM;AAgBP,OAAO,IAAI8U,qBAAqB,GAAGxY,cAAc,CAAC,CAACG,iBAAD,EAAoB8I,sBAApB,EAA4ChD,cAA5C,EAA4D3D,YAA5D,CAAD,EAA4E6V,sBAA5E,CAA1C;AACP,OAAO,IAAIM,wBAAwB,GAAG,CAACvH,MAAD,EAASmH,aAAT,EAAwB/S,IAAxB,EAA8BY,QAA9B,KAA2C;EAC/E,IAAIZ,IAAI,IAAI,IAAR,IAAgBA,IAAI,CAAC7B,OAAL,IAAgB,IAApC,EAA0C;IACxC,OAAOC,SAAP;EACD;;EACD,IAAI;IACFoB,IADE;IAEFL;EAFE,IAGAa,IAHJ;EAIA,IAAI0I,aAAa,GAAGzN,iBAAiB,CAAC2Q,MAAD,EAAShL,QAAT,CAArC;;EACA,IAAI8H,aAAa,KAAKlJ,IAAI,KAAK,QAAT,IAAqBL,KAAK,KAAK,MAApC,CAAjB,EAA8D;IAC5D,OAAO4T,aAAa,CAACrQ,GAAd,CAAkBsL,CAAC,IAAIA,CAAC,CAACjU,KAAzB,CAAP;EACD;;EACD,OAAOqE,SAAP;AACD,CAbM;AAcP,OAAO,IAAIgV,uBAAuB,GAAG1Y,cAAc,CAAC,CAACG,iBAAD,EAAoB8I,sBAApB,EAA4C3C,4BAA5C,EAA0EhE,YAA1E,CAAD,EAA0FmW,wBAA1F,CAA5C;AACP,OAAO,IAAIE,mDAAmD,GAAG3Y,cAAc,CAAC,CAACG,iBAAD,EAAoBkG,2BAApB,EAAiD6L,mBAAjD,EAAsEiE,eAAtE,EAAuFqC,qBAAvF,EAA8GE,uBAA9G,EAAuI3C,eAAvI,EAAwJvD,eAAxJ,EAAyKlQ,YAAzK,CAAD,EAAyL,CAAC4O,MAAD,EAAS5L,IAAT,EAAe8M,aAAf,EAA8B3N,KAA9B,EAAqCmU,eAArC,EAAsD3K,iBAAtD,EAAyEqE,SAAzE,EAAoFI,SAApF,EAA+FxM,QAA/F,KAA4G;EAClX,IAAIZ,IAAI,IAAI,IAAZ,EAAkB;IAChB,OAAO5B,SAAP;EACD;;EACD,IAAIsK,aAAa,GAAGzN,iBAAiB,CAAC2Q,MAAD,EAAShL,QAAT,CAArC;EACA,OAAO;IACL1C,KAAK,EAAE8B,IAAI,CAAC9B,KADP;IAELQ,QAAQ,EAAEsB,IAAI,CAACtB,QAFV;IAGLC,UAAU,EAAEqB,IAAI,CAACrB,UAHZ;IAILG,WAAW,EAAEkB,IAAI,CAAClB,WAJb;IAKLM,IAAI,EAAEY,IAAI,CAACZ,IALN;IAMLC,SAAS,EAAEW,IAAI,CAACX,SANX;IAOLC,aAAa,EAAEU,IAAI,CAACV,aAPf;IAQLC,KAAK,EAAES,IAAI,CAACT,KARP;IASLC,IAAI,EAAEQ,IAAI,CAACR,IATN;IAULC,IAAI,EAAEO,IAAI,CAACP,IAVN;IAWLmB,QAXK;IAYL+H,iBAZK;IAaL2K,eAbK;IAcL5K,aAdK;IAeL0E,SAfK;IAgBLzS,KAAK,EAAEqS,SAhBF;IAiBLF,aAjBK;IAkBL3N;EAlBK,CAAP;AAoBD,CAzB8E,CAAxE;AA2BP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIoU,gBAAgB,GAAG,CAAC3H,MAAD,EAAS5L,IAAT,EAAe8M,aAAf,EAA8B3N,KAA9B,EAAqCiO,SAArC,EAAgDJ,SAAhD,EAA2DsG,eAA3D,EAA4E3K,iBAA5E,EAA+F/H,QAA/F,KAA4G;EACxI,IAAIZ,IAAI,IAAI,IAAR,IAAgBb,KAAK,IAAI,IAA7B,EAAmC;IACjC,OAAOf,SAAP;EACD;;EACD,IAAIsK,aAAa,GAAGzN,iBAAiB,CAAC2Q,MAAD,EAAShL,QAAT,CAArC;EACA,IAAI;IACFpB,IADE;IAEFD,KAFE;IAGFF;EAHE,IAIAW,IAJJ;EAKA,IAAIwT,aAAa,GACjB;EACA1G,aAAa,KAAK,WAAlB,IAAiC,OAAO3N,KAAK,CAACsU,SAAb,KAA2B,UAA5D,GAAyEtU,KAAK,CAACsU,SAAN,KAAoB,CAA7F,GAAiG,CAFjG;EAGA,IAAIxE,MAAM,GAAGzP,IAAI,KAAK,UAAT,IAAuBL,KAAK,CAACsU,SAA7B,GAAyCtU,KAAK,CAACsU,SAAN,KAAoBD,aAA7D,GAA6E,CAA1F;EACAvE,MAAM,GAAGrO,QAAQ,KAAK,WAAb,IAA4BoM,SAAS,IAAI,IAAzC,IAAiDA,SAAS,CAACxT,MAAV,IAAoB,CAArE,GAAyEoC,QAAQ,CAACoR,SAAS,CAAC,CAAD,CAAT,GAAeA,SAAS,CAAC,CAAD,CAAzB,CAAR,GAAwC,CAAxC,GAA4CiC,MAArH,GAA8HA,MAAvI,CAdwI,CAgBxI;;EACA,IAAIyE,gBAAgB,GAAGnU,KAAK,IAAI6N,SAAhC;;EACA,IAAIsG,gBAAJ,EAAsB;IACpB,OAAOA,gBAAgB,CAAChR,GAAjB,CAAqB,CAACgB,KAAD,EAAQiQ,KAAR,KAAkB;MAC5C,IAAIC,YAAY,GAAGN,eAAe,GAAGA,eAAe,CAAC3G,OAAhB,CAAwBjJ,KAAxB,CAAH,GAAoCA,KAAtE;MACA,IAAImQ,MAAM,GAAG1U,KAAK,CAACuD,GAAN,CAAUkR,YAAV,CAAb;;MACA,IAAI,CAAC9X,mBAAmB,CAAC+X,MAAD,CAAxB,EAAkC;QAChC,OAAO,IAAP;MACD;;MACD,OAAO;QACLF,KADK;QAELG,UAAU,EAAED,MAAM,GAAG5E,MAFhB;QAGLlV,KAAK,EAAE2J,KAHF;QAILuL;MAJK,CAAP;IAMD,CAZM,EAYJhW,MAZI,CAYGyC,QAZH,CAAP;EAaD,CAhCuI,CAkCxI;;;EACA,IAAIgN,aAAa,IAAIC,iBAArB,EAAwC;IACtC,OAAOA,iBAAiB,CAACjG,GAAlB,CAAsB,CAACgB,KAAD,EAAQiQ,KAAR,KAAkB;MAC7C,IAAIE,MAAM,GAAG1U,KAAK,CAACuD,GAAN,CAAUgB,KAAV,CAAb;;MACA,IAAI,CAAC5H,mBAAmB,CAAC+X,MAAD,CAAxB,EAAkC;QAChC,OAAO,IAAP;MACD;;MACD,OAAO;QACLC,UAAU,EAAED,MAAM,GAAG5E,MADhB;QAELlV,KAAK,EAAE2J,KAFF;QAGLiQ,KAHK;QAIL1E;MAJK,CAAP;IAMD,CAXM,EAWJhW,MAXI,CAWGyC,QAXH,CAAP;EAYD;;EACD,IAAIyD,KAAK,CAACI,KAAV,EAAiB;IACf,OAAOJ,KAAK,CAACI,KAAN,CAAYF,SAAZ,EAAuBqD,GAAvB,CAA2B,CAACgB,KAAD,EAAQiQ,KAAR,KAAkB;MAClD,IAAIE,MAAM,GAAG1U,KAAK,CAACuD,GAAN,CAAUgB,KAAV,CAAb;;MACA,IAAI,CAAC5H,mBAAmB,CAAC+X,MAAD,CAAxB,EAAkC;QAChC,OAAO,IAAP;MACD;;MACD,OAAO;QACLC,UAAU,EAAED,MAAM,GAAG5E,MADhB;QAELlV,KAAK,EAAE2J,KAFF;QAGLiQ,KAHK;QAIL1E;MAJK,CAAP;IAMD,CAXM,EAWJhW,MAXI,CAWGyC,QAXH,CAAP;EAYD,CA9DuI,CAgExI;;;EACA,OAAOyD,KAAK,CAACd,MAAN,GAAeqE,GAAf,CAAmB,CAACgB,KAAD,EAAQiQ,KAAR,KAAkB;IAC1C,IAAIE,MAAM,GAAG1U,KAAK,CAACuD,GAAN,CAAUgB,KAAV,CAAb;;IACA,IAAI,CAAC5H,mBAAmB,CAAC+X,MAAD,CAAxB,EAAkC;MAChC,OAAO,IAAP;IACD;;IACD,OAAO;MACLC,UAAU,EAAED,MAAM,GAAG5E,MADhB;MAEL;MACAlV,KAAK,EAAEuZ,eAAe,GAAGA,eAAe,CAAC5P,KAAD,CAAlB,GAA4BA,KAH7C;MAILiQ,KAJK;MAKL1E;IALK,CAAP;EAOD,CAZM,EAYJhW,MAZI,CAYGyC,QAZH,CAAP;AAaD,CA9EM;AA+EP,OAAO,IAAIqY,iBAAiB,GAAGrZ,cAAc,CAAC,CAACG,iBAAD,EAAoBmG,4BAApB,EAAkD4L,mBAAlD,EAAuEiE,eAAvE,EAAwF3D,eAAxF,EAAyGuD,eAAzG,EAA0HyC,qBAA1H,EAAiJE,uBAAjJ,EAA0KpW,YAA1K,CAAD,EAA0LuW,gBAA1L,CAAtC;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIS,yBAAyB,GAAG,CAACpI,MAAD,EAAS5L,IAAT,EAAeb,KAAf,EAAsB6N,SAAtB,EAAiCsG,eAAjC,EAAkD3K,iBAAlD,EAAqE/H,QAArE,KAAkF;EACvH,IAAIZ,IAAI,IAAI,IAAR,IAAgBb,KAAK,IAAI,IAAzB,IAAiC6N,SAAS,IAAI,IAA9C,IAAsDA,SAAS,CAAC,CAAD,CAAT,KAAiBA,SAAS,CAAC,CAAD,CAApF,EAAyF;IACvF,OAAO5O,SAAP;EACD;;EACD,IAAIsK,aAAa,GAAGzN,iBAAiB,CAAC2Q,MAAD,EAAShL,QAAT,CAArC;EACA,IAAI;IACFvB;EADE,IAEAW,IAFJ;EAGA,IAAIiP,MAAM,GAAG,CAAb;EACAA,MAAM,GAAGrO,QAAQ,KAAK,WAAb,IAA4B,CAACoM,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACxT,MAAjE,KAA4E,CAAxG,GAA4GoC,QAAQ,CAACoR,SAAS,CAAC,CAAD,CAAT,GAAeA,SAAS,CAAC,CAAD,CAAzB,CAAR,GAAwC,CAAxC,GAA4CiC,MAAxJ,GAAiKA,MAA1K,CATuH,CAWvH;;EACA,IAAIvG,aAAa,IAAIC,iBAArB,EAAwC;IACtC,OAAOA,iBAAiB,CAACjG,GAAlB,CAAsB,CAACgB,KAAD,EAAQiQ,KAAR,KAAkB;MAC7C,IAAIE,MAAM,GAAG1U,KAAK,CAACuD,GAAN,CAAUgB,KAAV,CAAb;;MACA,IAAI,CAAC5H,mBAAmB,CAAC+X,MAAD,CAAxB,EAAkC;QAChC,OAAO,IAAP;MACD;;MACD,OAAO;QACLC,UAAU,EAAED,MAAM,GAAG5E,MADhB;QAELlV,KAAK,EAAE2J,KAFF;QAGLiQ,KAHK;QAIL1E;MAJK,CAAP;IAMD,CAXM,EAWJhW,MAXI,CAWGyC,QAXH,CAAP;EAYD;;EACD,IAAIyD,KAAK,CAACI,KAAV,EAAiB;IACf,OAAOJ,KAAK,CAACI,KAAN,CAAYF,SAAZ,EAAuBqD,GAAvB,CAA2B,CAACgB,KAAD,EAAQiQ,KAAR,KAAkB;MAClD,IAAIE,MAAM,GAAG1U,KAAK,CAACuD,GAAN,CAAUgB,KAAV,CAAb;;MACA,IAAI,CAAC5H,mBAAmB,CAAC+X,MAAD,CAAxB,EAAkC;QAChC,OAAO,IAAP;MACD;;MACD,OAAO;QACLC,UAAU,EAAED,MAAM,GAAG5E,MADhB;QAELlV,KAAK,EAAE2J,KAFF;QAGLiQ,KAHK;QAIL1E;MAJK,CAAP;IAMD,CAXM,EAWJhW,MAXI,CAWGyC,QAXH,CAAP;EAYD,CAvCsH,CAyCvH;;;EACA,OAAOyD,KAAK,CAACd,MAAN,GAAeqE,GAAf,CAAmB,CAACgB,KAAD,EAAQiQ,KAAR,KAAkB;IAC1C,IAAIE,MAAM,GAAG1U,KAAK,CAACuD,GAAN,CAAUgB,KAAV,CAAb;;IACA,IAAI,CAAC5H,mBAAmB,CAAC+X,MAAD,CAAxB,EAAkC;MAChC,OAAO,IAAP;IACD;;IACD,OAAO;MACLC,UAAU,EAAED,MAAM,GAAG5E,MADhB;MAEL;MACAlV,KAAK,EAAEuZ,eAAe,GAAGA,eAAe,CAAC5P,KAAD,CAAlB,GAA4BA,KAH7C;MAILiQ,KAJK;MAKL1E;IALK,CAAP;EAOD,CAZM,EAYJhW,MAZI,CAYGyC,QAZH,CAAP;AAaD,CAvDM;AAwDP,OAAO,IAAIuY,0BAA0B,GAAGvZ,cAAc,CAAC,CAACG,iBAAD,EAAoBmG,4BAApB,EAAkD6P,eAAlD,EAAmEJ,eAAnE,EAAoFyC,qBAApF,EAA2GE,uBAA3G,EAAoIpW,YAApI,CAAD,EAAoJgX,yBAApJ,CAA/C;AAEP;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIE,mBAAmB,GAAGxZ,cAAc,CAACiG,cAAD,EAAiBkQ,eAAjB,EAAkC,CAAC7Q,IAAD,EAAOb,KAAP,KAAiB;EAChG,IAAIa,IAAI,IAAI,IAAR,IAAgBb,KAAK,IAAI,IAA7B,EAAmC;IACjC,OAAOf,SAAP;EACD;;EACD,OAAO9E,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK0G,IAAL,CAAd,EAA0B,EAA1B,EAA8B;IAChDb;EADgD,CAA9B,CAApB;AAGD,CAP8C,CAAxC;AAQP,IAAIgV,gBAAgB,GAAGzZ,cAAc,CAAC,CAACiG,cAAD,EAAiBiM,mBAAjB,EAAsCP,gBAAtC,EAAwDsE,0BAAxD,CAAD,EAAsF9D,oBAAtF,CAArC;AACA,OAAO,IAAIuH,oBAAoB,GAAG1Z,cAAc,CAAC,CAACiF,KAAD,EAAQ0U,SAAR,EAAmBzU,MAAnB,KAA8Ba,mBAAmB,CAACd,KAAD,EAAQC,MAAR,CAAlD,EAAmEuU,gBAAnE,EAAqF,CAACnU,IAAD,EAAOb,KAAP,KAAiB;EACpJ,IAAIa,IAAI,IAAI,IAAR,IAAgBb,KAAK,IAAI,IAA7B,EAAmC;IACjC,OAAOf,SAAP;EACD;;EACD,OAAO9E,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK0G,IAAL,CAAd,EAA0B,EAA1B,EAA8B;IAChDb;EADgD,CAA9B,CAApB;AAGD,CAP+C,CAAzC;AASP;AACA;AACA;;AAEA,OAAO,IAAImV,oBAAoB,GAAG5Z,cAAc,CAAC,CAACG,iBAAD,EAAoBsB,cAApB,EAAoCC,cAApC,CAAD,EAAsD,CAACwP,MAAD,EAAS2I,QAAT,EAAmBC,QAAnB,KAAgC;EACpI,QAAQ5I,MAAR;IACE,KAAK,YAAL;MACE;QACE,OAAO2I,QAAQ,CAACnT,IAAT,CAAcpB,IAAI,IAAIA,IAAI,CAACd,QAA3B,IAAuC,eAAvC,GAAyD,eAAhE;MACD;;IACH,KAAK,UAAL;MACE;QACE,OAAOsV,QAAQ,CAACpT,IAAT,CAAcpB,IAAI,IAAIA,IAAI,CAACd,QAA3B,IAAuC,eAAvC,GAAyD,eAAhE;MACD;IACH;IACA;;IACA,KAAK,SAAL;IACA,KAAK,QAAL;MACE;QACE,OAAO,eAAP;MACD;;IACH;MACE;QACE,OAAOd,SAAP;MACD;EAnBL;AAqBD,CAtB+C,CAAzC"},"metadata":{},"sourceType":"module"}