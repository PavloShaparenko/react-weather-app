{"ast":null,"code":"var _excluded = [\"id\"],\n    _excluded2 = [\"type\", \"layout\", \"connectNulls\", \"needClip\", \"shape\"],\n    _excluded3 = [\"activeDot\", \"animateNewValues\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"hide\", \"isAnimationActive\", \"label\", \"legendType\", \"xAxisId\", \"yAxisId\", \"id\"];\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n\n  return t;\n}\n\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n\n  var o,\n      r,\n      i = _objectWithoutPropertiesLoose(e, t);\n\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n\n  return i;\n}\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n\n  return t;\n}\n\nimport * as React from 'react';\nimport { Component, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Layer } from '../container/Layer';\nimport { CartesianLabelListContextProvider, LabelListFromLabelProp } from '../component/LabelList';\nimport { Dots } from '../component/Dots';\nimport { interpolate, isNullish, noop } from '../util/DataUtils';\nimport { isClipDot } from '../util/ReactUtils';\nimport { getCateCoordinateOfLine, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { SetErrorBarContext } from '../context/ErrorBarContext';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { useChartLayout } from '../context/chartLayoutContext';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { selectLinePoints } from '../state/selectors/lineSelectors';\nimport { useAppSelector } from '../state/hooks';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { usePlotArea } from '../hooks';\nimport { RegisterGraphicalItemId } from '../context/RegisterGraphicalItemId';\nimport { SetCartesianGraphicalItem } from '../state/SetGraphicalItem';\nimport { svgPropertiesNoEvents } from '../util/svgPropertiesNoEvents';\nimport { JavascriptAnimate } from '../animation/JavascriptAnimate';\nimport { svgPropertiesAndEvents } from '../util/svgPropertiesAndEvents';\nimport { getRadiusAndStrokeWidthFromDot } from '../util/getRadiusAndStrokeWidthFromDot';\nimport { Shape } from '../util/ActiveShapeUtils';\nimport { ZIndexLayer } from '../zIndex/ZIndexLayer';\nimport { DefaultZIndexes } from '../zIndex/DefaultZIndexes';\nimport { propsAreEqual } from '../util/propsAreEqual';\n/**\n * Internal props, combination of external props + defaultProps + private Recharts state\n */\n\n/**\n * External props, intended for end users to fill in\n */\n\n/**\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\n */\n\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: stroke,\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\n\nvar SetLineTooltipEntrySettings = /*#__PURE__*/React.memo(_ref => {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit,\n    tooltipType,\n    id\n  } = _ref;\n  var tooltipEntrySettings = {\n    dataDefinedOnItem: data,\n    getPosition: noop,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: tooltipType,\n      color: stroke,\n      unit,\n      graphicalItemId: id\n    }\n  };\n  return /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n    tooltipEntrySettings: tooltipEntrySettings\n  });\n});\n\nvar generateSimpleStrokeDasharray = (totalLength, length) => {\n  return \"\".concat(length, \"px \").concat(totalLength - length, \"px\");\n};\n\nfunction repeat(lines, count) {\n  var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;\n  var result = [];\n\n  for (var i = 0; i < count; ++i) {\n    result = [...result, ...linesUnit];\n  }\n\n  return result;\n}\n\nvar getStrokeDasharray = (length, totalLength, lines) => {\n  var lineLength = lines.reduce((pre, next) => pre + next); // if lineLength is 0 return the default when no strokeDasharray is provided\n\n  if (!lineLength) {\n    return generateSimpleStrokeDasharray(totalLength, length);\n  }\n\n  var count = Math.floor(length / lineLength);\n  var remainLength = length % lineLength;\n  var restLength = totalLength - length;\n  var remainLines = [];\n\n  for (var i = 0, sum = 0; i < lines.length; sum += (_lines$i = lines[i]) !== null && _lines$i !== void 0 ? _lines$i : 0, ++i) {\n    var _lines$i;\n\n    var lineValue = lines[i];\n\n    if (lineValue != null && sum + lineValue > remainLength) {\n      remainLines = [...lines.slice(0, i), remainLength - sum];\n      break;\n    }\n  }\n\n  var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];\n  return [...repeat(lines, count), ...remainLines, ...emptyLines].map(line => \"\".concat(line, \"px\")).join(', ');\n};\n\nfunction LineDotsWrapper(_ref2) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref2;\n  var {\n    dot,\n    dataKey,\n    needClip\n  } = props;\n  /*\n   * Exclude ID from the props passed to the Dots component\n   * because then the ID would be applied to multiple dots, and it would no longer be unique.\n   */\n\n  var {\n    id\n  } = props,\n      propsWithoutId = _objectWithoutProperties(props, _excluded);\n\n  var lineProps = svgPropertiesNoEvents(propsWithoutId);\n  return /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    dot: dot,\n    className: \"recharts-line-dots\",\n    dotClassName: \"recharts-line-dot\",\n    dataKey: dataKey,\n    baseProps: lineProps,\n    needClip: needClip,\n    clipPathId: clipPathId\n  });\n}\n\nfunction LineLabelListProvider(_ref3) {\n  var {\n    showLabels,\n    children,\n    points\n  } = _ref3;\n  var labelListEntries = useMemo(() => {\n    return points === null || points === void 0 ? void 0 : points.map(point => {\n      var _point$x, _point$y;\n\n      var viewBox = {\n        x: (_point$x = point.x) !== null && _point$x !== void 0 ? _point$x : 0,\n        y: (_point$y = point.y) !== null && _point$y !== void 0 ? _point$y : 0,\n        width: 0,\n        lowerWidth: 0,\n        upperWidth: 0,\n        height: 0\n      };\n      return _objectSpread(_objectSpread({}, viewBox), {}, {\n        value: point.value,\n        payload: point.payload,\n        viewBox,\n\n        /*\n         * Line is not passing parentViewBox to the LabelList so the labels can escape - looks like a bug, should we pass parentViewBox?\n         * Or should this just be the root chart viewBox?\n         */\n        parentViewBox: undefined,\n        fill: undefined\n      });\n    });\n  }, [points]);\n  return /*#__PURE__*/React.createElement(CartesianLabelListContextProvider, {\n    value: showLabels ? labelListEntries : undefined\n  }, children);\n}\n\nfunction StaticCurve(_ref4) {\n  var {\n    clipPathId,\n    pathRef,\n    points,\n    strokeDasharray,\n    props\n  } = _ref4;\n\n  var {\n    type,\n    layout,\n    connectNulls,\n    needClip,\n    shape\n  } = props,\n      others = _objectWithoutProperties(props, _excluded2);\n\n  var curveProps = _objectSpread(_objectSpread({}, svgPropertiesAndEvents(others)), {}, {\n    fill: 'none',\n    className: 'recharts-line-curve',\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : undefined,\n    points,\n    type,\n    layout,\n    connectNulls,\n    strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray\n  });\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Shape, _extends({\n    shapeType: \"curve\",\n    option: shape\n  }, curveProps, {\n    pathRef: pathRef\n  })), /*#__PURE__*/React.createElement(LineDotsWrapper, {\n    points: points,\n    clipPathId: clipPathId,\n    props: props\n  }));\n}\n\nfunction getTotalLength(mainCurve) {\n  try {\n    return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;\n  } catch (_unused) {\n    return 0;\n  }\n}\n\nfunction CurveWithAnimation(_ref5) {\n  var {\n    clipPathId,\n    props,\n    pathRef,\n    previousPointsRef,\n    longestAnimatedLengthRef\n  } = _ref5;\n  var {\n    points,\n    strokeDasharray,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    animateNewValues,\n    width,\n    height,\n    onAnimationEnd,\n    onAnimationStart\n  } = props;\n  var prevPoints = previousPointsRef.current;\n  var animationId = useAnimationId(points, 'recharts-line-');\n  var animationIdRef = useRef(animationId);\n  var [isAnimating, setIsAnimating] = useState(false);\n  var showLabels = !isAnimating;\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  var totalLength = getTotalLength(pathRef.current);\n  /*\n   * Here we want to detect if the length animation has been interrupted.\n   * For that we keep a reference to the furthest length that has been animated.\n   *\n   * And then, to keep things smooth, we add to it the current length that is being animated right now.\n   *\n   * If we did Math.max then it makes the length animation \"pause\" but we want to keep it smooth\n   * so in case we have some \"leftover\" length from the previous animation we add it to the current length.\n   *\n   * This is not perfect because the animation changes speed due to easing. The default easing is 'ease' which is not linear\n   * and makes it stand out. But it's good enough I suppose.\n   * If we want to fix it then we need to keep track of multiple animations and their easing and timings.\n   *\n   * If you want to see this in action, try to change the dataKey of the line chart while the initial animation is running.\n   * The Line begins with zero length and slowly grows to the full length. While this growth is in progress,\n   * change the dataKey and the Line will continue growing from where it has grown so far.\n   *\n   * This is for the case when new animation triggers. When that happens we get new points, everything re-renders,\n   * and we get fresh new state in this component and use the ref stored above.\n   *\n   * In case when we get render without new animation - for example when opacity changes, or color changes,\n   * then the animationId remains the same, and we do not update the starting point.\n   * See https://github.com/recharts/recharts/issues/6044\n   */\n\n  var startingPointRef = useRef(0);\n\n  if (animationIdRef.current !== animationId) {\n    startingPointRef.current = longestAnimatedLengthRef.current;\n    animationIdRef.current = animationId;\n  }\n\n  var startingPoint = startingPointRef.current;\n  return /*#__PURE__*/React.createElement(LineLabelListProvider, {\n    points: points,\n    showLabels: showLabels\n  }, props.children, /*#__PURE__*/React.createElement(JavascriptAnimate, {\n    animationId: animationId,\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, t => {\n    var lengthInterpolated = interpolate(startingPoint, totalLength + startingPoint, t);\n    var curLength = Math.min(lengthInterpolated, totalLength);\n    var currentStrokeDasharray;\n\n    if (isAnimationActive) {\n      if (strokeDasharray) {\n        var lines = \"\".concat(strokeDasharray).split(/[,\\s]+/gim).map(num => parseFloat(num));\n        currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);\n      } else {\n        currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);\n      }\n    } else {\n      currentStrokeDasharray = strokeDasharray == null ? undefined : String(strokeDasharray);\n    }\n    /*\n     * Here it is important to wait a little bit with updating the previousPointsRef\n     * before the animation has a time to initialize.\n     * If we set the previous pointsRef immediately, we set it before the Legend height it calculated\n     * and before pathRef is set.\n     * If that happens, the Line will re-render again after Legend had reported its height\n     * which will start a new animation with the previous points as the starting point\n     * which gives the effect of the Line animating slightly upwards (where the animation distance equals the Legend height).\n     * Waiting for t > 0 is indirect but good enough to ensure that the Legend height is calculated and animation works properly.\n     *\n     * Total length similarly is calculated from the pathRef. We should not update the previousPointsRef\n     * before the pathRef is set, otherwise we will have a wrong total length.\n     */\n\n\n    if (t > 0 && totalLength > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points;\n      /*\n       * totalLength is set from a ref and is not updated in the first tick of the animation.\n       * It defaults to zero which is exactly what we want here because we want to grow from zero,\n       * however the same happens when the data change.\n       *\n       * In that case we want to remember the previous length and continue from there, and only animate the shape.\n       *\n       * Therefore the totalLength > 0 check.\n       *\n       * The Animate is about to fire handleAnimationStart which will update the state\n       * and cause a re-render and read a new proper totalLength which will be used in the next tick\n       * and update the longestAnimatedLengthRef.\n       *\n       * Why Math.max? Sometimes the curve goes through a smaller length than previously recorded.\n       * If we just set it to curLength, then the next animation would start from a smaller length\n       * which looks weird. So we keep the longest length ever reached and then animate from there.\n       */\n      // eslint-disable-next-line no-param-reassign\n\n      longestAnimatedLengthRef.current = Math.max(longestAnimatedLengthRef.current, curLength);\n    }\n\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepData = t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(prev.x, entry.x, t),\n            y: interpolate(prev.y, entry.y, t)\n          });\n        } // magic number of faking previous x and y location\n\n\n        if (animateNewValues) {\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(width * 2, entry.x, t),\n            y: interpolate(height / 2, entry.y, t)\n          });\n        }\n\n        return _objectSpread(_objectSpread({}, entry), {}, {\n          x: entry.x,\n          y: entry.y\n        });\n      }); // eslint-disable-next-line no-param-reassign\n\n      previousPointsRef.current = stepData;\n      return /*#__PURE__*/React.createElement(StaticCurve, {\n        props: props,\n        points: stepData,\n        clipPathId: clipPathId,\n        pathRef: pathRef,\n        strokeDasharray: currentStrokeDasharray\n      });\n    }\n\n    return /*#__PURE__*/React.createElement(StaticCurve, {\n      props: props,\n      points: points,\n      clipPathId: clipPathId,\n      pathRef: pathRef,\n      strokeDasharray: currentStrokeDasharray\n    });\n  }), /*#__PURE__*/React.createElement(LabelListFromLabelProp, {\n    label: props.label\n  }));\n}\n\nfunction RenderCurve(_ref6) {\n  var {\n    clipPathId,\n    props\n  } = _ref6;\n  var previousPointsRef = useRef(null);\n  var longestAnimatedLengthRef = useRef(0);\n  var pathRef = useRef(null);\n  return /*#__PURE__*/React.createElement(CurveWithAnimation, {\n    props: props,\n    clipPathId: clipPathId,\n    previousPointsRef: previousPointsRef,\n    longestAnimatedLengthRef: longestAnimatedLengthRef,\n    pathRef: pathRef\n  });\n}\n\nvar errorBarDataPointFormatter = (dataPoint, dataKey) => {\n  var _dataPoint$x, _dataPoint$y;\n\n  return {\n    x: (_dataPoint$x = dataPoint.x) !== null && _dataPoint$x !== void 0 ? _dataPoint$x : undefined,\n    y: (_dataPoint$y = dataPoint.y) !== null && _dataPoint$y !== void 0 ? _dataPoint$y : undefined,\n    value: dataPoint.value,\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    errorVal: getValueByDataKey(dataPoint.payload, dataKey)\n  };\n}; // eslint-disable-next-line react/prefer-stateless-function\n\n\nclass LineWithState extends Component {\n  render() {\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      xAxisId,\n      yAxisId,\n      top,\n      left,\n      width,\n      height,\n      id,\n      needClip,\n      zIndex\n    } = this.props;\n\n    if (hide) {\n      return null;\n    }\n\n    var layerClass = clsx('recharts-line', className);\n    var clipPathId = id;\n    var {\n      r,\n      strokeWidth\n    } = getRadiusAndStrokeWidthFromDot(dot);\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    var activePointsClipPath = needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : undefined;\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\n      zIndex: zIndex\n    }, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(SetErrorBarContext, {\n      xAxisId: xAxisId,\n      yAxisId: yAxisId,\n      data: points,\n      dataPointFormatter: errorBarDataPointFormatter,\n      errorBarOffset: 0\n    }, /*#__PURE__*/React.createElement(RenderCurve, {\n      props: this.props,\n      clipPathId: clipPathId\n    }))), /*#__PURE__*/React.createElement(ActivePoints, {\n      activeDot: this.props.activeDot,\n      points: points,\n      mainColor: this.props.stroke,\n      itemDataKey: this.props.dataKey,\n      clipPath: activePointsClipPath\n    }));\n  }\n\n}\n\nexport var defaultLineProps = {\n  activeDot: true,\n  animateNewValues: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: true,\n  fill: '#fff',\n  hide: false,\n  isAnimationActive: 'auto',\n  label: false,\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  xAxisId: 0,\n  yAxisId: 0,\n  zIndex: DefaultZIndexes.line,\n  type: 'linear'\n};\n\nfunction LineImpl(props) {\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps),\n      {\n    activeDot,\n    animateNewValues,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    connectNulls,\n    dot,\n    hide,\n    isAnimationActive,\n    label,\n    legendType,\n    xAxisId,\n    yAxisId,\n    id\n  } = _resolveDefaultProps,\n      everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded3);\n\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var plotArea = usePlotArea();\n  var layout = useChartLayout();\n  var isPanorama = useIsPanorama();\n  var points = useAppSelector(state => selectLinePoints(state, xAxisId, yAxisId, isPanorama, id));\n\n  if (layout !== 'horizontal' && layout !== 'vertical' || points == null || plotArea == null) {\n    // Cannot render Line in an unsupported layout\n    return null;\n  }\n\n  var {\n    height,\n    width,\n    x: left,\n    y: top\n  } = plotArea;\n  return /*#__PURE__*/React.createElement(LineWithState, _extends({}, everythingElse, {\n    id: id,\n    connectNulls: connectNulls,\n    dot: dot,\n    activeDot: activeDot,\n    animateNewValues: animateNewValues,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    isAnimationActive: isAnimationActive,\n    hide: hide,\n    label: label,\n    legendType: legendType,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId,\n    points: points,\n    layout: layout,\n    height: height,\n    width: width,\n    left: left,\n    top: top,\n    needClip: needClip\n  }));\n}\n\nexport function computeLinePoints(_ref7) {\n  var {\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataKey,\n    bandSize,\n    displayedData\n  } = _ref7;\n  return displayedData.map((entry, index) => {\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    var value = getValueByDataKey(entry, dataKey);\n\n    if (layout === 'horizontal') {\n      var _x = getCateCoordinateOfLine({\n        axis: xAxis,\n        ticks: xAxisTicks,\n        bandSize,\n        entry,\n        index\n      });\n\n      var _y = isNullish(value) ? null : yAxis.scale.map(value);\n\n      return {\n        x: _x,\n        y: _y !== null && _y !== void 0 ? _y : null,\n        value,\n        payload: entry\n      };\n    }\n\n    var x = isNullish(value) ? null : xAxis.scale.map(value);\n    var y = getCateCoordinateOfLine({\n      axis: yAxis,\n      ticks: yAxisTicks,\n      bandSize,\n      entry,\n      index\n    });\n\n    if (x == null || y == null) {\n      return null;\n    }\n\n    return {\n      x,\n      y,\n      value,\n      payload: entry\n    };\n  }).filter(Boolean);\n}\n\nfunction LineFn(outsideProps) {\n  var props = resolveDefaultProps(outsideProps, defaultLineProps);\n  var isPanorama = useIsPanorama();\n  return /*#__PURE__*/React.createElement(RegisterGraphicalItemId, {\n    id: props.id,\n    type: \"line\"\n  }, id => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetLegendPayload, {\n    legendPayload: computeLegendPayloadFromAreaData(props)\n  }), /*#__PURE__*/React.createElement(SetLineTooltipEntrySettings, {\n    dataKey: props.dataKey,\n    data: props.data,\n    stroke: props.stroke,\n    strokeWidth: props.strokeWidth,\n    fill: props.fill,\n    name: props.name,\n    hide: props.hide,\n    unit: props.unit,\n    tooltipType: props.tooltipType,\n    id: id\n  }), /*#__PURE__*/React.createElement(SetCartesianGraphicalItem, {\n    type: \"line\",\n    id: id,\n    data: props.data,\n    xAxisId: props.xAxisId,\n    yAxisId: props.yAxisId,\n    zAxisId: 0,\n    dataKey: props.dataKey,\n    hide: props.hide,\n    isPanorama: isPanorama\n  }), /*#__PURE__*/React.createElement(LineImpl, _extends({}, props, {\n    id: id\n  }))));\n}\n/**\n * @provides LabelListContext\n * @provides ErrorBarContext\n * @consumes CartesianChartContext\n */\n\n\nexport var Line = /*#__PURE__*/React.memo(LineFn, propsAreEqual);\nLine.displayName = 'Line';","map":{"version":3,"names":["_excluded","_excluded2","_excluded3","_extends","Object","assign","bind","n","e","arguments","length","t","r","hasOwnProperty","call","apply","ownKeys","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","_objectSpread","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","_objectWithoutProperties","_objectWithoutPropertiesLoose","indexOf","propertyIsEnumerable","React","Component","useCallback","useMemo","useRef","useState","clsx","Layer","CartesianLabelListContextProvider","LabelListFromLabelProp","Dots","interpolate","isNullish","noop","isClipDot","getCateCoordinateOfLine","getTooltipNameProp","getValueByDataKey","ActivePoints","SetTooltipEntrySettings","SetErrorBarContext","GraphicalItemClipPath","useNeedsClip","useChartLayout","useIsPanorama","selectLinePoints","useAppSelector","SetLegendPayload","useAnimationId","resolveDefaultProps","usePlotArea","RegisterGraphicalItemId","SetCartesianGraphicalItem","svgPropertiesNoEvents","JavascriptAnimate","svgPropertiesAndEvents","getRadiusAndStrokeWidthFromDot","Shape","ZIndexLayer","DefaultZIndexes","propsAreEqual","computeLegendPayloadFromAreaData","props","dataKey","name","stroke","legendType","hide","inactive","type","color","payload","SetLineTooltipEntrySettings","memo","_ref","data","strokeWidth","fill","unit","tooltipType","id","tooltipEntrySettings","dataDefinedOnItem","getPosition","settings","nameKey","undefined","graphicalItemId","createElement","generateSimpleStrokeDasharray","totalLength","concat","repeat","lines","count","linesUnit","result","getStrokeDasharray","lineLength","reduce","pre","next","Math","floor","remainLength","restLength","remainLines","sum","_lines$i","lineValue","slice","emptyLines","map","line","join","LineDotsWrapper","_ref2","clipPathId","points","dot","needClip","propsWithoutId","lineProps","className","dotClassName","baseProps","LineLabelListProvider","_ref3","showLabels","children","labelListEntries","point","_point$x","_point$y","viewBox","x","y","width","lowerWidth","upperWidth","height","parentViewBox","StaticCurve","_ref4","pathRef","strokeDasharray","layout","connectNulls","shape","others","curveProps","clipPath","Fragment","shapeType","option","getTotalLength","mainCurve","_unused","CurveWithAnimation","_ref5","previousPointsRef","longestAnimatedLengthRef","isAnimationActive","animationBegin","animationDuration","animationEasing","animateNewValues","onAnimationEnd","onAnimationStart","prevPoints","current","animationId","animationIdRef","isAnimating","setIsAnimating","handleAnimationEnd","handleAnimationStart","startingPointRef","startingPoint","begin","duration","isActive","easing","key","lengthInterpolated","curLength","min","currentStrokeDasharray","split","num","parseFloat","max","prevPointsDiffFactor","stepData","entry","index","prevPointIndex","prev","label","RenderCurve","_ref6","errorBarDataPointFormatter","dataPoint","_dataPoint$x","_dataPoint$y","errorVal","LineWithState","render","xAxisId","yAxisId","top","left","zIndex","layerClass","clipDot","dotSize","activePointsClipPath","dataPointFormatter","errorBarOffset","activeDot","mainColor","itemDataKey","defaultLineProps","LineImpl","_resolveDefaultProps","everythingElse","plotArea","isPanorama","state","computeLinePoints","_ref7","xAxis","yAxis","xAxisTicks","yAxisTicks","bandSize","displayedData","_x","axis","ticks","_y","scale","Boolean","LineFn","outsideProps","legendPayload","zAxisId","Line","displayName"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/cartesian/Line.js"],"sourcesContent":["var _excluded = [\"id\"],\n  _excluded2 = [\"type\", \"layout\", \"connectNulls\", \"needClip\", \"shape\"],\n  _excluded3 = [\"activeDot\", \"animateNewValues\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"hide\", \"isAnimationActive\", \"label\", \"legendType\", \"xAxisId\", \"yAxisId\", \"id\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nimport * as React from 'react';\nimport { Component, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Layer } from '../container/Layer';\nimport { CartesianLabelListContextProvider, LabelListFromLabelProp } from '../component/LabelList';\nimport { Dots } from '../component/Dots';\nimport { interpolate, isNullish, noop } from '../util/DataUtils';\nimport { isClipDot } from '../util/ReactUtils';\nimport { getCateCoordinateOfLine, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { SetErrorBarContext } from '../context/ErrorBarContext';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { useChartLayout } from '../context/chartLayoutContext';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { selectLinePoints } from '../state/selectors/lineSelectors';\nimport { useAppSelector } from '../state/hooks';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { usePlotArea } from '../hooks';\nimport { RegisterGraphicalItemId } from '../context/RegisterGraphicalItemId';\nimport { SetCartesianGraphicalItem } from '../state/SetGraphicalItem';\nimport { svgPropertiesNoEvents } from '../util/svgPropertiesNoEvents';\nimport { JavascriptAnimate } from '../animation/JavascriptAnimate';\nimport { svgPropertiesAndEvents } from '../util/svgPropertiesAndEvents';\nimport { getRadiusAndStrokeWidthFromDot } from '../util/getRadiusAndStrokeWidthFromDot';\nimport { Shape } from '../util/ActiveShapeUtils';\nimport { ZIndexLayer } from '../zIndex/ZIndexLayer';\nimport { DefaultZIndexes } from '../zIndex/DefaultZIndexes';\nimport { propsAreEqual } from '../util/propsAreEqual';\n\n/**\n * Internal props, combination of external props + defaultProps + private Recharts state\n */\n\n/**\n * External props, intended for end users to fill in\n */\n\n/**\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\n */\n\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: stroke,\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\nvar SetLineTooltipEntrySettings = /*#__PURE__*/React.memo(_ref => {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit,\n    tooltipType,\n    id\n  } = _ref;\n  var tooltipEntrySettings = {\n    dataDefinedOnItem: data,\n    getPosition: noop,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: tooltipType,\n      color: stroke,\n      unit,\n      graphicalItemId: id\n    }\n  };\n  return /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n    tooltipEntrySettings: tooltipEntrySettings\n  });\n});\nvar generateSimpleStrokeDasharray = (totalLength, length) => {\n  return \"\".concat(length, \"px \").concat(totalLength - length, \"px\");\n};\nfunction repeat(lines, count) {\n  var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;\n  var result = [];\n  for (var i = 0; i < count; ++i) {\n    result = [...result, ...linesUnit];\n  }\n  return result;\n}\nvar getStrokeDasharray = (length, totalLength, lines) => {\n  var lineLength = lines.reduce((pre, next) => pre + next);\n\n  // if lineLength is 0 return the default when no strokeDasharray is provided\n  if (!lineLength) {\n    return generateSimpleStrokeDasharray(totalLength, length);\n  }\n  var count = Math.floor(length / lineLength);\n  var remainLength = length % lineLength;\n  var restLength = totalLength - length;\n  var remainLines = [];\n  for (var i = 0, sum = 0; i < lines.length; sum += (_lines$i = lines[i]) !== null && _lines$i !== void 0 ? _lines$i : 0, ++i) {\n    var _lines$i;\n    var lineValue = lines[i];\n    if (lineValue != null && sum + lineValue > remainLength) {\n      remainLines = [...lines.slice(0, i), remainLength - sum];\n      break;\n    }\n  }\n  var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];\n  return [...repeat(lines, count), ...remainLines, ...emptyLines].map(line => \"\".concat(line, \"px\")).join(', ');\n};\nfunction LineDotsWrapper(_ref2) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref2;\n  var {\n    dot,\n    dataKey,\n    needClip\n  } = props;\n\n  /*\n   * Exclude ID from the props passed to the Dots component\n   * because then the ID would be applied to multiple dots, and it would no longer be unique.\n   */\n  var {\n      id\n    } = props,\n    propsWithoutId = _objectWithoutProperties(props, _excluded);\n  var lineProps = svgPropertiesNoEvents(propsWithoutId);\n  return /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    dot: dot,\n    className: \"recharts-line-dots\",\n    dotClassName: \"recharts-line-dot\",\n    dataKey: dataKey,\n    baseProps: lineProps,\n    needClip: needClip,\n    clipPathId: clipPathId\n  });\n}\nfunction LineLabelListProvider(_ref3) {\n  var {\n    showLabels,\n    children,\n    points\n  } = _ref3;\n  var labelListEntries = useMemo(() => {\n    return points === null || points === void 0 ? void 0 : points.map(point => {\n      var _point$x, _point$y;\n      var viewBox = {\n        x: (_point$x = point.x) !== null && _point$x !== void 0 ? _point$x : 0,\n        y: (_point$y = point.y) !== null && _point$y !== void 0 ? _point$y : 0,\n        width: 0,\n        lowerWidth: 0,\n        upperWidth: 0,\n        height: 0\n      };\n      return _objectSpread(_objectSpread({}, viewBox), {}, {\n        value: point.value,\n        payload: point.payload,\n        viewBox,\n        /*\n         * Line is not passing parentViewBox to the LabelList so the labels can escape - looks like a bug, should we pass parentViewBox?\n         * Or should this just be the root chart viewBox?\n         */\n        parentViewBox: undefined,\n        fill: undefined\n      });\n    });\n  }, [points]);\n  return /*#__PURE__*/React.createElement(CartesianLabelListContextProvider, {\n    value: showLabels ? labelListEntries : undefined\n  }, children);\n}\nfunction StaticCurve(_ref4) {\n  var {\n    clipPathId,\n    pathRef,\n    points,\n    strokeDasharray,\n    props\n  } = _ref4;\n  var {\n      type,\n      layout,\n      connectNulls,\n      needClip,\n      shape\n    } = props,\n    others = _objectWithoutProperties(props, _excluded2);\n  var curveProps = _objectSpread(_objectSpread({}, svgPropertiesAndEvents(others)), {}, {\n    fill: 'none',\n    className: 'recharts-line-curve',\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : undefined,\n    points,\n    type,\n    layout,\n    connectNulls,\n    strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Shape, _extends({\n    shapeType: \"curve\",\n    option: shape\n  }, curveProps, {\n    pathRef: pathRef\n  })), /*#__PURE__*/React.createElement(LineDotsWrapper, {\n    points: points,\n    clipPathId: clipPathId,\n    props: props\n  }));\n}\nfunction getTotalLength(mainCurve) {\n  try {\n    return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;\n  } catch (_unused) {\n    return 0;\n  }\n}\nfunction CurveWithAnimation(_ref5) {\n  var {\n    clipPathId,\n    props,\n    pathRef,\n    previousPointsRef,\n    longestAnimatedLengthRef\n  } = _ref5;\n  var {\n    points,\n    strokeDasharray,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    animateNewValues,\n    width,\n    height,\n    onAnimationEnd,\n    onAnimationStart\n  } = props;\n  var prevPoints = previousPointsRef.current;\n  var animationId = useAnimationId(points, 'recharts-line-');\n  var animationIdRef = useRef(animationId);\n  var [isAnimating, setIsAnimating] = useState(false);\n  var showLabels = !isAnimating;\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  var totalLength = getTotalLength(pathRef.current);\n  /*\n   * Here we want to detect if the length animation has been interrupted.\n   * For that we keep a reference to the furthest length that has been animated.\n   *\n   * And then, to keep things smooth, we add to it the current length that is being animated right now.\n   *\n   * If we did Math.max then it makes the length animation \"pause\" but we want to keep it smooth\n   * so in case we have some \"leftover\" length from the previous animation we add it to the current length.\n   *\n   * This is not perfect because the animation changes speed due to easing. The default easing is 'ease' which is not linear\n   * and makes it stand out. But it's good enough I suppose.\n   * If we want to fix it then we need to keep track of multiple animations and their easing and timings.\n   *\n   * If you want to see this in action, try to change the dataKey of the line chart while the initial animation is running.\n   * The Line begins with zero length and slowly grows to the full length. While this growth is in progress,\n   * change the dataKey and the Line will continue growing from where it has grown so far.\n   *\n   * This is for the case when new animation triggers. When that happens we get new points, everything re-renders,\n   * and we get fresh new state in this component and use the ref stored above.\n   *\n   * In case when we get render without new animation - for example when opacity changes, or color changes,\n   * then the animationId remains the same, and we do not update the starting point.\n   * See https://github.com/recharts/recharts/issues/6044\n   */\n  var startingPointRef = useRef(0);\n  if (animationIdRef.current !== animationId) {\n    startingPointRef.current = longestAnimatedLengthRef.current;\n    animationIdRef.current = animationId;\n  }\n  var startingPoint = startingPointRef.current;\n  return /*#__PURE__*/React.createElement(LineLabelListProvider, {\n    points: points,\n    showLabels: showLabels\n  }, props.children, /*#__PURE__*/React.createElement(JavascriptAnimate, {\n    animationId: animationId,\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, t => {\n    var lengthInterpolated = interpolate(startingPoint, totalLength + startingPoint, t);\n    var curLength = Math.min(lengthInterpolated, totalLength);\n    var currentStrokeDasharray;\n    if (isAnimationActive) {\n      if (strokeDasharray) {\n        var lines = \"\".concat(strokeDasharray).split(/[,\\s]+/gim).map(num => parseFloat(num));\n        currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);\n      } else {\n        currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);\n      }\n    } else {\n      currentStrokeDasharray = strokeDasharray == null ? undefined : String(strokeDasharray);\n    }\n\n    /*\n     * Here it is important to wait a little bit with updating the previousPointsRef\n     * before the animation has a time to initialize.\n     * If we set the previous pointsRef immediately, we set it before the Legend height it calculated\n     * and before pathRef is set.\n     * If that happens, the Line will re-render again after Legend had reported its height\n     * which will start a new animation with the previous points as the starting point\n     * which gives the effect of the Line animating slightly upwards (where the animation distance equals the Legend height).\n     * Waiting for t > 0 is indirect but good enough to ensure that the Legend height is calculated and animation works properly.\n     *\n     * Total length similarly is calculated from the pathRef. We should not update the previousPointsRef\n     * before the pathRef is set, otherwise we will have a wrong total length.\n     */\n    if (t > 0 && totalLength > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points;\n      /*\n       * totalLength is set from a ref and is not updated in the first tick of the animation.\n       * It defaults to zero which is exactly what we want here because we want to grow from zero,\n       * however the same happens when the data change.\n       *\n       * In that case we want to remember the previous length and continue from there, and only animate the shape.\n       *\n       * Therefore the totalLength > 0 check.\n       *\n       * The Animate is about to fire handleAnimationStart which will update the state\n       * and cause a re-render and read a new proper totalLength which will be used in the next tick\n       * and update the longestAnimatedLengthRef.\n       *\n       * Why Math.max? Sometimes the curve goes through a smaller length than previously recorded.\n       * If we just set it to curLength, then the next animation would start from a smaller length\n       * which looks weird. So we keep the longest length ever reached and then animate from there.\n       */\n      // eslint-disable-next-line no-param-reassign\n      longestAnimatedLengthRef.current = Math.max(longestAnimatedLengthRef.current, curLength);\n    }\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepData = t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(prev.x, entry.x, t),\n            y: interpolate(prev.y, entry.y, t)\n          });\n        }\n\n        // magic number of faking previous x and y location\n        if (animateNewValues) {\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(width * 2, entry.x, t),\n            y: interpolate(height / 2, entry.y, t)\n          });\n        }\n        return _objectSpread(_objectSpread({}, entry), {}, {\n          x: entry.x,\n          y: entry.y\n        });\n      });\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = stepData;\n      return /*#__PURE__*/React.createElement(StaticCurve, {\n        props: props,\n        points: stepData,\n        clipPathId: clipPathId,\n        pathRef: pathRef,\n        strokeDasharray: currentStrokeDasharray\n      });\n    }\n    return /*#__PURE__*/React.createElement(StaticCurve, {\n      props: props,\n      points: points,\n      clipPathId: clipPathId,\n      pathRef: pathRef,\n      strokeDasharray: currentStrokeDasharray\n    });\n  }), /*#__PURE__*/React.createElement(LabelListFromLabelProp, {\n    label: props.label\n  }));\n}\nfunction RenderCurve(_ref6) {\n  var {\n    clipPathId,\n    props\n  } = _ref6;\n  var previousPointsRef = useRef(null);\n  var longestAnimatedLengthRef = useRef(0);\n  var pathRef = useRef(null);\n  return /*#__PURE__*/React.createElement(CurveWithAnimation, {\n    props: props,\n    clipPathId: clipPathId,\n    previousPointsRef: previousPointsRef,\n    longestAnimatedLengthRef: longestAnimatedLengthRef,\n    pathRef: pathRef\n  });\n}\nvar errorBarDataPointFormatter = (dataPoint, dataKey) => {\n  var _dataPoint$x, _dataPoint$y;\n  return {\n    x: (_dataPoint$x = dataPoint.x) !== null && _dataPoint$x !== void 0 ? _dataPoint$x : undefined,\n    y: (_dataPoint$y = dataPoint.y) !== null && _dataPoint$y !== void 0 ? _dataPoint$y : undefined,\n    value: dataPoint.value,\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    errorVal: getValueByDataKey(dataPoint.payload, dataKey)\n  };\n};\n\n// eslint-disable-next-line react/prefer-stateless-function\nclass LineWithState extends Component {\n  render() {\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      xAxisId,\n      yAxisId,\n      top,\n      left,\n      width,\n      height,\n      id,\n      needClip,\n      zIndex\n    } = this.props;\n    if (hide) {\n      return null;\n    }\n    var layerClass = clsx('recharts-line', className);\n    var clipPathId = id;\n    var {\n      r,\n      strokeWidth\n    } = getRadiusAndStrokeWidthFromDot(dot);\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    var activePointsClipPath = needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : undefined;\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\n      zIndex: zIndex\n    }, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(SetErrorBarContext, {\n      xAxisId: xAxisId,\n      yAxisId: yAxisId,\n      data: points,\n      dataPointFormatter: errorBarDataPointFormatter,\n      errorBarOffset: 0\n    }, /*#__PURE__*/React.createElement(RenderCurve, {\n      props: this.props,\n      clipPathId: clipPathId\n    }))), /*#__PURE__*/React.createElement(ActivePoints, {\n      activeDot: this.props.activeDot,\n      points: points,\n      mainColor: this.props.stroke,\n      itemDataKey: this.props.dataKey,\n      clipPath: activePointsClipPath\n    }));\n  }\n}\nexport var defaultLineProps = {\n  activeDot: true,\n  animateNewValues: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: true,\n  fill: '#fff',\n  hide: false,\n  isAnimationActive: 'auto',\n  label: false,\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  xAxisId: 0,\n  yAxisId: 0,\n  zIndex: DefaultZIndexes.line,\n  type: 'linear'\n};\nfunction LineImpl(props) {\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps),\n    {\n      activeDot,\n      animateNewValues,\n      animationBegin,\n      animationDuration,\n      animationEasing,\n      connectNulls,\n      dot,\n      hide,\n      isAnimationActive,\n      label,\n      legendType,\n      xAxisId,\n      yAxisId,\n      id\n    } = _resolveDefaultProps,\n    everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded3);\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var plotArea = usePlotArea();\n  var layout = useChartLayout();\n  var isPanorama = useIsPanorama();\n  var points = useAppSelector(state => selectLinePoints(state, xAxisId, yAxisId, isPanorama, id));\n  if (layout !== 'horizontal' && layout !== 'vertical' || points == null || plotArea == null) {\n    // Cannot render Line in an unsupported layout\n    return null;\n  }\n  var {\n    height,\n    width,\n    x: left,\n    y: top\n  } = plotArea;\n  return /*#__PURE__*/React.createElement(LineWithState, _extends({}, everythingElse, {\n    id: id,\n    connectNulls: connectNulls,\n    dot: dot,\n    activeDot: activeDot,\n    animateNewValues: animateNewValues,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    isAnimationActive: isAnimationActive,\n    hide: hide,\n    label: label,\n    legendType: legendType,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId,\n    points: points,\n    layout: layout,\n    height: height,\n    width: width,\n    left: left,\n    top: top,\n    needClip: needClip\n  }));\n}\nexport function computeLinePoints(_ref7) {\n  var {\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataKey,\n    bandSize,\n    displayedData\n  } = _ref7;\n  return displayedData.map((entry, index) => {\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    var value = getValueByDataKey(entry, dataKey);\n    if (layout === 'horizontal') {\n      var _x = getCateCoordinateOfLine({\n        axis: xAxis,\n        ticks: xAxisTicks,\n        bandSize,\n        entry,\n        index\n      });\n      var _y = isNullish(value) ? null : yAxis.scale.map(value);\n      return {\n        x: _x,\n        y: _y !== null && _y !== void 0 ? _y : null,\n        value,\n        payload: entry\n      };\n    }\n    var x = isNullish(value) ? null : xAxis.scale.map(value);\n    var y = getCateCoordinateOfLine({\n      axis: yAxis,\n      ticks: yAxisTicks,\n      bandSize,\n      entry,\n      index\n    });\n    if (x == null || y == null) {\n      return null;\n    }\n    return {\n      x,\n      y,\n      value,\n      payload: entry\n    };\n  }).filter(Boolean);\n}\nfunction LineFn(outsideProps) {\n  var props = resolveDefaultProps(outsideProps, defaultLineProps);\n  var isPanorama = useIsPanorama();\n  return /*#__PURE__*/React.createElement(RegisterGraphicalItemId, {\n    id: props.id,\n    type: \"line\"\n  }, id => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetLegendPayload, {\n    legendPayload: computeLegendPayloadFromAreaData(props)\n  }), /*#__PURE__*/React.createElement(SetLineTooltipEntrySettings, {\n    dataKey: props.dataKey,\n    data: props.data,\n    stroke: props.stroke,\n    strokeWidth: props.strokeWidth,\n    fill: props.fill,\n    name: props.name,\n    hide: props.hide,\n    unit: props.unit,\n    tooltipType: props.tooltipType,\n    id: id\n  }), /*#__PURE__*/React.createElement(SetCartesianGraphicalItem, {\n    type: \"line\",\n    id: id,\n    data: props.data,\n    xAxisId: props.xAxisId,\n    yAxisId: props.yAxisId,\n    zAxisId: 0,\n    dataKey: props.dataKey,\n    hide: props.hide,\n    isPanorama: isPanorama\n  }), /*#__PURE__*/React.createElement(LineImpl, _extends({}, props, {\n    id: id\n  }))));\n}\n\n/**\n * @provides LabelListContext\n * @provides ErrorBarContext\n * @consumes CartesianChartContext\n */\nexport var Line = /*#__PURE__*/React.memo(LineFn, propsAreEqual);\nLine.displayName = 'Line';"],"mappings":"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"},"metadata":{},"sourceType":"module"}