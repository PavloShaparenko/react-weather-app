{"ast":null,"code":"import { useEffect } from 'react';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { setChartSize, setMargin } from '../state/layoutSlice';\nimport { selectChartOffsetInternal, selectChartViewBox } from '../state/selectors/selectChartOffsetInternal';\nimport { selectChartHeight, selectChartWidth } from '../state/selectors/containerSelectors';\nimport { useIsPanorama } from './PanoramaContext';\nimport { selectBrushDimensions, selectBrushSettings } from '../state/selectors/brushSelectors';\nimport { useResponsiveContainerContext } from '../component/ResponsiveContainer';\nimport { isPositiveNumber } from '../util/isWellBehavedNumber';\nexport function cartesianViewBoxToTrapezoid(box) {\n  if (!box) {\n    return undefined;\n  }\n\n  return {\n    x: box.x,\n    y: box.y,\n    upperWidth: 'upperWidth' in box ? box.upperWidth : box.width,\n    lowerWidth: 'lowerWidth' in box ? box.lowerWidth : box.width,\n    width: box.width,\n    height: box.height\n  };\n}\nexport var useViewBox = () => {\n  var _useAppSelector;\n\n  var panorama = useIsPanorama();\n  var rootViewBox = useAppSelector(selectChartViewBox);\n  var brushDimensions = useAppSelector(selectBrushDimensions);\n  var brushPadding = (_useAppSelector = useAppSelector(selectBrushSettings)) === null || _useAppSelector === void 0 ? void 0 : _useAppSelector.padding;\n\n  if (!panorama || !brushDimensions || !brushPadding) {\n    return rootViewBox;\n  }\n\n  return {\n    width: brushDimensions.width - brushPadding.left - brushPadding.right,\n    height: brushDimensions.height - brushPadding.top - brushPadding.bottom,\n    x: brushPadding.left,\n    y: brushPadding.top\n  };\n};\nvar manyComponentsThrowErrorsIfOffsetIsUndefined = {\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  width: 0,\n  height: 0,\n  brushBottom: 0\n};\n/**\n * For internal use only. If you want this information, `import { useOffset } from 'recharts'` instead.\n *\n * Returns the offset of the chart in pixels.\n *\n * @returns {ChartOffsetInternal} The offset of the chart in pixels, or a default value if not in a chart context.\n */\n\nexport var useOffsetInternal = () => {\n  var _useAppSelector2;\n\n  return (_useAppSelector2 = useAppSelector(selectChartOffsetInternal)) !== null && _useAppSelector2 !== void 0 ? _useAppSelector2 : manyComponentsThrowErrorsIfOffsetIsUndefined;\n};\n/**\n * Returns the width of the chart in pixels.\n *\n * If you are using chart with hardcoded `width` prop, then the width returned will be the same\n * as the `width` prop on the main chart element.\n *\n * If you are using a chart with a `ResponsiveContainer`, the width will be the size of the chart\n * as the ResponsiveContainer has decided it would be.\n *\n * If the chart has any axes or legend, the `width` will be the size of the chart\n * including the axes and legend. Meaning: adding axes and legend will not change the width.\n *\n * The dimensions do not scale, meaning as user zoom in and out, the width number will not change\n * as the chart gets visually larger or smaller.\n *\n * Returns `undefined` if used outside a chart context.\n *\n * @returns {number | undefined} The width of the chart in pixels, or `undefined` if not in a chart context.\n */\n\nexport var useChartWidth = () => {\n  return useAppSelector(selectChartWidth);\n};\n/**\n * Returns the height of the chart in pixels.\n *\n * If you are using chart with hardcoded `height` props, then the height returned will be the same\n * as the `height` prop on the main chart element.\n *\n * If you are using a chart with a `ResponsiveContainer`, the height will be the size of the chart\n * as the ResponsiveContainer has decided it would be.\n *\n * If the chart has any axes or legend, the `height` will be the size of the chart\n * including the axes and legend. Meaning: adding axes and legend will not change the height.\n *\n * The dimensions do not scale, meaning as user zoom in and out, the height number will not change\n * as the chart gets visually larger or smaller.\n *\n * Returns `undefined` if used outside a chart context.\n *\n * @returns {number | undefined} The height of the chart in pixels, or `undefined` if not in a chart context.\n */\n\nexport var useChartHeight = () => {\n  return useAppSelector(selectChartHeight);\n};\n/**\n * Margin is the empty space around the chart. Excludes axes and legend and brushes and the like.\n * This is declared by the user in the chart props.\n * If you are interested in the space occupied by axes, legend, or brushes,\n * use {@link useOffset} instead, which also includes calculated widths and heights of axes and legends.\n *\n * Returns `undefined` if used outside a chart context.\n *\n * @returns {Margin | undefined} The margin of the chart in pixels, or `undefined` if not in a chart context.\n */\n\nexport var useMargin = () => {\n  return useAppSelector(state => state.layout.margin);\n};\nexport var selectChartLayout = state => state.layout.layoutType;\nexport var useChartLayout = () => useAppSelector(selectChartLayout);\nexport var useCartesianChartLayout = () => {\n  var layout = useChartLayout();\n\n  if (layout === 'horizontal' || layout === 'vertical') {\n    return layout;\n  }\n\n  return undefined;\n};\nexport var selectPolarChartLayout = state => {\n  var layout = state.layout.layoutType;\n\n  if (layout === 'centric' || layout === 'radial') {\n    return layout;\n  }\n\n  return undefined;\n};\nexport var usePolarChartLayout = () => {\n  return useAppSelector(selectPolarChartLayout);\n};\n/**\n * Returns true if the component is rendered inside a chart context.\n * Some components may be used both inside and outside of charts,\n * and this hook allows them to determine if they are in a chart context or not.\n *\n * Other selectors may return undefined when used outside a chart context,\n * or undefined when inside a chart, but without relevant data.\n * This hook provides a more explicit way to check for chart context.\n *\n * @returns {boolean} True if in chart context, false otherwise.\n */\n\nexport var useIsInChartContext = () => {\n  /*\n   * All charts provide a layout type in the chart context.\n   * If we have a layout type, we are in a chart context.\n   */\n  var layout = useChartLayout();\n  return layout !== undefined;\n};\nexport var ReportChartSize = props => {\n  var dispatch = useAppDispatch();\n  /*\n   * Skip dispatching properties in panorama chart for two reasons:\n   * 1. The root chart should be deciding on these properties, and\n   * 2. Brush reads these properties from redux store, and so they must remain stable\n   *      to avoid circular dependency and infinite re-rendering.\n   */\n\n  var isPanorama = useIsPanorama();\n  var {\n    width: widthFromProps,\n    height: heightFromProps\n  } = props;\n  var responsiveContainerCalculations = useResponsiveContainerContext();\n  var width = widthFromProps;\n  var height = heightFromProps;\n\n  if (responsiveContainerCalculations) {\n    /*\n     * In case we receive width and height from ResponsiveContainer,\n     * we will always prefer those.\n     * Only in case ResponsiveContainer does not provide width or height,\n     * we will fall back to the explicitly provided width and height.\n     *\n     * This to me feels backwards - we should allow override by the more specific props on individual charts, right?\n     * But this is 3.x behaviour, so let's keep it for backwards compatibility.\n     *\n     * We can change this in 4.x if we want to.\n     */\n    width = responsiveContainerCalculations.width > 0 ? responsiveContainerCalculations.width : widthFromProps;\n    height = responsiveContainerCalculations.height > 0 ? responsiveContainerCalculations.height : heightFromProps;\n  }\n\n  useEffect(() => {\n    if (!isPanorama && isPositiveNumber(width) && isPositiveNumber(height)) {\n      dispatch(setChartSize({\n        width,\n        height\n      }));\n    }\n  }, [dispatch, isPanorama, width, height]);\n  return null;\n};\nexport var ReportChartMargin = _ref => {\n  var {\n    margin\n  } = _ref;\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(setMargin(margin));\n  }, [dispatch, margin]);\n  return null;\n};","map":{"version":3,"names":["useEffect","useAppDispatch","useAppSelector","setChartSize","setMargin","selectChartOffsetInternal","selectChartViewBox","selectChartHeight","selectChartWidth","useIsPanorama","selectBrushDimensions","selectBrushSettings","useResponsiveContainerContext","isPositiveNumber","cartesianViewBoxToTrapezoid","box","undefined","x","y","upperWidth","width","lowerWidth","height","useViewBox","_useAppSelector","panorama","rootViewBox","brushDimensions","brushPadding","padding","left","right","top","bottom","manyComponentsThrowErrorsIfOffsetIsUndefined","brushBottom","useOffsetInternal","_useAppSelector2","useChartWidth","useChartHeight","useMargin","state","layout","margin","selectChartLayout","layoutType","useChartLayout","useCartesianChartLayout","selectPolarChartLayout","usePolarChartLayout","useIsInChartContext","ReportChartSize","props","dispatch","isPanorama","widthFromProps","heightFromProps","responsiveContainerCalculations","ReportChartMargin","_ref"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/context/chartLayoutContext.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { setChartSize, setMargin } from '../state/layoutSlice';\nimport { selectChartOffsetInternal, selectChartViewBox } from '../state/selectors/selectChartOffsetInternal';\nimport { selectChartHeight, selectChartWidth } from '../state/selectors/containerSelectors';\nimport { useIsPanorama } from './PanoramaContext';\nimport { selectBrushDimensions, selectBrushSettings } from '../state/selectors/brushSelectors';\nimport { useResponsiveContainerContext } from '../component/ResponsiveContainer';\nimport { isPositiveNumber } from '../util/isWellBehavedNumber';\nexport function cartesianViewBoxToTrapezoid(box) {\n  if (!box) {\n    return undefined;\n  }\n  return {\n    x: box.x,\n    y: box.y,\n    upperWidth: 'upperWidth' in box ? box.upperWidth : box.width,\n    lowerWidth: 'lowerWidth' in box ? box.lowerWidth : box.width,\n    width: box.width,\n    height: box.height\n  };\n}\nexport var useViewBox = () => {\n  var _useAppSelector;\n  var panorama = useIsPanorama();\n  var rootViewBox = useAppSelector(selectChartViewBox);\n  var brushDimensions = useAppSelector(selectBrushDimensions);\n  var brushPadding = (_useAppSelector = useAppSelector(selectBrushSettings)) === null || _useAppSelector === void 0 ? void 0 : _useAppSelector.padding;\n  if (!panorama || !brushDimensions || !brushPadding) {\n    return rootViewBox;\n  }\n  return {\n    width: brushDimensions.width - brushPadding.left - brushPadding.right,\n    height: brushDimensions.height - brushPadding.top - brushPadding.bottom,\n    x: brushPadding.left,\n    y: brushPadding.top\n  };\n};\nvar manyComponentsThrowErrorsIfOffsetIsUndefined = {\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  width: 0,\n  height: 0,\n  brushBottom: 0\n};\n/**\n * For internal use only. If you want this information, `import { useOffset } from 'recharts'` instead.\n *\n * Returns the offset of the chart in pixels.\n *\n * @returns {ChartOffsetInternal} The offset of the chart in pixels, or a default value if not in a chart context.\n */\nexport var useOffsetInternal = () => {\n  var _useAppSelector2;\n  return (_useAppSelector2 = useAppSelector(selectChartOffsetInternal)) !== null && _useAppSelector2 !== void 0 ? _useAppSelector2 : manyComponentsThrowErrorsIfOffsetIsUndefined;\n};\n\n/**\n * Returns the width of the chart in pixels.\n *\n * If you are using chart with hardcoded `width` prop, then the width returned will be the same\n * as the `width` prop on the main chart element.\n *\n * If you are using a chart with a `ResponsiveContainer`, the width will be the size of the chart\n * as the ResponsiveContainer has decided it would be.\n *\n * If the chart has any axes or legend, the `width` will be the size of the chart\n * including the axes and legend. Meaning: adding axes and legend will not change the width.\n *\n * The dimensions do not scale, meaning as user zoom in and out, the width number will not change\n * as the chart gets visually larger or smaller.\n *\n * Returns `undefined` if used outside a chart context.\n *\n * @returns {number | undefined} The width of the chart in pixels, or `undefined` if not in a chart context.\n */\nexport var useChartWidth = () => {\n  return useAppSelector(selectChartWidth);\n};\n\n/**\n * Returns the height of the chart in pixels.\n *\n * If you are using chart with hardcoded `height` props, then the height returned will be the same\n * as the `height` prop on the main chart element.\n *\n * If you are using a chart with a `ResponsiveContainer`, the height will be the size of the chart\n * as the ResponsiveContainer has decided it would be.\n *\n * If the chart has any axes or legend, the `height` will be the size of the chart\n * including the axes and legend. Meaning: adding axes and legend will not change the height.\n *\n * The dimensions do not scale, meaning as user zoom in and out, the height number will not change\n * as the chart gets visually larger or smaller.\n *\n * Returns `undefined` if used outside a chart context.\n *\n * @returns {number | undefined} The height of the chart in pixels, or `undefined` if not in a chart context.\n */\nexport var useChartHeight = () => {\n  return useAppSelector(selectChartHeight);\n};\n\n/**\n * Margin is the empty space around the chart. Excludes axes and legend and brushes and the like.\n * This is declared by the user in the chart props.\n * If you are interested in the space occupied by axes, legend, or brushes,\n * use {@link useOffset} instead, which also includes calculated widths and heights of axes and legends.\n *\n * Returns `undefined` if used outside a chart context.\n *\n * @returns {Margin | undefined} The margin of the chart in pixels, or `undefined` if not in a chart context.\n */\nexport var useMargin = () => {\n  return useAppSelector(state => state.layout.margin);\n};\nexport var selectChartLayout = state => state.layout.layoutType;\nexport var useChartLayout = () => useAppSelector(selectChartLayout);\nexport var useCartesianChartLayout = () => {\n  var layout = useChartLayout();\n  if (layout === 'horizontal' || layout === 'vertical') {\n    return layout;\n  }\n  return undefined;\n};\nexport var selectPolarChartLayout = state => {\n  var layout = state.layout.layoutType;\n  if (layout === 'centric' || layout === 'radial') {\n    return layout;\n  }\n  return undefined;\n};\nexport var usePolarChartLayout = () => {\n  return useAppSelector(selectPolarChartLayout);\n};\n\n/**\n * Returns true if the component is rendered inside a chart context.\n * Some components may be used both inside and outside of charts,\n * and this hook allows them to determine if they are in a chart context or not.\n *\n * Other selectors may return undefined when used outside a chart context,\n * or undefined when inside a chart, but without relevant data.\n * This hook provides a more explicit way to check for chart context.\n *\n * @returns {boolean} True if in chart context, false otherwise.\n */\nexport var useIsInChartContext = () => {\n  /*\n   * All charts provide a layout type in the chart context.\n   * If we have a layout type, we are in a chart context.\n   */\n  var layout = useChartLayout();\n  return layout !== undefined;\n};\nexport var ReportChartSize = props => {\n  var dispatch = useAppDispatch();\n\n  /*\n   * Skip dispatching properties in panorama chart for two reasons:\n   * 1. The root chart should be deciding on these properties, and\n   * 2. Brush reads these properties from redux store, and so they must remain stable\n   *      to avoid circular dependency and infinite re-rendering.\n   */\n  var isPanorama = useIsPanorama();\n  var {\n    width: widthFromProps,\n    height: heightFromProps\n  } = props;\n  var responsiveContainerCalculations = useResponsiveContainerContext();\n  var width = widthFromProps;\n  var height = heightFromProps;\n  if (responsiveContainerCalculations) {\n    /*\n     * In case we receive width and height from ResponsiveContainer,\n     * we will always prefer those.\n     * Only in case ResponsiveContainer does not provide width or height,\n     * we will fall back to the explicitly provided width and height.\n     *\n     * This to me feels backwards - we should allow override by the more specific props on individual charts, right?\n     * But this is 3.x behaviour, so let's keep it for backwards compatibility.\n     *\n     * We can change this in 4.x if we want to.\n     */\n    width = responsiveContainerCalculations.width > 0 ? responsiveContainerCalculations.width : widthFromProps;\n    height = responsiveContainerCalculations.height > 0 ? responsiveContainerCalculations.height : heightFromProps;\n  }\n  useEffect(() => {\n    if (!isPanorama && isPositiveNumber(width) && isPositiveNumber(height)) {\n      dispatch(setChartSize({\n        width,\n        height\n      }));\n    }\n  }, [dispatch, isPanorama, width, height]);\n  return null;\n};\nexport var ReportChartMargin = _ref => {\n  var {\n    margin\n  } = _ref;\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(setMargin(margin));\n  }, [dispatch, margin]);\n  return null;\n};"],"mappings":"AAAA,SAASA,SAAT,QAA0B,OAA1B;AACA,SAASC,cAAT,EAAyBC,cAAzB,QAA+C,gBAA/C;AACA,SAASC,YAAT,EAAuBC,SAAvB,QAAwC,sBAAxC;AACA,SAASC,yBAAT,EAAoCC,kBAApC,QAA8D,8CAA9D;AACA,SAASC,iBAAT,EAA4BC,gBAA5B,QAAoD,uCAApD;AACA,SAASC,aAAT,QAA8B,mBAA9B;AACA,SAASC,qBAAT,EAAgCC,mBAAhC,QAA2D,mCAA3D;AACA,SAASC,6BAAT,QAA8C,kCAA9C;AACA,SAASC,gBAAT,QAAiC,6BAAjC;AACA,OAAO,SAASC,2BAAT,CAAqCC,GAArC,EAA0C;EAC/C,IAAI,CAACA,GAAL,EAAU;IACR,OAAOC,SAAP;EACD;;EACD,OAAO;IACLC,CAAC,EAAEF,GAAG,CAACE,CADF;IAELC,CAAC,EAAEH,GAAG,CAACG,CAFF;IAGLC,UAAU,EAAE,gBAAgBJ,GAAhB,GAAsBA,GAAG,CAACI,UAA1B,GAAuCJ,GAAG,CAACK,KAHlD;IAILC,UAAU,EAAE,gBAAgBN,GAAhB,GAAsBA,GAAG,CAACM,UAA1B,GAAuCN,GAAG,CAACK,KAJlD;IAKLA,KAAK,EAAEL,GAAG,CAACK,KALN;IAMLE,MAAM,EAAEP,GAAG,CAACO;EANP,CAAP;AAQD;AACD,OAAO,IAAIC,UAAU,GAAG,MAAM;EAC5B,IAAIC,eAAJ;;EACA,IAAIC,QAAQ,GAAGhB,aAAa,EAA5B;EACA,IAAIiB,WAAW,GAAGxB,cAAc,CAACI,kBAAD,CAAhC;EACA,IAAIqB,eAAe,GAAGzB,cAAc,CAACQ,qBAAD,CAApC;EACA,IAAIkB,YAAY,GAAG,CAACJ,eAAe,GAAGtB,cAAc,CAACS,mBAAD,CAAjC,MAA4D,IAA5D,IAAoEa,eAAe,KAAK,KAAK,CAA7F,GAAiG,KAAK,CAAtG,GAA0GA,eAAe,CAACK,OAA7I;;EACA,IAAI,CAACJ,QAAD,IAAa,CAACE,eAAd,IAAiC,CAACC,YAAtC,EAAoD;IAClD,OAAOF,WAAP;EACD;;EACD,OAAO;IACLN,KAAK,EAAEO,eAAe,CAACP,KAAhB,GAAwBQ,YAAY,CAACE,IAArC,GAA4CF,YAAY,CAACG,KAD3D;IAELT,MAAM,EAAEK,eAAe,CAACL,MAAhB,GAAyBM,YAAY,CAACI,GAAtC,GAA4CJ,YAAY,CAACK,MAF5D;IAGLhB,CAAC,EAAEW,YAAY,CAACE,IAHX;IAILZ,CAAC,EAAEU,YAAY,CAACI;EAJX,CAAP;AAMD,CAfM;AAgBP,IAAIE,4CAA4C,GAAG;EACjDF,GAAG,EAAE,CAD4C;EAEjDC,MAAM,EAAE,CAFyC;EAGjDH,IAAI,EAAE,CAH2C;EAIjDC,KAAK,EAAE,CAJ0C;EAKjDX,KAAK,EAAE,CAL0C;EAMjDE,MAAM,EAAE,CANyC;EAOjDa,WAAW,EAAE;AAPoC,CAAnD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,iBAAiB,GAAG,MAAM;EACnC,IAAIC,gBAAJ;;EACA,OAAO,CAACA,gBAAgB,GAAGnC,cAAc,CAACG,yBAAD,CAAlC,MAAmE,IAAnE,IAA2EgC,gBAAgB,KAAK,KAAK,CAArG,GAAyGA,gBAAzG,GAA4HH,4CAAnI;AACD,CAHM;AAKP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAII,aAAa,GAAG,MAAM;EAC/B,OAAOpC,cAAc,CAACM,gBAAD,CAArB;AACD,CAFM;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAI+B,cAAc,GAAG,MAAM;EAChC,OAAOrC,cAAc,CAACK,iBAAD,CAArB;AACD,CAFM;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIiC,SAAS,GAAG,MAAM;EAC3B,OAAOtC,cAAc,CAACuC,KAAK,IAAIA,KAAK,CAACC,MAAN,CAAaC,MAAvB,CAArB;AACD,CAFM;AAGP,OAAO,IAAIC,iBAAiB,GAAGH,KAAK,IAAIA,KAAK,CAACC,MAAN,CAAaG,UAA9C;AACP,OAAO,IAAIC,cAAc,GAAG,MAAM5C,cAAc,CAAC0C,iBAAD,CAAzC;AACP,OAAO,IAAIG,uBAAuB,GAAG,MAAM;EACzC,IAAIL,MAAM,GAAGI,cAAc,EAA3B;;EACA,IAAIJ,MAAM,KAAK,YAAX,IAA2BA,MAAM,KAAK,UAA1C,EAAsD;IACpD,OAAOA,MAAP;EACD;;EACD,OAAO1B,SAAP;AACD,CANM;AAOP,OAAO,IAAIgC,sBAAsB,GAAGP,KAAK,IAAI;EAC3C,IAAIC,MAAM,GAAGD,KAAK,CAACC,MAAN,CAAaG,UAA1B;;EACA,IAAIH,MAAM,KAAK,SAAX,IAAwBA,MAAM,KAAK,QAAvC,EAAiD;IAC/C,OAAOA,MAAP;EACD;;EACD,OAAO1B,SAAP;AACD,CANM;AAOP,OAAO,IAAIiC,mBAAmB,GAAG,MAAM;EACrC,OAAO/C,cAAc,CAAC8C,sBAAD,CAArB;AACD,CAFM;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIE,mBAAmB,GAAG,MAAM;EACrC;AACF;AACA;AACA;EACE,IAAIR,MAAM,GAAGI,cAAc,EAA3B;EACA,OAAOJ,MAAM,KAAK1B,SAAlB;AACD,CAPM;AAQP,OAAO,IAAImC,eAAe,GAAGC,KAAK,IAAI;EACpC,IAAIC,QAAQ,GAAGpD,cAAc,EAA7B;EAEA;AACF;AACA;AACA;AACA;AACA;;EACE,IAAIqD,UAAU,GAAG7C,aAAa,EAA9B;EACA,IAAI;IACFW,KAAK,EAAEmC,cADL;IAEFjC,MAAM,EAAEkC;EAFN,IAGAJ,KAHJ;EAIA,IAAIK,+BAA+B,GAAG7C,6BAA6B,EAAnE;EACA,IAAIQ,KAAK,GAAGmC,cAAZ;EACA,IAAIjC,MAAM,GAAGkC,eAAb;;EACA,IAAIC,+BAAJ,EAAqC;IACnC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIrC,KAAK,GAAGqC,+BAA+B,CAACrC,KAAhC,GAAwC,CAAxC,GAA4CqC,+BAA+B,CAACrC,KAA5E,GAAoFmC,cAA5F;IACAjC,MAAM,GAAGmC,+BAA+B,CAACnC,MAAhC,GAAyC,CAAzC,GAA6CmC,+BAA+B,CAACnC,MAA7E,GAAsFkC,eAA/F;EACD;;EACDxD,SAAS,CAAC,MAAM;IACd,IAAI,CAACsD,UAAD,IAAezC,gBAAgB,CAACO,KAAD,CAA/B,IAA0CP,gBAAgB,CAACS,MAAD,CAA9D,EAAwE;MACtE+B,QAAQ,CAAClD,YAAY,CAAC;QACpBiB,KADoB;QAEpBE;MAFoB,CAAD,CAAb,CAAR;IAID;EACF,CAPQ,EAON,CAAC+B,QAAD,EAAWC,UAAX,EAAuBlC,KAAvB,EAA8BE,MAA9B,CAPM,CAAT;EAQA,OAAO,IAAP;AACD,CAzCM;AA0CP,OAAO,IAAIoC,iBAAiB,GAAGC,IAAI,IAAI;EACrC,IAAI;IACFhB;EADE,IAEAgB,IAFJ;EAGA,IAAIN,QAAQ,GAAGpD,cAAc,EAA7B;EACAD,SAAS,CAAC,MAAM;IACdqD,QAAQ,CAACjD,SAAS,CAACuC,MAAD,CAAV,CAAR;EACD,CAFQ,EAEN,CAACU,QAAD,EAAWV,MAAX,CAFM,CAAT;EAGA,OAAO,IAAP;AACD,CATM"},"metadata":{},"sourceType":"module"}