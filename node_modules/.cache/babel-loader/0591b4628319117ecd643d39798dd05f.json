{"ast":null,"code":"/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */\nimport Decimal from 'decimal.js-light';\nimport { getDigitCount, rangeStep } from './util/arithmetic';\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\n\nexport var getValidInterval = _ref => {\n  var [min, max] = _ref;\n  var [validMin, validMax] = [min, max]; // exchange\n\n  if (min > max) {\n    [validMin, validMax] = [max, min];\n  }\n\n  return [validMin, validMax];\n};\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  roughStep        The rough step calculated by dividing the difference by the tickCount\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step which is easy to understand between two ticks\n */\n\nexport var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {\n  if (roughStep.lte(0)) {\n    return new Decimal(0);\n  }\n\n  var digitCount = getDigitCount(roughStep.toNumber()); // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n\n  var digitCountValue = new Decimal(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue); // When an integer and a float multiplied, the accuracy of result may be wrong\n\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? new Decimal(formatStep.toNumber()) : new Decimal(Math.ceil(formatStep.toNumber()));\n};\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  value         The minimum value which is also the maximum value\n * @param  tickCount     The count of ticks\n * @param  allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\n\nexport var getTickOfSingleValue = (value, tickCount, allowDecimals) => {\n  var step = new Decimal(1); // calculate the middle value of ticks\n\n  var middle = new Decimal(value);\n\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new Decimal(10).pow(getDigitCount(value) - 1);\n      middle = new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new Decimal(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new Decimal(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new Decimal(Math.floor(value));\n  }\n\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var ticks = [];\n\n  for (var i = 0; i < tickCount; i++) {\n    ticks.push(middle.add(new Decimal(i - middleIndex).mul(step)).toNumber());\n  }\n\n  return ticks;\n};\n/**\n * Calculate the step\n *\n * @param  min              The minimum value of an interval\n * @param  max              The maximum value of an interval\n * @param  tickCount        The count of ticks\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step, minimum value of ticks, maximum value of ticks\n */\n\nvar _calculateStep = function calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0; // dirty hack (for recharts' test)\n\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new Decimal(0),\n      tickMin: new Decimal(0),\n      tickMax: new Decimal(0)\n    };\n  } // The step which is easy to understand between two ticks\n\n\n  var step = getFormatStep(new Decimal(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor); // A medial value of ticks\n\n  var middle; // When 0 is inside the interval, 0 should be a tick\n\n  if (min <= 0 && max >= 0) {\n    middle = new Decimal(0);\n  } else {\n    // calculate the middle value\n    middle = new Decimal(min).add(max).div(2); // minus modulo value\n\n    middle = middle.sub(new Decimal(middle).mod(step));\n  }\n\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return _calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n\n  return {\n    step,\n    tickMin: middle.sub(new Decimal(belowCount).mul(step)),\n    tickMax: middle.add(new Decimal(upCount).mul(step))\n  };\n};\n/**\n * Calculate the ticks of an interval. Ticks can appear outside the interval\n * if it makes them more rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\n\n\nexport { _calculateStep as calculateStep };\nexport var getNiceTickValues = function getNiceTickValues(_ref2) {\n  var [min, max] = _ref2;\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var count = Math.max(tickCount, 2);\n  var [cormin, cormax] = getValidInterval([min, max]);\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin, ...Array(tickCount - 1).fill(Infinity)] : [...Array(tickCount - 1).fill(-Infinity), cormax];\n\n    return min > max ? _values.reverse() : _values;\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  } // Get the step between two ticks\n\n\n  var {\n    step,\n    tickMin,\n    tickMax\n  } = _calculateStep(cormin, cormax, count, allowDecimals, 0);\n\n  var values = rangeStep(tickMin, tickMax.add(new Decimal(0.1).mul(step)), step);\n  return min > max ? values.reverse() : values;\n};\n/**\n * Calculate the ticks of an interval.\n * Ticks will be constrained to the interval [min, max] even if it makes them less rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks. This function may return less than tickCount ticks if the interval is too small.\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\n\nexport var getTickValuesFixedDomain = function getTickValuesFixedDomain(_ref3, tickCount) {\n  var [min, max] = _ref3;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var [cormin, cormax] = getValidInterval([min, max]);\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return [cormin];\n  }\n\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var values = [...rangeStep(new Decimal(cormin), new Decimal(cormax), step), cormax];\n\n  if (allowDecimals === false) {\n    /*\n     * allowDecimals is false means that we want to have integer ticks.\n     * The step is guaranteed to be an integer in the code above which is great start\n     * but when the first step is not an integer, it will start stepping from a decimal value anyway.\n     * So we need to round all the values to integers after the fact.\n     */\n    values = values.map(value => Math.round(value));\n  }\n\n  return min > max ? values.reverse() : values;\n};","map":{"version":3,"names":["Decimal","getDigitCount","rangeStep","getValidInterval","_ref","min","max","validMin","validMax","getFormatStep","roughStep","allowDecimals","correctionFactor","lte","digitCount","toNumber","digitCountValue","pow","stepRatio","div","stepRatioScale","amendStepRatio","Math","ceil","add","mul","formatStep","getTickOfSingleValue","value","tickCount","step","middle","isint","absVal","abs","floor","middleIndex","ticks","i","push","_calculateStep","calculateStep","arguments","length","undefined","Number","isFinite","tickMin","tickMax","sub","mod","belowCount","upCount","scaleCount","getNiceTickValues","_ref2","count","cormin","cormax","Infinity","_values","Array","fill","reverse","values","getTickValuesFixedDomain","_ref3","map","round"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/util/scale/getNiceTickValues.js"],"sourcesContent":["/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */\nimport Decimal from 'decimal.js-light';\nimport { getDigitCount, rangeStep } from './util/arithmetic';\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\nexport var getValidInterval = _ref => {\n  var [min, max] = _ref;\n  var [validMin, validMax] = [min, max];\n\n  // exchange\n  if (min > max) {\n    [validMin, validMax] = [max, min];\n  }\n  return [validMin, validMax];\n};\n\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  roughStep        The rough step calculated by dividing the difference by the tickCount\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step which is easy to understand between two ticks\n */\nexport var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {\n  if (roughStep.lte(0)) {\n    return new Decimal(0);\n  }\n  var digitCount = getDigitCount(roughStep.toNumber());\n  // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n  var digitCountValue = new Decimal(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue);\n  // When an integer and a float multiplied, the accuracy of result may be wrong\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? new Decimal(formatStep.toNumber()) : new Decimal(Math.ceil(formatStep.toNumber()));\n};\n\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  value         The minimum value which is also the maximum value\n * @param  tickCount     The count of ticks\n * @param  allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport var getTickOfSingleValue = (value, tickCount, allowDecimals) => {\n  var step = new Decimal(1);\n  // calculate the middle value of ticks\n  var middle = new Decimal(value);\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new Decimal(10).pow(getDigitCount(value) - 1);\n      middle = new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new Decimal(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new Decimal(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new Decimal(Math.floor(value));\n  }\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var ticks = [];\n  for (var i = 0; i < tickCount; i++) {\n    ticks.push(middle.add(new Decimal(i - middleIndex).mul(step)).toNumber());\n  }\n  return ticks;\n};\n\n/**\n * Calculate the step\n *\n * @param  min              The minimum value of an interval\n * @param  max              The maximum value of an interval\n * @param  tickCount        The count of ticks\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step, minimum value of ticks, maximum value of ticks\n */\nvar _calculateStep = function calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  // dirty hack (for recharts' test)\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new Decimal(0),\n      tickMin: new Decimal(0),\n      tickMax: new Decimal(0)\n    };\n  }\n\n  // The step which is easy to understand between two ticks\n  var step = getFormatStep(new Decimal(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor);\n\n  // A medial value of ticks\n  var middle;\n\n  // When 0 is inside the interval, 0 should be a tick\n  if (min <= 0 && max >= 0) {\n    middle = new Decimal(0);\n  } else {\n    // calculate the middle value\n    middle = new Decimal(min).add(max).div(2);\n    // minus modulo value\n    middle = middle.sub(new Decimal(middle).mod(step));\n  }\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return _calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n  return {\n    step,\n    tickMin: middle.sub(new Decimal(belowCount).mul(step)),\n    tickMax: middle.add(new Decimal(upCount).mul(step))\n  };\n};\n\n/**\n * Calculate the ticks of an interval. Ticks can appear outside the interval\n * if it makes them more rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport { _calculateStep as calculateStep };\nexport var getNiceTickValues = function getNiceTickValues(_ref2) {\n  var [min, max] = _ref2;\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin, ...Array(tickCount - 1).fill(Infinity)] : [...Array(tickCount - 1).fill(-Infinity), cormax];\n    return min > max ? _values.reverse() : _values;\n  }\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  // Get the step between two ticks\n  var {\n    step,\n    tickMin,\n    tickMax\n  } = _calculateStep(cormin, cormax, count, allowDecimals, 0);\n  var values = rangeStep(tickMin, tickMax.add(new Decimal(0.1).mul(step)), step);\n  return min > max ? values.reverse() : values;\n};\n\n/**\n * Calculate the ticks of an interval.\n * Ticks will be constrained to the interval [min, max] even if it makes them less rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks. This function may return less than tickCount ticks if the interval is too small.\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport var getTickValuesFixedDomain = function getTickValuesFixedDomain(_ref3, tickCount) {\n  var [min, max] = _ref3;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n  if (cormin === cormax) {\n    return [cormin];\n  }\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var values = [...rangeStep(new Decimal(cormin), new Decimal(cormax), step), cormax];\n  if (allowDecimals === false) {\n    /*\n     * allowDecimals is false means that we want to have integer ticks.\n     * The step is guaranteed to be an integer in the code above which is great start\n     * but when the first step is not an integer, it will start stepping from a decimal value anyway.\n     * So we need to round all the values to integers after the fact.\n     */\n    values = values.map(value => Math.round(value));\n  }\n  return min > max ? values.reverse() : values;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}