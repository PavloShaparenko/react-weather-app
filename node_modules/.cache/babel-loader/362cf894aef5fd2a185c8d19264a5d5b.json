{"ast":null,"code":"import isEqual from 'react-fast-compare';\nimport { lerp, random, randomElement, twoPi } from './utils.js';\nexport const defaultConfig = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1.0, 3.0],\n  wind: [-0.5, 2.0],\n  changeFrequency: 200,\n  rotationSpeed: [-1.0, 1.0],\n  opacity: [1, 1],\n  enable3DRotation: false\n};\n/**\n * An individual snowflake that will update it's location every call to `update`\n * and draw itself to the canvas every call to `draw`.\n */\n\nclass Snowflake {\n  /**\n   * A utility function to create a collection of snowflakes\n   * @param canvas The canvas element\n   * @param amount The number of snowflakes\n   * @param config The configuration for each snowflake\n   */\n  static createSnowflakes(canvas, amount, config) {\n    if (!canvas) return [];\n    const snowflakes = [];\n\n    for (let i = 0; i < amount; i++) {\n      snowflakes.push(new Snowflake(canvas, config));\n    }\n\n    return snowflakes;\n  }\n\n  constructor(canvas) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Set custom config\n    this.updateConfig(config); // Setting initial parameters\n\n    const {\n      radius,\n      wind,\n      speed,\n      rotationSpeed,\n      opacity,\n      enable3DRotation\n    } = this.config;\n    this.params = {\n      x: random(0, canvas.offsetWidth),\n      y: random(-canvas.offsetHeight, 0),\n      rotation: random(0, 360),\n      radius: random(...radius),\n      speed: random(...speed),\n      wind: random(...wind),\n      rotationSpeed: random(...rotationSpeed),\n      nextSpeed: random(...speed),\n      nextWind: random(...wind),\n      nextRotationSpeed: random(...rotationSpeed),\n      opacity: random(...opacity),\n      hasNextOpacity: false,\n      // Initialize 3D rotation parameters\n      rotationX: enable3DRotation ? random(0, 360) : 0,\n      rotationY: enable3DRotation ? random(0, 360) : 0,\n      rotationSpeedX: enable3DRotation ? random(-2.0, 2.0) : 0,\n      rotationSpeedY: enable3DRotation ? random(-2.0, 2.0) : 0,\n      nextRotationSpeedX: enable3DRotation ? random(-2.0, 2.0) : 0,\n      nextRotationSpeedY: enable3DRotation ? random(-2.0, 2.0) : 0\n    };\n    this.framesSinceLastUpdate = 0;\n  }\n\n  selectImage() {\n    if (this.config.images && this.config.images.length > 0) {\n      this.image = randomElement(this.config.images);\n    } else {\n      this.image = undefined;\n    }\n  }\n\n  updateConfig(config) {\n    const previousConfig = this.config;\n    this.config = { ...defaultConfig,\n      ...config\n    };\n    this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5); // Update the radius if the config has changed, it won't gradually update on it's own\n\n    if (this.params && !isEqual(this.config.radius, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.radius)) {\n      this.params.radius = random(...this.config.radius);\n    }\n\n    if (!isEqual(this.config.images, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.images)) {\n      this.selectImage();\n    }\n\n    if ((previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.opacity) && !isEqual(this.config.opacity, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.opacity)) {\n      this.params.hasNextOpacity = true;\n    }\n  }\n\n  updateTargetParams() {\n    this.params.nextSpeed = random(...this.config.speed);\n    this.params.nextWind = random(...this.config.wind);\n\n    if (this.image) {\n      this.params.nextRotationSpeed = random(...this.config.rotationSpeed);\n    }\n\n    if (this.config.enable3DRotation) {\n      this.params.nextRotationSpeedX = random(-2.0, 2.0);\n      this.params.nextRotationSpeedY = random(-2.0, 2.0);\n    }\n  }\n\n  update(offsetWidth, offsetHeight) {\n    let framesPassed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const {\n      x,\n      y,\n      rotation,\n      rotationSpeed,\n      nextRotationSpeed,\n      wind,\n      speed,\n      nextWind,\n      nextSpeed,\n      radius\n    } = this.params; // Update current location, wrapping around if going off the canvas\n\n    this.params.x = (x + wind * framesPassed) % (offsetWidth + radius * 2);\n    if (this.params.x > offsetWidth + radius) this.params.x = -radius;\n    this.params.y = (y + speed * framesPassed) % (offsetHeight + radius * 2);\n\n    if (this.params.y > offsetHeight + radius) {\n      if (this.params.hasNextOpacity) {\n        this.params.opacity = random(...this.config.opacity);\n        this.params.hasNextOpacity = false;\n      }\n\n      this.params.y = -radius;\n    } // Apply rotation\n\n\n    if (this.image || this.config.enable3DRotation) {\n      this.params.rotation = (rotation + rotationSpeed) % 360;\n    } // Apply 3D rotation if enabled\n\n\n    if (this.config.enable3DRotation) {\n      this.params.rotationX = (this.params.rotationX + this.params.rotationSpeedX * framesPassed) % 360;\n      this.params.rotationY = (this.params.rotationY + this.params.rotationSpeedY * framesPassed) % 360;\n    } // Update the wind, speed and rotation towards the desired values\n\n\n    this.params.speed = lerp(speed, nextSpeed, 0.01);\n    this.params.wind = lerp(wind, nextWind, 0.01);\n    this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, 0.01);\n\n    if (this.config.enable3DRotation) {\n      this.params.rotationSpeedX = lerp(this.params.rotationSpeedX, this.params.nextRotationSpeedX, 0.01);\n      this.params.rotationSpeedY = lerp(this.params.rotationSpeedY, this.params.nextRotationSpeedY, 0.01);\n    }\n\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\n      this.updateTargetParams();\n      this.framesSinceLastUpdate = 0;\n    }\n  }\n\n  getImageOffscreenCanvas(image, size) {\n    var _a, _b;\n\n    if (image instanceof HTMLImageElement && image.loading) return image;\n    let sizes = Snowflake.offscreenCanvases.get(image);\n\n    if (!sizes) {\n      sizes = {};\n      Snowflake.offscreenCanvases.set(image, sizes);\n    }\n\n    if (!(size in sizes)) {\n      const canvas = document.createElement('canvas');\n      canvas.width = size;\n      canvas.height = size;\n      (_a = canvas.getContext('2d')) === null || _a === void 0 ? void 0 : _a.drawImage(image, 0, 0, size, size);\n      sizes[size] = canvas;\n    }\n\n    return (_b = sizes[size]) !== null && _b !== void 0 ? _b : image;\n  }\n  /**\n   * Applies 3D rotation transform to the canvas context.\n   * This method calculates and applies the transformation matrix for 3D rotation effects.\n   *\n   * @param ctx The canvas context to apply the transform to\n   * @param x The x position to translate to\n   * @param y The y position to translate to\n   */\n\n\n  apply3DTransform(ctx, x, y) {\n    if (this.config.enable3DRotation) {\n      const {\n        rotationX,\n        rotationY\n      } = this.params;\n      const rotation = this.params.rotation || 0; // Convert degrees to radians\n\n      const radX = rotationX * Math.PI / 180;\n      const radY = rotationY * Math.PI / 180;\n      const radZ = rotation * Math.PI / 180; // Calculate 3D rotation matrices\n\n      const cosX = Math.cos(radX);\n      const sinX = Math.sin(radX);\n      const cosY = Math.cos(radY);\n      const sinY = Math.sin(radY);\n      const cosZ = Math.cos(radZ);\n      const sinZ = Math.sin(radZ); // Combined rotation matrix (Z * Y * X)\n      // This creates a 3D tumbling effect\n\n      const a = cosZ * cosY;\n      const b = cosZ * sinY * sinX - sinZ * cosX;\n      const c = cosZ * sinY * cosX + sinZ * sinX;\n      const d = sinZ * cosY; // Apply the transform\n      // The arguments for setTransform are: a, b, c, d, e, f\n      // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\n\n      ctx.setTransform(a, b, c, d, x, y);\n    } else {\n      // Original 2D rotation (only for images)\n      const rotation = this.params.rotation || 0;\n      const radian = rotation * Math.PI / 180;\n      const cos = Math.cos(radian);\n      const sin = Math.sin(radian); // The arguments for setTransform are: a, b, c, d, e, f\n      // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\n\n      ctx.setTransform(cos, sin, -sin, cos, x, y);\n    }\n  }\n  /**\n   * Draws a circular snowflake to the canvas.\n   *\n   * This method should only be called if our config does not have images.\n   *\n   * This method assumes that a path has already been started on the canvas.\n   * `ctx.beginPath()` should be called before calling this method.\n   *\n   * After calling this method, the fillStyle should be set to the snowflake's\n   * color and `ctx.fill()` should be called to fill the snowflake.\n   *\n   * Calling `ctx.fill()` after multiple snowflakes have had `drawCircle` called\n   * will render all of the snowflakes since the last call to `ctx.beginPath()`.\n   *\n   * @param ctx The canvas context to draw to\n   */\n\n\n  drawCircle(ctx) {\n    // If 3D rotation is enabled, we need to draw individually with transform\n    // This method is called when 3D rotation is disabled (for performance)\n    ctx.moveTo(this.params.x, this.params.y);\n    ctx.arc(this.params.x, this.params.y, this.params.radius, 0, twoPi);\n  }\n  /**\n   * Draws a circular snowflake with 3D rotation effect to the canvas.\n   *\n   * This method is used when 3D rotation is enabled and images are not being used.\n   *\n   * @param ctx The canvas context to draw to\n   * @param color The color to fill the circle with\n   */\n\n\n  drawCircle3D(ctx, color) {\n    const {\n      x,\n      y,\n      radius\n    } = this.params;\n    ctx.save(); // Apply 3D rotation transform\n\n    if (this.config.enable3DRotation) {\n      this.apply3DTransform(ctx, x, y);\n    } else {\n      // No transform needed for circles without 3D rotation\n      ctx.translate(x, y);\n    } // Draw the circle\n\n\n    ctx.beginPath();\n    ctx.arc(0, 0, radius, 0, twoPi);\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.restore();\n  }\n  /**\n   * Draws an image-based snowflake to the canvas.\n   *\n   * This method should only be called if our config has images.\n   *\n   * @param ctx The canvas context to draw to\n   */\n\n\n  drawImage(ctx) {\n    const {\n      x,\n      y,\n      radius\n    } = this.params; // Save the current state to avoid affecting other drawings\n\n    ctx.save(); // Set opacity if needed\n\n    if (this.params.opacity !== 1) {\n      ctx.globalAlpha = this.params.opacity;\n    } // Apply 3D or 2D rotation transform\n\n\n    this.apply3DTransform(ctx, x, y); // Draw the image with the center of the image at the center of the current location\n\n    const image = this.getImageOffscreenCanvas(this.image, radius);\n    ctx.drawImage(image, -(radius / 2), -(radius / 2), radius, radius); // Restore the transform\n\n    ctx.restore();\n  }\n\n}\n\nSnowflake.offscreenCanvases = new WeakMap();\nexport default Snowflake;","map":{"version":3,"mappings":"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","names":["isEqual","lerp","random","randomElement","twoPi","defaultConfig","color","radius","speed","wind","changeFrequency","rotationSpeed","opacity","enable3DRotation","Snowflake","createSnowflakes","canvas","amount","config","snowflakes","i","push","constructor","updateConfig","params","x","offsetWidth","y","offsetHeight","rotation","nextSpeed","nextWind","nextRotationSpeed","hasNextOpacity","rotationX","rotationY","rotationSpeedX","rotationSpeedY","nextRotationSpeedX","nextRotationSpeedY","framesSinceLastUpdate","selectImage","images","length","image","undefined","previousConfig","updateTargetParams","update","framesPassed","getImageOffscreenCanvas","size","HTMLImageElement","loading","sizes","offscreenCanvases","get","set","document","createElement","width","height","getContext","_a","drawImage","_b","apply3DTransform","ctx","radX","Math","PI","radY","radZ","cosX","cos","sinX","sin","cosY","sinY","cosZ","sinZ","a","b","c","d","setTransform","radian","drawCircle","moveTo","arc","drawCircle3D","save","translate","beginPath","fillStyle","fill","restore","globalAlpha","WeakMap"],"sources":["C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\react-snowfall\\src\\Snowflake.ts"],"sourcesContent":["import isEqual from 'react-fast-compare'\r\nimport { lerp, random, randomElement, twoPi } from './utils.js'\r\n\r\nexport interface SnowflakeProps {\r\n  /** The color of the snowflake, can be any valid CSS color. */\r\n  color: string\r\n  /**\r\n   * The minimum and maximum radius of the snowflake, will be\r\n   * randomly selected within this range.\r\n   *\r\n   * The default value is `[0.5, 3.0]`.\r\n   */\r\n  radius: [number, number]\r\n  /**\r\n   * The minimum and maximum speed of the snowflake.\r\n   *\r\n   * The speed determines how quickly the snowflake moves\r\n   * along the y axis (vertical speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1.0, 3.0]`.\r\n   */\r\n  speed: [number, number]\r\n  /**\r\n   * The minimum and maximum wind of the snowflake.\r\n   *\r\n   * The wind determines how quickly the snowflake moves\r\n   * along the x axis (horizontal speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-0.5, 2.0]`.\r\n   */\r\n  wind: [number, number]\r\n  /**\r\n   * The frequency in frames that the wind and speed values\r\n   * will update.\r\n   *\r\n   * The default value is 200.\r\n   */\r\n  changeFrequency: number\r\n  /**\r\n   * An array of images that will be rendered as the snowflakes instead\r\n   * of the default circle shapes.\r\n   */\r\n  images?: CanvasImageSource[]\r\n  /**\r\n   * The minimum and maximum rotation speed of the snowflake (in degrees of\r\n   * rotation per frame).\r\n   *\r\n   * The rotation speed determines how quickly the snowflake rotates when\r\n   * an image is being rendered.\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-1.0, 1.0]`.\r\n   */\r\n  rotationSpeed: [number, number]\r\n  /**\r\n   * The minimum and maximum opacity of the snowflake image.\r\n   *\r\n   * This value only applies to snowflakes that are using images.\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1, 1]`.\r\n   */\r\n  opacity: [number, number]\r\n  /**\r\n   * Enable 3D rotation effect (like falling leaves).\r\n   *\r\n   * When enabled, snowflakes will rotate on X and Y axes in addition to Z axis,\r\n   * creating a more realistic 3D tumbling effect.\r\n   *\r\n   * The default value is `false`.\r\n   */\r\n  enable3DRotation?: boolean\r\n}\r\n\r\nexport type SnowflakeConfig = Partial<SnowflakeProps>\r\n\r\nexport const defaultConfig: SnowflakeProps = {\r\n  color: '#dee4fd',\r\n  radius: [0.5, 3.0],\r\n  speed: [1.0, 3.0],\r\n  wind: [-0.5, 2.0],\r\n  changeFrequency: 200,\r\n  rotationSpeed: [-1.0, 1.0],\r\n  opacity: [1, 1],\r\n  enable3DRotation: false,\r\n}\r\n\r\ninterface SnowflakeParams {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  rotation: number\r\n  rotationSpeed: number\r\n  speed: number\r\n  wind: number\r\n  nextSpeed: number\r\n  nextWind: number\r\n  nextRotationSpeed: number\r\n  opacity: number\r\n  hasNextOpacity: boolean\r\n  // 3D rotation parameters\r\n  rotationX: number\r\n  rotationY: number\r\n  rotationSpeedX: number\r\n  rotationSpeedY: number\r\n  nextRotationSpeedX: number\r\n  nextRotationSpeedY: number\r\n}\r\n\r\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\r\nclass Snowflake {\r\n  private static offscreenCanvases = new WeakMap<CanvasImageSource, Record<number, HTMLCanvasElement>>()\r\n\r\n  /**\r\n   * A utility function to create a collection of snowflakes\r\n   * @param canvas The canvas element\r\n   * @param amount The number of snowflakes\r\n   * @param config The configuration for each snowflake\r\n   */\r\n  static createSnowflakes(canvas: HTMLCanvasElement | null, amount: number, config: SnowflakeConfig): Snowflake[] {\r\n    if (!canvas) return []\r\n\r\n    const snowflakes: Snowflake[] = []\r\n\r\n    for (let i = 0; i < amount; i++) {\r\n      snowflakes.push(new Snowflake(canvas, config))\r\n    }\r\n\r\n    return snowflakes\r\n  }\r\n\r\n  private config!: SnowflakeProps\r\n  private params: SnowflakeParams\r\n  private framesSinceLastUpdate: number\r\n  private image?: CanvasImageSource\r\n\r\n  public constructor(canvas: HTMLCanvasElement, config: SnowflakeConfig = {}) {\r\n    // Set custom config\r\n    this.updateConfig(config)\r\n\r\n    // Setting initial parameters\r\n    const { radius, wind, speed, rotationSpeed, opacity, enable3DRotation } = this.config\r\n\r\n    this.params = {\r\n      x: random(0, canvas.offsetWidth),\r\n      y: random(-canvas.offsetHeight, 0),\r\n      rotation: random(0, 360),\r\n      radius: random(...radius),\r\n      speed: random(...speed),\r\n      wind: random(...wind),\r\n      rotationSpeed: random(...rotationSpeed),\r\n      nextSpeed: random(...speed),\r\n      nextWind: random(...wind),\r\n      nextRotationSpeed: random(...rotationSpeed),\r\n      opacity: random(...opacity),\r\n      hasNextOpacity: false,\r\n      // Initialize 3D rotation parameters\r\n      rotationX: enable3DRotation ? random(0, 360) : 0,\r\n      rotationY: enable3DRotation ? random(0, 360) : 0,\r\n      rotationSpeedX: enable3DRotation ? random(-2.0, 2.0) : 0,\r\n      rotationSpeedY: enable3DRotation ? random(-2.0, 2.0) : 0,\r\n      nextRotationSpeedX: enable3DRotation ? random(-2.0, 2.0) : 0,\r\n      nextRotationSpeedY: enable3DRotation ? random(-2.0, 2.0) : 0,\r\n    }\r\n\r\n    this.framesSinceLastUpdate = 0\r\n  }\r\n\r\n  private selectImage() {\r\n    if (this.config.images && this.config.images.length > 0) {\r\n      this.image = randomElement(this.config.images)\r\n    } else {\r\n      this.image = undefined\r\n    }\r\n  }\r\n\r\n  public updateConfig(config: SnowflakeConfig): void {\r\n    const previousConfig = this.config\r\n    this.config = { ...defaultConfig, ...config }\r\n    this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5)\r\n\r\n    // Update the radius if the config has changed, it won't gradually update on it's own\r\n    if (this.params && !isEqual(this.config.radius, previousConfig?.radius)) {\r\n      this.params.radius = random(...this.config.radius)\r\n    }\r\n\r\n    if (!isEqual(this.config.images, previousConfig?.images)) {\r\n      this.selectImage()\r\n    }\r\n\r\n    if (previousConfig?.opacity && !isEqual(this.config.opacity, previousConfig?.opacity)) {\r\n      this.params.hasNextOpacity = true\r\n    }\r\n  }\r\n\r\n  private updateTargetParams(): void {\r\n    this.params.nextSpeed = random(...this.config.speed)\r\n    this.params.nextWind = random(...this.config.wind)\r\n    if (this.image) {\r\n      this.params.nextRotationSpeed = random(...this.config.rotationSpeed)\r\n    }\r\n    if (this.config.enable3DRotation) {\r\n      this.params.nextRotationSpeedX = random(-2.0, 2.0)\r\n      this.params.nextRotationSpeedY = random(-2.0, 2.0)\r\n    }\r\n  }\r\n\r\n  public update(offsetWidth: number, offsetHeight: number, framesPassed = 1): void {\r\n    const { x, y, rotation, rotationSpeed, nextRotationSpeed, wind, speed, nextWind, nextSpeed, radius } = this.params\r\n\r\n    // Update current location, wrapping around if going off the canvas\r\n    this.params.x = (x + wind * framesPassed) % (offsetWidth + radius * 2)\r\n    if (this.params.x > offsetWidth + radius) this.params.x = -radius\r\n    this.params.y = (y + speed * framesPassed) % (offsetHeight + radius * 2)\r\n    if (this.params.y > offsetHeight + radius) {\r\n      if (this.params.hasNextOpacity) {\r\n        this.params.opacity = random(...this.config.opacity)\r\n        this.params.hasNextOpacity = false\r\n      }\r\n      this.params.y = -radius\r\n    }\r\n\r\n    // Apply rotation\r\n    if (this.image || this.config.enable3DRotation) {\r\n      this.params.rotation = (rotation + rotationSpeed) % 360\r\n    }\r\n\r\n    // Apply 3D rotation if enabled\r\n    if (this.config.enable3DRotation) {\r\n      this.params.rotationX = (this.params.rotationX + this.params.rotationSpeedX * framesPassed) % 360\r\n      this.params.rotationY = (this.params.rotationY + this.params.rotationSpeedY * framesPassed) % 360\r\n    }\r\n\r\n    // Update the wind, speed and rotation towards the desired values\r\n    this.params.speed = lerp(speed, nextSpeed, 0.01)\r\n    this.params.wind = lerp(wind, nextWind, 0.01)\r\n    this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, 0.01)\r\n\r\n    if (this.config.enable3DRotation) {\r\n      this.params.rotationSpeedX = lerp(this.params.rotationSpeedX, this.params.nextRotationSpeedX, 0.01)\r\n      this.params.rotationSpeedY = lerp(this.params.rotationSpeedY, this.params.nextRotationSpeedY, 0.01)\r\n    }\r\n\r\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\r\n      this.updateTargetParams()\r\n      this.framesSinceLastUpdate = 0\r\n    }\r\n  }\r\n\r\n  private getImageOffscreenCanvas(image: CanvasImageSource, size: number): CanvasImageSource {\r\n    if (image instanceof HTMLImageElement && image.loading) return image\r\n    let sizes = Snowflake.offscreenCanvases.get(image)\r\n\r\n    if (!sizes) {\r\n      sizes = {}\r\n      Snowflake.offscreenCanvases.set(image, sizes)\r\n    }\r\n\r\n    if (!(size in sizes)) {\r\n      const canvas = document.createElement('canvas')\r\n      canvas.width = size\r\n      canvas.height = size\r\n      canvas.getContext('2d')?.drawImage(image, 0, 0, size, size)\r\n      sizes[size] = canvas\r\n    }\r\n\r\n    return sizes[size] ?? image\r\n  }\r\n\r\n  /**\r\n   * Applies 3D rotation transform to the canvas context.\r\n   * This method calculates and applies the transformation matrix for 3D rotation effects.\r\n   *\r\n   * @param ctx The canvas context to apply the transform to\r\n   * @param x The x position to translate to\r\n   * @param y The y position to translate to\r\n   */\r\n  private apply3DTransform(ctx: CanvasRenderingContext2D, x: number, y: number): void {\r\n    if (this.config.enable3DRotation) {\r\n      const { rotationX, rotationY } = this.params\r\n      const rotation = this.params.rotation || 0\r\n\r\n      // Convert degrees to radians\r\n      const radX = (rotationX * Math.PI) / 180\r\n      const radY = (rotationY * Math.PI) / 180\r\n      const radZ = (rotation * Math.PI) / 180\r\n\r\n      // Calculate 3D rotation matrices\r\n      const cosX = Math.cos(radX)\r\n      const sinX = Math.sin(radX)\r\n      const cosY = Math.cos(radY)\r\n      const sinY = Math.sin(radY)\r\n      const cosZ = Math.cos(radZ)\r\n      const sinZ = Math.sin(radZ)\r\n\r\n      // Combined rotation matrix (Z * Y * X)\r\n      // This creates a 3D tumbling effect\r\n      const a = cosZ * cosY\r\n      const b = cosZ * sinY * sinX - sinZ * cosX\r\n      const c = cosZ * sinY * cosX + sinZ * sinX\r\n      const d = sinZ * cosY\r\n\r\n      // Apply the transform\r\n      // The arguments for setTransform are: a, b, c, d, e, f\r\n      // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\r\n      ctx.setTransform(a, b, c, d, x, y)\r\n    } else {\r\n      // Original 2D rotation (only for images)\r\n      const rotation = this.params.rotation || 0\r\n      const radian = (rotation * Math.PI) / 180\r\n      const cos = Math.cos(radian)\r\n      const sin = Math.sin(radian)\r\n\r\n      // The arguments for setTransform are: a, b, c, d, e, f\r\n      // a (scaleX), b (skewY), c (skewX), d (scaleY), e (translateX), f (translateY)\r\n      ctx.setTransform(cos, sin, -sin, cos, x, y)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draws a circular snowflake to the canvas.\r\n   *\r\n   * This method should only be called if our config does not have images.\r\n   *\r\n   * This method assumes that a path has already been started on the canvas.\r\n   * `ctx.beginPath()` should be called before calling this method.\r\n   *\r\n   * After calling this method, the fillStyle should be set to the snowflake's\r\n   * color and `ctx.fill()` should be called to fill the snowflake.\r\n   *\r\n   * Calling `ctx.fill()` after multiple snowflakes have had `drawCircle` called\r\n   * will render all of the snowflakes since the last call to `ctx.beginPath()`.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   */\r\n  public drawCircle(ctx: CanvasRenderingContext2D): void {\r\n    // If 3D rotation is enabled, we need to draw individually with transform\r\n    // This method is called when 3D rotation is disabled (for performance)\r\n    ctx.moveTo(this.params.x, this.params.y)\r\n    ctx.arc(this.params.x, this.params.y, this.params.radius, 0, twoPi)\r\n  }\r\n\r\n  /**\r\n   * Draws a circular snowflake with 3D rotation effect to the canvas.\r\n   *\r\n   * This method is used when 3D rotation is enabled and images are not being used.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   * @param color The color to fill the circle with\r\n   */\r\n  public drawCircle3D(ctx: CanvasRenderingContext2D, color: string): void {\r\n    const { x, y, radius } = this.params\r\n\r\n    ctx.save()\r\n\r\n    // Apply 3D rotation transform\r\n    if (this.config.enable3DRotation) {\r\n      this.apply3DTransform(ctx, x, y)\r\n    } else {\r\n      // No transform needed for circles without 3D rotation\r\n      ctx.translate(x, y)\r\n    }\r\n\r\n    // Draw the circle\r\n    ctx.beginPath()\r\n    ctx.arc(0, 0, radius, 0, twoPi)\r\n    ctx.fillStyle = color\r\n    ctx.fill()\r\n\r\n    ctx.restore()\r\n  }\r\n\r\n  /**\r\n   * Draws an image-based snowflake to the canvas.\r\n   *\r\n   * This method should only be called if our config has images.\r\n   *\r\n   * @param ctx The canvas context to draw to\r\n   */\r\n  public drawImage(ctx: CanvasRenderingContext2D): void {\r\n    const { x, y, radius } = this.params\r\n\r\n    // Save the current state to avoid affecting other drawings\r\n    ctx.save()\r\n\r\n    // Set opacity if needed\r\n    if (this.params.opacity !== 1) {\r\n      ctx.globalAlpha = this.params.opacity\r\n    }\r\n\r\n    // Apply 3D or 2D rotation transform\r\n    this.apply3DTransform(ctx, x, y)\r\n\r\n    // Draw the image with the center of the image at the center of the current location\r\n    const image = this.getImageOffscreenCanvas(this.image!, radius)\r\n    ctx.drawImage(image, -(radius / 2), -(radius / 2), radius, radius)\r\n\r\n    // Restore the transform\r\n    ctx.restore()\r\n  }\r\n}\r\n\r\nexport default Snowflake\r\n"]},"metadata":{},"sourceType":"module"}