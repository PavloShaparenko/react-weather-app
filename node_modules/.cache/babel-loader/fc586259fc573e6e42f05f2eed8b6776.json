{"ast":null,"code":"import { createAction, createListenerMiddleware } from '@reduxjs/toolkit';\nimport { selectActiveLabel, selectActiveTooltipCoordinate, selectActiveTooltipDataKey, selectActiveTooltipIndex, selectIsTooltipActive } from './selectors/tooltipSelectors';\nexport var externalEventAction = createAction('externalEvent');\nexport var externalEventsMiddleware = createListenerMiddleware();\n/*\n * We need a Map keyed by event type because this middleware handles MULTIPLE different event types\n * (click, mouseenter, mouseleave, mousedown, mouseup, contextmenu, dblclick, touchstart, touchmove, touchend)\n * from the same DOM element. Different event types should NOT cancel each other's animation frames.\n * For example, a click event and a mousemove event can happen in quick succession and both should be processed.\n * This is different from mouseMoveMiddleware which only handles one event type and uses a single rafId.\n */\n\nvar rafIdMap = new Map();\nexternalEventsMiddleware.startListening({\n  actionCreator: externalEventAction,\n  effect: (action, listenerApi) => {\n    var {\n      handler,\n      reactEvent\n    } = action.payload;\n\n    if (handler == null) {\n      return;\n    }\n\n    reactEvent.persist();\n    var eventType = reactEvent.type; // Cancel any pending animation frame for this event type\n\n    var existingRafId = rafIdMap.get(eventType);\n\n    if (existingRafId !== undefined) {\n      cancelAnimationFrame(existingRafId);\n    }\n\n    var rafId = requestAnimationFrame(() => {\n      try {\n        /*\n         * Here it is important that we get the latest state inside the animation frame callback,\n         * not from the outer scope, because there may have been other actions dispatched\n         * between the time the event was fired and the animation frame callback is executed.\n         * One of those actions is the one that actually sets the active tooltip state!\n         */\n        var state = listenerApi.getState();\n        var nextState = {\n          activeCoordinate: selectActiveTooltipCoordinate(state),\n          activeDataKey: selectActiveTooltipDataKey(state),\n          activeIndex: selectActiveTooltipIndex(state),\n          activeLabel: selectActiveLabel(state),\n          activeTooltipIndex: selectActiveTooltipIndex(state),\n          isTooltipActive: selectIsTooltipActive(state)\n        };\n        handler(nextState, reactEvent);\n      } finally {\n        rafIdMap.delete(eventType);\n      }\n    });\n    rafIdMap.set(eventType, rafId);\n  }\n});","map":{"version":3,"names":["createAction","createListenerMiddleware","selectActiveLabel","selectActiveTooltipCoordinate","selectActiveTooltipDataKey","selectActiveTooltipIndex","selectIsTooltipActive","externalEventAction","externalEventsMiddleware","rafIdMap","Map","startListening","actionCreator","effect","action","listenerApi","handler","reactEvent","payload","persist","eventType","type","existingRafId","get","undefined","cancelAnimationFrame","rafId","requestAnimationFrame","state","getState","nextState","activeCoordinate","activeDataKey","activeIndex","activeLabel","activeTooltipIndex","isTooltipActive","delete","set"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/state/externalEventsMiddleware.js"],"sourcesContent":["import { createAction, createListenerMiddleware } from '@reduxjs/toolkit';\nimport { selectActiveLabel, selectActiveTooltipCoordinate, selectActiveTooltipDataKey, selectActiveTooltipIndex, selectIsTooltipActive } from './selectors/tooltipSelectors';\nexport var externalEventAction = createAction('externalEvent');\nexport var externalEventsMiddleware = createListenerMiddleware();\n\n/*\n * We need a Map keyed by event type because this middleware handles MULTIPLE different event types\n * (click, mouseenter, mouseleave, mousedown, mouseup, contextmenu, dblclick, touchstart, touchmove, touchend)\n * from the same DOM element. Different event types should NOT cancel each other's animation frames.\n * For example, a click event and a mousemove event can happen in quick succession and both should be processed.\n * This is different from mouseMoveMiddleware which only handles one event type and uses a single rafId.\n */\nvar rafIdMap = new Map();\nexternalEventsMiddleware.startListening({\n  actionCreator: externalEventAction,\n  effect: (action, listenerApi) => {\n    var {\n      handler,\n      reactEvent\n    } = action.payload;\n    if (handler == null) {\n      return;\n    }\n    reactEvent.persist();\n    var eventType = reactEvent.type;\n\n    // Cancel any pending animation frame for this event type\n    var existingRafId = rafIdMap.get(eventType);\n    if (existingRafId !== undefined) {\n      cancelAnimationFrame(existingRafId);\n    }\n    var rafId = requestAnimationFrame(() => {\n      try {\n        /*\n         * Here it is important that we get the latest state inside the animation frame callback,\n         * not from the outer scope, because there may have been other actions dispatched\n         * between the time the event was fired and the animation frame callback is executed.\n         * One of those actions is the one that actually sets the active tooltip state!\n         */\n        var state = listenerApi.getState();\n        var nextState = {\n          activeCoordinate: selectActiveTooltipCoordinate(state),\n          activeDataKey: selectActiveTooltipDataKey(state),\n          activeIndex: selectActiveTooltipIndex(state),\n          activeLabel: selectActiveLabel(state),\n          activeTooltipIndex: selectActiveTooltipIndex(state),\n          isTooltipActive: selectIsTooltipActive(state)\n        };\n        handler(nextState, reactEvent);\n      } finally {\n        rafIdMap.delete(eventType);\n      }\n    });\n    rafIdMap.set(eventType, rafId);\n  }\n});"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,wBAAvB,QAAuD,kBAAvD;AACA,SAASC,iBAAT,EAA4BC,6BAA5B,EAA2DC,0BAA3D,EAAuFC,wBAAvF,EAAiHC,qBAAjH,QAA8I,8BAA9I;AACA,OAAO,IAAIC,mBAAmB,GAAGP,YAAY,CAAC,eAAD,CAAtC;AACP,OAAO,IAAIQ,wBAAwB,GAAGP,wBAAwB,EAAvD;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIQ,QAAQ,GAAG,IAAIC,GAAJ,EAAf;AACAF,wBAAwB,CAACG,cAAzB,CAAwC;EACtCC,aAAa,EAAEL,mBADuB;EAEtCM,MAAM,EAAE,CAACC,MAAD,EAASC,WAAT,KAAyB;IAC/B,IAAI;MACFC,OADE;MAEFC;IAFE,IAGAH,MAAM,CAACI,OAHX;;IAIA,IAAIF,OAAO,IAAI,IAAf,EAAqB;MACnB;IACD;;IACDC,UAAU,CAACE,OAAX;IACA,IAAIC,SAAS,GAAGH,UAAU,CAACI,IAA3B,CAT+B,CAW/B;;IACA,IAAIC,aAAa,GAAGb,QAAQ,CAACc,GAAT,CAAaH,SAAb,CAApB;;IACA,IAAIE,aAAa,KAAKE,SAAtB,EAAiC;MAC/BC,oBAAoB,CAACH,aAAD,CAApB;IACD;;IACD,IAAII,KAAK,GAAGC,qBAAqB,CAAC,MAAM;MACtC,IAAI;QACF;AACR;AACA;AACA;AACA;AACA;QACQ,IAAIC,KAAK,GAAGb,WAAW,CAACc,QAAZ,EAAZ;QACA,IAAIC,SAAS,GAAG;UACdC,gBAAgB,EAAE5B,6BAA6B,CAACyB,KAAD,CADjC;UAEdI,aAAa,EAAE5B,0BAA0B,CAACwB,KAAD,CAF3B;UAGdK,WAAW,EAAE5B,wBAAwB,CAACuB,KAAD,CAHvB;UAIdM,WAAW,EAAEhC,iBAAiB,CAAC0B,KAAD,CAJhB;UAKdO,kBAAkB,EAAE9B,wBAAwB,CAACuB,KAAD,CAL9B;UAMdQ,eAAe,EAAE9B,qBAAqB,CAACsB,KAAD;QANxB,CAAhB;QAQAZ,OAAO,CAACc,SAAD,EAAYb,UAAZ,CAAP;MACD,CAjBD,SAiBU;QACRR,QAAQ,CAAC4B,MAAT,CAAgBjB,SAAhB;MACD;IACF,CArBgC,CAAjC;IAsBAX,QAAQ,CAAC6B,GAAT,CAAalB,SAAb,EAAwBM,KAAxB;EACD;AAzCqC,CAAxC"},"metadata":{},"sourceType":"module"}