{"ast":null,"code":"import { isVisible } from '../util/TickUtils';\nimport { getEveryNth } from '../util/getEveryNth';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  // If the ticks are readonly, then the slice might not be necessary\n  var result = (ticks || []).slice();\n  var {\n    start: initialStart,\n    end\n  } = boundaries;\n  var index = 0; // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n\n  var stepsize = 1;\n  var start = initialStart;\n\n  var _loop = function _loop() {\n    // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n    // If it can not, then increase the stepsize by 1, and try again.\n    var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index]; // Break condition - If we have evaluated all the ticks, then we are done.\n\n    if (entry === undefined) {\n      return {\n        v: getEveryNth(ticks, stepsize)\n      };\n    } // Check if the element collides with the next element\n\n\n    var i = index;\n    var size;\n\n    var getSize = () => {\n      if (size === undefined) {\n        size = getTickSize(entry, i);\n      }\n\n      return size;\n    };\n\n    var tickCoord = entry.coordinate; // We will always show the first tick.\n\n    var isShow = index === 0 || isVisible(sign, tickCoord, getSize, start, end);\n\n    if (!isShow) {\n      // Start all over with a larger stepsize\n      index = 0;\n      start = initialStart;\n      stepsize += 1;\n    }\n\n    if (isShow) {\n      // If it can be shown, update the start\n      start = tickCoord + sign * (getSize() / 2 + minTickGap);\n      index += stepsize;\n    }\n  },\n      _ret;\n\n  while (stepsize <= result.length) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n\n  return [];\n}\nexport function getEquidistantPreserveEndTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  // If the ticks are readonly, then the slice might not be necessary\n  // Reworked logic for getEquidistantPreserveEndTicks\n  var result = (ticks || []).slice();\n  var len = result.length;\n\n  if (len === 0) {\n    return [];\n  }\n\n  var {\n    start: initialStart,\n    end\n  } = boundaries; // Start with stepsize = 1 (every tick) up to the maximum possible stepsize (len)\n\n  for (var stepsize = 1; stepsize <= len; stepsize++) {\n    // 1. Calculate the offset so the last tick (index len - 1) is always included in the sequence.\n    var offset = (len - 1) % stepsize;\n    var start = initialStart; // `start` tracks the coordinate of the last successfully drawn tick + gap\n\n    var ok = true; // 2. Iterate through the end-anchored sequence: offset, offset + stepsize, ..., len - 1\n\n    var _loop2 = function _loop2() {\n      var entry = ticks[index];\n\n      if (entry == null) {\n        return 0; // continue\n      }\n\n      var i = index;\n      var size; // Use a function to get size, as in the original code\n\n      var getSize = () => {\n        if (size === undefined) {\n          size = getTickSize(entry, i);\n        }\n\n        return size;\n      };\n\n      var tickCoord = entry.coordinate; // 3. Apply visibility logic (including the first tick special case)\n      // The reviewer says *not* to unconditionally bypass checks for the last tick.\n\n      var isShow = index === offset || isVisible(sign, tickCoord, getSize, start, end);\n\n      if (!isShow) {\n        // If any tick in this end-anchored sequence fails visibility/collision,\n        // reject this stepsize and move to the next iteration (larger stepsize).\n        ok = false;\n        return 1; // break\n      } // 4. If showable, update the 'start' coordinate for the next collision check\n\n\n      if (isShow) {\n        start = tickCoord + sign * (getSize() / 2 + minTickGap);\n      }\n    },\n        _ret2;\n\n    for (var index = offset; index < len; index += stepsize) {\n      _ret2 = _loop2();\n      if (_ret2 === 0) continue;\n      if (_ret2 === 1) break;\n    } // 5. If the entire sequence for this stepsize passed the visibility check, return the result\n\n\n    if (ok) {\n      // Build the final result array explicitly using the validated stepsize and offset.\n      var finalTicks = [];\n\n      for (var _index = offset; _index < len; _index += stepsize) {\n        var tick = ticks[_index];\n\n        if (tick != null) {\n          finalTicks.push(tick);\n        }\n      }\n\n      return finalTicks;\n    }\n  } // If no stepsize works (this shouldn't happen unless minTickGap is huge), return an empty array.\n\n\n  return [];\n}","map":{"version":3,"names":["isVisible","getEveryNth","getEquidistantTicks","sign","boundaries","getTickSize","ticks","minTickGap","result","slice","start","initialStart","end","index","stepsize","_loop","entry","undefined","v","i","size","getSize","tickCoord","coordinate","isShow","_ret","length","getEquidistantPreserveEndTicks","len","offset","ok","_loop2","_ret2","finalTicks","_index","tick","push"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/cartesian/getEquidistantTicks.js"],"sourcesContent":["import { isVisible } from '../util/TickUtils';\nimport { getEveryNth } from '../util/getEveryNth';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  // If the ticks are readonly, then the slice might not be necessary\n  var result = (ticks || []).slice();\n  var {\n    start: initialStart,\n    end\n  } = boundaries;\n  var index = 0;\n  // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n  var stepsize = 1;\n  var start = initialStart;\n  var _loop = function _loop() {\n      // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n      // If it can not, then increase the stepsize by 1, and try again.\n\n      var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n\n      // Break condition - If we have evaluated all the ticks, then we are done.\n      if (entry === undefined) {\n        return {\n          v: getEveryNth(ticks, stepsize)\n        };\n      }\n\n      // Check if the element collides with the next element\n      var i = index;\n      var size;\n      var getSize = () => {\n        if (size === undefined) {\n          size = getTickSize(entry, i);\n        }\n        return size;\n      };\n      var tickCoord = entry.coordinate;\n      // We will always show the first tick.\n      var isShow = index === 0 || isVisible(sign, tickCoord, getSize, start, end);\n      if (!isShow) {\n        // Start all over with a larger stepsize\n        index = 0;\n        start = initialStart;\n        stepsize += 1;\n      }\n      if (isShow) {\n        // If it can be shown, update the start\n        start = tickCoord + sign * (getSize() / 2 + minTickGap);\n        index += stepsize;\n      }\n    },\n    _ret;\n  while (stepsize <= result.length) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n  return [];\n}\nexport function getEquidistantPreserveEndTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  // If the ticks are readonly, then the slice might not be necessary\n  // Reworked logic for getEquidistantPreserveEndTicks\n  var result = (ticks || []).slice();\n  var len = result.length;\n  if (len === 0) {\n    return [];\n  }\n  var {\n    start: initialStart,\n    end\n  } = boundaries;\n\n  // Start with stepsize = 1 (every tick) up to the maximum possible stepsize (len)\n  for (var stepsize = 1; stepsize <= len; stepsize++) {\n    // 1. Calculate the offset so the last tick (index len - 1) is always included in the sequence.\n    var offset = (len - 1) % stepsize;\n    var start = initialStart; // `start` tracks the coordinate of the last successfully drawn tick + gap\n    var ok = true;\n\n    // 2. Iterate through the end-anchored sequence: offset, offset + stepsize, ..., len - 1\n    var _loop2 = function _loop2() {\n        var entry = ticks[index];\n        if (entry == null) {\n          return 0; // continue\n        }\n        var i = index;\n        var size;\n\n        // Use a function to get size, as in the original code\n        var getSize = () => {\n          if (size === undefined) {\n            size = getTickSize(entry, i);\n          }\n          return size;\n        };\n        var tickCoord = entry.coordinate;\n\n        // 3. Apply visibility logic (including the first tick special case)\n        // The reviewer says *not* to unconditionally bypass checks for the last tick.\n        var isShow = index === offset || isVisible(sign, tickCoord, getSize, start, end);\n        if (!isShow) {\n          // If any tick in this end-anchored sequence fails visibility/collision,\n          // reject this stepsize and move to the next iteration (larger stepsize).\n          ok = false;\n          return 1; // break\n        }\n\n        // 4. If showable, update the 'start' coordinate for the next collision check\n        if (isShow) {\n          start = tickCoord + sign * (getSize() / 2 + minTickGap);\n        }\n      },\n      _ret2;\n    for (var index = offset; index < len; index += stepsize) {\n      _ret2 = _loop2();\n      if (_ret2 === 0) continue;\n      if (_ret2 === 1) break;\n    }\n\n    // 5. If the entire sequence for this stepsize passed the visibility check, return the result\n    if (ok) {\n      // Build the final result array explicitly using the validated stepsize and offset.\n      var finalTicks = [];\n      for (var _index = offset; _index < len; _index += stepsize) {\n        var tick = ticks[_index];\n        if (tick != null) {\n          finalTicks.push(tick);\n        }\n      }\n      return finalTicks;\n    }\n  }\n\n  // If no stepsize works (this shouldn't happen unless minTickGap is huge), return an empty array.\n  return [];\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}