{"ast":null,"code":"// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\"); // src/utils/errors.ts\n\nvar errors = process.env.NODE_ENV !== \"production\" ? [// All error codes, starting by 0:\nfunction (plugin) {\n  return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n}, function (thing) {\n  return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n}, \"This object has been frozen and should not be mutated\", function (data) {\n  return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n}, \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\", \"Immer forbids circular references\", \"The first or second argument to `produce` must be a function\", \"The third argument to `produce` must be a function or undefined\", \"First argument to `createDraft` must be a plain object, an array, or an immerable object\", \"First argument to `finishDraft` must be a draft returned by `createDraft`\", function (thing) {\n  return `'current' expects a draft, got: ${thing}`;\n}, \"Object.defineProperty() cannot be used on an Immer draft\", \"Object.setPrototypeOf() cannot be used on an Immer draft\", \"Immer only supports deleting array indices\", \"Immer only supports setting array indices and the 'length' property\", function (thing) {\n  return `'original' expects a draft, got: ${thing}`;\n} // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n// See Patches.ts for additional errors\n] : [];\n\nfunction die(error) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const e = errors[error];\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    const msg = isFunction(e) ? e.apply(null, args) : e;\n    throw new Error(`[Immer] ${msg}`);\n  }\n\n  throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);\n} // src/utils/common.ts\n\n\nvar O = Object;\nvar getPrototypeOf = O.getPrototypeOf;\nvar CONSTRUCTOR = \"constructor\";\nvar PROTOTYPE = \"prototype\";\nvar CONFIGURABLE = \"configurable\";\nvar ENUMERABLE = \"enumerable\";\nvar WRITABLE = \"writable\";\nvar VALUE = \"value\";\n\nvar isDraft = value => !!value && !!value[DRAFT_STATE];\n\nfunction isDraftable(value) {\n  if (!value) return false;\n  return isPlainObject(value) || isArray(value) || !!value[DRAFTABLE] || !!value[CONSTRUCTOR]?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\n\nvar objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString();\nvar cachedCtorStrings = /* @__PURE__ */new WeakMap();\n\nfunction isPlainObject(value) {\n  if (!value || !isObjectish(value)) return false;\n  const proto = getPrototypeOf(value);\n  if (proto === null || proto === O[PROTOTYPE]) return true;\n  const Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR];\n  if (Ctor === Object) return true;\n  if (!isFunction(Ctor)) return false;\n  let ctorString = cachedCtorStrings.get(Ctor);\n\n  if (ctorString === void 0) {\n    ctorString = Function.toString.call(Ctor);\n    cachedCtorStrings.set(Ctor, ctorString);\n  }\n\n  return ctorString === objectCtorString;\n}\n\nfunction original(value) {\n  if (!isDraft(value)) die(15, value);\n  return value[DRAFT_STATE].base_;\n}\n\nfunction each(obj, iter) {\n  let strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (getArchtype(obj) === 0\n  /* Object */\n  ) {\n    const keys = strict ? Reflect.ownKeys(obj) : O.keys(obj);\n    keys.forEach(key => {\n      iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach((entry, index) => iter(index, entry, obj));\n  }\n}\n\nfunction getArchtype(thing) {\n  const state = thing[DRAFT_STATE];\n  return state ? state.type_ : isArray(thing) ? 1\n  /* Array */\n  : isMap(thing) ? 2\n  /* Map */\n  : isSet(thing) ? 3\n  /* Set */\n  : 0\n  /* Object */\n  ;\n}\n\nvar has = function (thing, prop) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getArchtype(thing);\n  return type === 2\n  /* Map */\n  ? thing.has(prop) : O[PROTOTYPE].hasOwnProperty.call(thing, prop);\n};\n\nvar get = function (thing, prop) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getArchtype(thing);\n  return (// @ts-ignore\n    type === 2\n    /* Map */\n    ? thing.get(prop) : thing[prop]\n  );\n};\n\nvar set = function (thing, propOrOldValue, value) {\n  let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getArchtype(thing);\n  if (type === 2\n  /* Map */\n  ) thing.set(propOrOldValue, value);else if (type === 3\n  /* Set */\n  ) {\n    thing.add(value);\n  } else thing[propOrOldValue] = value;\n};\n\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nvar isArray = Array.isArray;\n\nvar isMap = target => target instanceof Map;\n\nvar isSet = target => target instanceof Set;\n\nvar isObjectish = target => typeof target === \"object\";\n\nvar isFunction = target => typeof target === \"function\";\n\nvar isBoolean = target => typeof target === \"boolean\";\n\nfunction isArrayIndex(value) {\n  const n = +value;\n  return Number.isInteger(n) && String(n) === value;\n}\n\nvar getProxyDraft = value => {\n  if (!isObjectish(value)) return null;\n  return value?.[DRAFT_STATE];\n};\n\nvar latest = state => state.copy_ || state.base_;\n\nvar getValue = value => {\n  const proxyDraft = getProxyDraft(value);\n  return proxyDraft ? proxyDraft.copy_ ?? proxyDraft.base_ : value;\n};\n\nvar getFinalValue = state => state.modified_ ? state.copy_ : state.base_;\n\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n\n  if (isSet(base)) {\n    return new Set(base);\n  }\n\n  if (isArray(base)) return Array[PROTOTYPE].slice.call(base);\n  const isPlain = isPlainObject(base);\n\n  if (strict === true || strict === \"class_only\" && !isPlain) {\n    const descriptors = O.getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    let keys = Reflect.ownKeys(descriptors);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const desc = descriptors[key];\n\n      if (desc[WRITABLE] === false) {\n        desc[WRITABLE] = true;\n        desc[CONFIGURABLE] = true;\n      }\n\n      if (desc.get || desc.set) descriptors[key] = {\n        [CONFIGURABLE]: true,\n        [WRITABLE]: true,\n        // could live with !!desc.set as well here...\n        [ENUMERABLE]: desc[ENUMERABLE],\n        [VALUE]: base[key]\n      };\n    }\n\n    return O.create(getPrototypeOf(base), descriptors);\n  } else {\n    const proto = getPrototypeOf(base);\n\n    if (proto !== null && isPlain) {\n      return { ...base\n      };\n    }\n\n    const obj = O.create(proto);\n    return O.assign(obj, base);\n  }\n}\n\nfunction freeze(obj) {\n  let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n\n  if (getArchtype(obj) > 1) {\n    O.defineProperties(obj, {\n      set: dontMutateMethodOverride,\n      add: dontMutateMethodOverride,\n      clear: dontMutateMethodOverride,\n      delete: dontMutateMethodOverride\n    });\n  }\n\n  O.freeze(obj);\n  if (deep) each(obj, (_key, value) => {\n    freeze(value, true);\n  }, false);\n  return obj;\n}\n\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\n\nvar dontMutateMethodOverride = {\n  [VALUE]: dontMutateFrozenCollections\n};\n\nfunction isFrozen(obj) {\n  if (obj === null || !isObjectish(obj)) return true;\n  return O.isFrozen(obj);\n} // src/utils/plugins.ts\n\n\nvar PluginMapSet = \"MapSet\";\nvar PluginPatches = \"Patches\";\nvar PluginArrayMethods = \"ArrayMethods\";\nvar plugins = {};\n\nfunction getPlugin(pluginKey) {\n  const plugin = plugins[pluginKey];\n\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n\n  return plugin;\n}\n\nvar isPluginLoaded = pluginKey => !!plugins[pluginKey];\n\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n} // src/core/scope.ts\n\n\nvar currentScope;\n\nvar getCurrentScope = () => currentScope;\n\nvar createScope = (parent_, immer_) => ({\n  drafts_: [],\n  parent_,\n  immer_,\n  // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n  canAutoFreeze_: true,\n  unfinalizedDrafts_: 0,\n  handledSet_: /* @__PURE__ */new Set(),\n  processedForPatches_: /* @__PURE__ */new Set(),\n  mapSetPlugin_: isPluginLoaded(PluginMapSet) ? getPlugin(PluginMapSet) : void 0,\n  arrayMethodsPlugin_: isPluginLoaded(PluginArrayMethods) ? getPlugin(PluginArrayMethods) : void 0\n});\n\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    scope.patchPlugin_ = getPlugin(PluginPatches);\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\n\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\n\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\n\nvar enterScope = immer2 => currentScope = createScope(currentScope, immer2);\n\nfunction revokeDraft(draft) {\n  const state = draft[DRAFT_STATE];\n  if (state.type_ === 0\n  /* Object */\n  || state.type_ === 1\n  /* Array */\n  ) state.revoke_();else state.revoked_ = true;\n} // src/core/finalize.ts\n\n\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  const baseDraft = scope.drafts_[0];\n  const isReplaced = result !== void 0 && result !== baseDraft;\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n    }\n\n    const {\n      patchPlugin_\n    } = scope;\n\n    if (patchPlugin_) {\n      patchPlugin_.generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope);\n    }\n  } else {\n    result = finalize(scope, baseDraft);\n  }\n\n  maybeFreeze(scope, result, true);\n  revokeScope(scope);\n\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n\n  return result !== NOTHING ? result : void 0;\n}\n\nfunction finalize(rootScope, value) {\n  if (isFrozen(value)) return value;\n  const state = value[DRAFT_STATE];\n\n  if (!state) {\n    const finalValue = handleValue(value, rootScope.handledSet_, rootScope);\n    return finalValue;\n  }\n\n  if (!isSameScope(state, rootScope)) {\n    return value;\n  }\n\n  if (!state.modified_) {\n    return state.base_;\n  }\n\n  if (!state.finalized_) {\n    const {\n      callbacks_\n    } = state;\n\n    if (callbacks_) {\n      while (callbacks_.length > 0) {\n        const callback = callbacks_.pop();\n        callback(rootScope);\n      }\n    }\n\n    generatePatchesAndFinalize(state, rootScope);\n  }\n\n  return state.copy_;\n}\n\nfunction maybeFreeze(scope, value) {\n  let deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\nfunction markStateFinalized(state) {\n  state.finalized_ = true;\n  state.scope_.unfinalizedDrafts_--;\n}\n\nvar isSameScope = (state, rootScope) => state.scope_ === rootScope;\n\nvar EMPTY_LOCATIONS_RESULT = [];\n\nfunction updateDraftInParent(parent, draftValue, finalizedValue, originalKey) {\n  const parentCopy = latest(parent);\n  const parentType = parent.type_;\n\n  if (originalKey !== void 0) {\n    const currentValue = get(parentCopy, originalKey, parentType);\n\n    if (currentValue === draftValue) {\n      set(parentCopy, originalKey, finalizedValue, parentType);\n      return;\n    }\n  }\n\n  if (!parent.draftLocations_) {\n    const draftLocations = parent.draftLocations_ = /* @__PURE__ */new Map();\n    each(parentCopy, (key, value) => {\n      if (isDraft(value)) {\n        const keys = draftLocations.get(value) || [];\n        keys.push(key);\n        draftLocations.set(value, keys);\n      }\n    });\n  }\n\n  const locations = parent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT;\n\n  for (const location of locations) {\n    set(parentCopy, location, finalizedValue, parentType);\n  }\n}\n\nfunction registerChildFinalizationCallback(parent, child, key) {\n  parent.callbacks_.push(function childCleanup(rootScope) {\n    const state = child;\n\n    if (!state || !isSameScope(state, rootScope)) {\n      return;\n    }\n\n    rootScope.mapSetPlugin_?.fixSetContents(state);\n    const finalizedValue = getFinalValue(state);\n    updateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key);\n    generatePatchesAndFinalize(state, rootScope);\n  });\n}\n\nfunction generatePatchesAndFinalize(state, rootScope) {\n  const shouldFinalize = state.modified_ && !state.finalized_ && (state.type_ === 3\n  /* Set */\n  || state.type_ === 1\n  /* Array */\n  && state.allIndicesReassigned_ || (state.assigned_?.size ?? 0) > 0);\n\n  if (shouldFinalize) {\n    const {\n      patchPlugin_\n    } = rootScope;\n\n    if (patchPlugin_) {\n      const basePath = patchPlugin_.getPath(state);\n\n      if (basePath) {\n        patchPlugin_.generatePatches_(state, basePath, rootScope);\n      }\n    }\n\n    markStateFinalized(state);\n  }\n}\n\nfunction handleCrossReference(target, key, value) {\n  const {\n    scope_\n  } = target;\n\n  if (isDraft(value)) {\n    const state = value[DRAFT_STATE];\n\n    if (isSameScope(state, scope_)) {\n      state.callbacks_.push(function crossReferenceCleanup() {\n        prepareCopy(target);\n        const finalizedValue = getFinalValue(state);\n        updateDraftInParent(target, value, finalizedValue, key);\n      });\n    }\n  } else if (isDraftable(value)) {\n    target.callbacks_.push(function nestedDraftCleanup() {\n      const targetCopy = latest(target);\n\n      if (target.type_ === 3\n      /* Set */\n      ) {\n        if (targetCopy.has(value)) {\n          handleValue(value, scope_.handledSet_, scope_);\n        }\n      } else {\n        if (get(targetCopy, key, target.type_) === value) {\n          if (scope_.drafts_.length > 1 && (target.assigned_.get(key) ?? false) === true && target.copy_) {\n            handleValue(get(target.copy_, key, target.type_), scope_.handledSet_, scope_);\n          }\n        }\n      }\n    });\n  }\n}\n\nfunction handleValue(target, handledSet, rootScope) {\n  if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n    return target;\n  }\n\n  if (isDraft(target) || handledSet.has(target) || !isDraftable(target) || isFrozen(target)) {\n    return target;\n  }\n\n  handledSet.add(target);\n  each(target, (key, value) => {\n    if (isDraft(value)) {\n      const state = value[DRAFT_STATE];\n\n      if (isSameScope(state, rootScope)) {\n        const updatedValue = getFinalValue(state);\n        set(target, key, updatedValue, target.type_);\n        markStateFinalized(state);\n      }\n    } else if (isDraftable(value)) {\n      handleValue(value, handledSet, rootScope);\n    }\n  });\n  return target;\n} // src/core/proxy.ts\n\n\nfunction createProxyProxy(base, parent) {\n  const baseIsArray = isArray(base);\n  const state = {\n    type_: baseIsArray ? 1\n    /* Array */\n    : 0\n    /* Object */\n    ,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    // actually instantiated in `prepareCopy()`\n    assigned_: void 0,\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false,\n    // `callbacks` actually gets assigned in `createProxy`\n    callbacks_: void 0\n  };\n  let target = state;\n  let traps = objectTraps;\n\n  if (baseIsArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n\n  const {\n    revoke,\n    proxy\n  } = Proxy.revocable(target, traps);\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return [proxy, state];\n}\n\nvar objectTraps = {\n  get(state, prop) {\n    if (prop === DRAFT_STATE) return state;\n    let arrayPlugin = state.scope_.arrayMethodsPlugin_;\n    const isArrayWithStringProp = state.type_ === 1\n    /* Array */\n    && typeof prop === \"string\";\n\n    if (isArrayWithStringProp) {\n      if (arrayPlugin?.isArrayOperationMethod(prop)) {\n        return arrayPlugin.createMethodInterceptor(state, prop);\n      }\n    }\n\n    const source = latest(state);\n\n    if (!has(source, prop, state.type_)) {\n      return readPropFromProto(state, source, prop);\n    }\n\n    const value = source[prop];\n\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n\n    if (isArrayWithStringProp && state.operationMethod && arrayPlugin?.isMutatingArrayMethod(state.operationMethod) && isArrayIndex(prop)) {\n      return value;\n    }\n\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      const childKey = state.type_ === 1\n      /* Array */\n      ? +prop : prop;\n      const childDraft = createProxy(state.scope_, value, state, childKey);\n      return state.copy_[childKey] = childDraft;\n    }\n\n    return value;\n  },\n\n  has(state, prop) {\n    return prop in latest(state);\n  },\n\n  ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n\n  set(state, prop, value) {\n    const desc = getDescriptorFromProto(latest(state), prop);\n\n    if (desc?.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n\n    if (!state.modified_) {\n      const current2 = peek(latest(state), prop);\n      const currentState = current2?.[DRAFT_STATE];\n\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_.set(prop, false);\n        return true;\n      }\n\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop, state.type_))) return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n\n    if (state.copy_[prop] === value && ( // special case: handle new props with value 'undefined'\n    value !== void 0 || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;\n    state.copy_[prop] = value;\n    state.assigned_.set(prop, true);\n    handleCrossReference(state, prop, value);\n    return true;\n  },\n\n  deleteProperty(state, prop) {\n    prepareCopy(state);\n\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_.set(prop, false);\n      markChanged(state);\n    } else {\n      state.assigned_.delete(prop);\n    }\n\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n\n    return true;\n  },\n\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor(state, prop) {\n    const owner = latest(state);\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc) return desc;\n    return {\n      [WRITABLE]: true,\n      [CONFIGURABLE]: state.type_ !== 1\n      /* Array */\n      || prop !== \"length\",\n      [ENUMERABLE]: desc[ENUMERABLE],\n      [VALUE]: owner[prop]\n    };\n  },\n\n  defineProperty() {\n    die(11);\n  },\n\n  getPrototypeOf(state) {\n    return getPrototypeOf(state.base_);\n  },\n\n  setPrototypeOf() {\n    die(12);\n  }\n\n};\nvar arrayTraps = {};\n\nfor (let key in objectTraps) {\n  let fn = objectTraps[key];\n\n  arrayTraps[key] = function () {\n    const args = arguments;\n    args[0] = args[0][0];\n    return fn.apply(this, args);\n  };\n}\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop))) die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (process.env.NODE_ENV !== \"production\" && prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\n\nfunction peek(draft, prop) {\n  const state = draft[DRAFT_STATE];\n  const source = state ? latest(state) : draft;\n  return source[prop];\n}\n\nfunction readPropFromProto(state, source, prop) {\n  const desc = getDescriptorFromProto(source, prop);\n  return desc ? VALUE in desc ? desc[VALUE] : // This is a very special case, if the prop is a getter defined by the\n  // prototype, we should invoke it with the draft as context!\n  desc.get?.call(state.draft_) : void 0;\n}\n\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source)) return void 0;\n  let proto = getPrototypeOf(source);\n\n  while (proto) {\n    const desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc) return desc;\n    proto = getPrototypeOf(proto);\n  }\n\n  return void 0;\n}\n\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.assigned_ = /* @__PURE__ */new Map();\n    state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);\n  }\n} // src/core/immerClass.ts\n\n\nvar Immer2 = class {\n  constructor(config) {\n    var _this = this;\n\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    this.useStrictIteration_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n\n    this.produce = (base, recipe, patchListener) => {\n      if (isFunction(base) && !isFunction(recipe)) {\n        const defaultBase = recipe;\n        recipe = base;\n        const self = this;\n        return function curriedProduce() {\n          let base2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBase;\n\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {\n            args[_key3 - 1] = arguments[_key3];\n          }\n\n          return self.produce(base2, draft => recipe.call(this, draft, ...args));\n        };\n      }\n\n      if (!isFunction(recipe)) die(6);\n      if (patchListener !== void 0 && !isFunction(patchListener)) die(7);\n      let result;\n\n      if (isDraftable(base)) {\n        const scope = enterScope(this);\n        const proxy = createProxy(scope, base, void 0);\n        let hasError = true;\n\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError) revokeScope(scope);else leaveScope(scope);\n        }\n\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || !isObjectish(base)) {\n        result = recipe(base);\n        if (result === void 0) result = base;\n        if (result === NOTHING) result = void 0;\n        if (this.autoFreeze_) freeze(result, true);\n\n        if (patchListener) {\n          const p = [];\n          const ip = [];\n          getPlugin(PluginPatches).generateReplacementPatches_(base, result, {\n            patches_: p,\n            inversePatches_: ip\n          });\n          patchListener(p, ip);\n        }\n\n        return result;\n      } else die(1, base);\n    };\n\n    this.produceWithPatches = (base, recipe) => {\n      if (isFunction(base)) {\n        return function (state) {\n          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {\n            args[_key4 - 1] = arguments[_key4];\n          }\n\n          return _this.produceWithPatches(state, draft => base(draft, ...args));\n        };\n      }\n\n      let patches, inversePatches;\n      const result = this.produce(base, recipe, (p, ip) => {\n        patches = p;\n        inversePatches = ip;\n      });\n      return [result, patches, inversePatches];\n    };\n\n    if (isBoolean(config?.autoFreeze)) this.setAutoFreeze(config.autoFreeze);\n    if (isBoolean(config?.useStrictShallowCopy)) this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n    if (isBoolean(config?.useStrictIteration)) this.setUseStrictIteration(config.useStrictIteration);\n  }\n\n  createDraft(base) {\n    if (!isDraftable(base)) die(8);\n    if (isDraft(base)) base = current(base);\n    const scope = enterScope(this);\n    const proxy = createProxy(scope, base, void 0);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  }\n\n  finishDraft(draft, patchListener) {\n    const state = draft && draft[DRAFT_STATE];\n    if (!state || !state.isManual_) die(9);\n    const {\n      scope_: scope\n    } = state;\n    usePatchesInScope(scope, patchListener);\n    return processResult(void 0, scope);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n\n\n  setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */\n\n\n  setUseStrictShallowCopy(value) {\n    this.useStrictShallowCopy_ = value;\n  }\n  /**\n   * Pass false to use faster iteration that skips non-enumerable properties\n   * but still handles symbols for compatibility.\n   *\n   * By default, strict iteration is enabled (includes all own properties).\n   */\n\n\n  setUseStrictIteration(value) {\n    this.useStrictIteration_ = value;\n  }\n\n  shouldUseStrictIteration() {\n    return this.useStrictIteration_;\n  }\n\n  applyPatches(base, patches) {\n    let i;\n\n    for (i = patches.length - 1; i >= 0; i--) {\n      const patch = patches[i];\n\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n\n    const applyPatchesImpl = getPlugin(PluginPatches).applyPatches_;\n\n    if (isDraft(base)) {\n      return applyPatchesImpl(base, patches);\n    }\n\n    return this.produce(base, draft => applyPatchesImpl(draft, patches));\n  }\n\n};\n\nfunction createProxy(rootScope, value, parent, key) {\n  const [draft, state] = isMap(value) ? getPlugin(PluginMapSet).proxyMap_(value, parent) : isSet(value) ? getPlugin(PluginMapSet).proxySet_(value, parent) : createProxyProxy(value, parent);\n  const scope = parent?.scope_ ?? getCurrentScope();\n  scope.drafts_.push(draft);\n  state.callbacks_ = parent?.callbacks_ ?? [];\n  state.key_ = key;\n\n  if (parent && key !== void 0) {\n    registerChildFinalizationCallback(parent, state, key);\n  } else {\n    state.callbacks_.push(function rootDraftCleanup(rootScope2) {\n      rootScope2.mapSetPlugin_?.fixSetContents(state);\n      const {\n        patchPlugin_\n      } = rootScope2;\n\n      if (state.modified_ && patchPlugin_) {\n        patchPlugin_.generatePatches_(state, [], rootScope2);\n      }\n    });\n  }\n\n  return draft;\n} // src/core/current.ts\n\n\nfunction current(value) {\n  if (!isDraft(value)) die(10, value);\n  return currentImpl(value);\n}\n\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value)) return value;\n  const state = value[DRAFT_STATE];\n  let copy;\n  let strict = true;\n\n  if (state) {\n    if (!state.modified_) return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n    strict = state.scope_.immer_.shouldUseStrictIteration();\n  } else {\n    copy = shallowCopy(value, true);\n  }\n\n  each(copy, (key, childValue) => {\n    set(copy, key, currentImpl(childValue));\n  }, strict);\n\n  if (state) {\n    state.finalized_ = false;\n  }\n\n  return copy;\n} // src/plugins/patches.ts\n\n\nfunction enablePatches() {\n  const errorOffset = 16;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    errors.push('Sets cannot have \"replace\" patches.', function (op) {\n      return \"Unsupported patch operation: \" + op;\n    }, function (path) {\n      return \"Cannot apply patch, path doesn't resolve: \" + path;\n    }, \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\");\n  }\n\n  function getPath(state) {\n    let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (state.key_ !== void 0) {\n      const parentCopy = state.parent_.copy_ ?? state.parent_.base_;\n      const proxyDraft = getProxyDraft(get(parentCopy, state.key_));\n      const valueAtKey = get(parentCopy, state.key_);\n\n      if (valueAtKey === void 0) {\n        return null;\n      }\n\n      if (valueAtKey !== state.draft_ && valueAtKey !== state.base_ && valueAtKey !== state.copy_) {\n        return null;\n      }\n\n      if (proxyDraft != null && proxyDraft.base_ !== state.base_) {\n        return null;\n      }\n\n      const isSet2 = state.parent_.type_ === 3\n      /* Set */\n      ;\n      let key;\n\n      if (isSet2) {\n        const setParent = state.parent_;\n        key = Array.from(setParent.drafts_.keys()).indexOf(state.key_);\n      } else {\n        key = state.key_;\n      }\n\n      if (!(isSet2 && parentCopy.size > key || has(parentCopy, key))) {\n        return null;\n      }\n\n      path.push(key);\n    }\n\n    if (state.parent_) {\n      return getPath(state.parent_, path);\n    }\n\n    path.reverse();\n\n    try {\n      resolvePath(state.copy_, path);\n    } catch (e) {\n      return null;\n    }\n\n    return path;\n  }\n\n  function resolvePath(base, path) {\n    let current2 = base;\n\n    for (let i = 0; i < path.length - 1; i++) {\n      const key = path[i];\n      current2 = get(current2, key);\n\n      if (!isObjectish(current2) || current2 === null) {\n        throw new Error(`Cannot resolve path at '${path.join(\"/\")}'`);\n      }\n    }\n\n    return current2;\n  }\n\n  const REPLACE = \"replace\";\n  const ADD = \"add\";\n  const REMOVE = \"remove\";\n\n  function generatePatches_(state, basePath, scope) {\n    if (state.scope_.processedForPatches_.has(state)) {\n      return;\n    }\n\n    state.scope_.processedForPatches_.add(state);\n    const {\n      patches_,\n      inversePatches_\n    } = scope;\n\n    switch (state.type_) {\n      case 0\n      /* Object */\n      :\n      case 2\n      /* Map */\n      :\n        return generatePatchesFromAssigned(state, basePath, patches_, inversePatches_);\n\n      case 1\n      /* Array */\n      :\n        return generateArrayPatches(state, basePath, patches_, inversePatches_);\n\n      case 3\n      /* Set */\n      :\n        return generateSetPatches(state, basePath, patches_, inversePatches_);\n    }\n  }\n\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    let {\n      base_,\n      assigned_\n    } = state;\n    let copy_ = state.copy_;\n\n    if (copy_.length < base_.length) {\n      ;\n      [base_, copy_] = [copy_, base_];\n      [patches, inversePatches] = [inversePatches, patches];\n    }\n\n    const allReassigned = state.allIndicesReassigned_ === true;\n\n    for (let i = 0; i < base_.length; i++) {\n      const copiedItem = copy_[i];\n      const baseItem = base_[i];\n      const isAssigned = allReassigned || assigned_?.get(i.toString());\n\n      if (isAssigned && copiedItem !== baseItem) {\n        const childState = copiedItem?.[DRAFT_STATE];\n\n        if (childState && childState.modified_) {\n          continue;\n        }\n\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copiedItem)\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path,\n          value: clonePatchValueIfNeeded(baseItem)\n        });\n      }\n    }\n\n    for (let i = base_.length; i < copy_.length; i++) {\n      const path = basePath.concat([i]);\n      patches.push({\n        op: ADD,\n        path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[i])\n      });\n    }\n\n    for (let i = copy_.length - 1; base_.length <= i; --i) {\n      const path = basePath.concat([i]);\n      inversePatches.push({\n        op: REMOVE,\n        path\n      });\n    }\n  }\n\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    const {\n      base_,\n      copy_,\n      type_\n    } = state;\n    each(state.assigned_, (key, assignedValue) => {\n      const origValue = get(base_, key, type_);\n      const value = get(copy_, key, type_);\n      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE) return;\n      const path = basePath.concat(key);\n      patches.push(op === REMOVE ? {\n        op,\n        path\n      } : {\n        op,\n        path,\n        value: clonePatchValueIfNeeded(value)\n      });\n      inversePatches.push(op === ADD ? {\n        op: REMOVE,\n        path\n      } : op === REMOVE ? {\n        op: ADD,\n        path,\n        value: clonePatchValueIfNeeded(origValue)\n      } : {\n        op: REPLACE,\n        path,\n        value: clonePatchValueIfNeeded(origValue)\n      });\n    });\n  }\n\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    let {\n      base_,\n      copy_\n    } = state;\n    let i = 0;\n    base_.forEach(value => {\n      if (!copy_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path,\n          value\n        });\n      }\n\n      i++;\n    });\n    i = 0;\n    copy_.forEach(value => {\n      if (!base_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path,\n          value\n        });\n      }\n\n      i++;\n    });\n  }\n\n  function generateReplacementPatches_(baseValue, replacement, scope) {\n    const {\n      patches_,\n      inversePatches_\n    } = scope;\n    patches_.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches_.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n\n  function applyPatches_(draft, patches) {\n    patches.forEach(patch => {\n      const {\n        path,\n        op\n      } = patch;\n      let base = draft;\n\n      for (let i = 0; i < path.length - 1; i++) {\n        const parentType = getArchtype(base);\n        let p = path[i];\n\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n\n        if ((parentType === 0\n        /* Object */\n        || parentType === 1\n        /* Array */\n        ) && (p === \"__proto__\" || p === CONSTRUCTOR)) die(errorOffset + 3);\n        if (isFunction(base) && p === PROTOTYPE) die(errorOffset + 3);\n        base = get(base, p);\n        if (!isObjectish(base)) die(errorOffset + 2, path.join(\"/\"));\n      }\n\n      const type = getArchtype(base);\n      const value = deepClonePatchValue(patch.value);\n      const key = path[path.length - 1];\n\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            case 3\n            /* Set */\n            :\n              die(errorOffset);\n\n            default:\n              return base[key] = value;\n          }\n\n        case ADD:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            case 3\n            /* Set */\n            :\n              return base.add(value);\n\n            default:\n              return base[key] = value;\n          }\n\n        case REMOVE:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return base.splice(key, 1);\n\n            case 2\n            /* Map */\n            :\n              return base.delete(key);\n\n            case 3\n            /* Set */\n            :\n              return base.delete(patch.value);\n\n            default:\n              return delete base[key];\n          }\n\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj)) return obj;\n    if (isArray(obj)) return obj.map(deepClonePatchValue);\n    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(_ref => {\n      let [k, v] = _ref;\n      return [k, deepClonePatchValue(v)];\n    }));\n    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n    const cloned = Object.create(getPrototypeOf(obj));\n\n    for (const key in obj) cloned[key] = deepClonePatchValue(obj[key]);\n\n    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else return obj;\n  }\n\n  loadPlugin(PluginPatches, {\n    applyPatches_,\n    generatePatches_,\n    generateReplacementPatches_,\n    getPath\n  });\n} // src/plugins/mapset.ts\n\n\nfunction enableMapSet() {\n  class DraftMap extends Map {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 2\n        /* Map */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false,\n        callbacks_: []\n      };\n    }\n\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n\n    has(key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    }\n\n    set(key, value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n        handleCrossReference(state, key, value);\n      }\n\n      return this;\n    }\n\n    delete(key) {\n      if (!this.has(key)) {\n        return false;\n      }\n\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n\n      state.copy_.delete(key);\n      return true;\n    }\n\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = /* @__PURE__ */new Map();\n        each(state.base_, key => {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    }\n\n    forEach(cb, thisArg) {\n      const state = this[DRAFT_STATE];\n      latest(state).forEach((_value, key, _map) => {\n        cb.call(thisArg, this.get(key), key, this);\n      });\n    }\n\n    get(key) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      const value = latest(state).get(key);\n\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n\n      if (value !== state.base_.get(key)) {\n        return value;\n      }\n\n      const draft = createProxy(state.scope_, value, state, key);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    }\n\n    keys() {\n      return latest(this[DRAFT_STATE]).keys();\n    }\n\n    values() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.values(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done) return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value\n          };\n        }\n      };\n    }\n\n    entries() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.entries(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done) return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value: [r.value, value]\n          };\n        }\n      };\n    }\n\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.entries();\n    }\n\n  }\n\n  function proxyMap_(target, parent) {\n    const map = new DraftMap(target, parent);\n    return [map, map[DRAFT_STATE]];\n  }\n\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n\n  class DraftSet extends Set {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 3\n        /* Set */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: this,\n        drafts_: /* @__PURE__ */new Map(),\n        revoked_: false,\n        isManual_: false,\n        assigned_: void 0,\n        callbacks_: []\n      };\n    }\n\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n\n    has(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n\n      if (state.copy_.has(value)) return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n      return false;\n    }\n\n    add(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n        handleCrossReference(state, value, value);\n      }\n\n      return this;\n    }\n\n    delete(value) {\n      if (!this.has(value)) {\n        return false;\n      }\n\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :\n      /* istanbul ignore next */\n      false);\n    }\n\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    }\n\n    values() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    }\n\n    entries() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    }\n\n    keys() {\n      return this.values();\n    }\n\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.values();\n    }\n\n    forEach(cb, thisArg) {\n      const iterator = this.values();\n      let result = iterator.next();\n\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    }\n\n  }\n\n  function proxySet_(target, parent) {\n    const set2 = new DraftSet(target, parent);\n    return [set2, set2[DRAFT_STATE]];\n  }\n\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */new Set();\n      state.base_.forEach(value => {\n        if (isDraftable(value)) {\n          const draft = createProxy(state.scope_, value, state, value);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n\n  function assertUnrevoked(state) {\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\n  }\n\n  function fixSetContents(target) {\n    if (target.type_ === 3\n    /* Set */\n    && target.copy_) {\n      const copy = new Set(target.copy_);\n      target.copy_.clear();\n      copy.forEach(value => {\n        target.copy_.add(getValue(value));\n      });\n    }\n  }\n\n  loadPlugin(PluginMapSet, {\n    proxyMap_,\n    proxySet_,\n    fixSetContents\n  });\n} // src/plugins/arrayMethods.ts\n\n\nfunction enableArrayMethods() {\n  const SHIFTING_METHODS = /* @__PURE__ */new Set([\"shift\", \"unshift\"]);\n  const QUEUE_METHODS = /* @__PURE__ */new Set([\"push\", \"pop\"]);\n  const RESULT_RETURNING_METHODS = /* @__PURE__ */new Set([...QUEUE_METHODS, ...SHIFTING_METHODS]);\n  const REORDERING_METHODS = /* @__PURE__ */new Set([\"reverse\", \"sort\"]);\n  const MUTATING_METHODS = /* @__PURE__ */new Set([...RESULT_RETURNING_METHODS, ...REORDERING_METHODS, \"splice\"]);\n  const FIND_METHODS = /* @__PURE__ */new Set([\"find\", \"findLast\"]);\n  const NON_MUTATING_METHODS = /* @__PURE__ */new Set([\"filter\", \"slice\", \"concat\", \"flat\", ...FIND_METHODS, \"findIndex\", \"findLastIndex\", \"some\", \"every\", \"indexOf\", \"lastIndexOf\", \"includes\", \"join\", \"toString\", \"toLocaleString\"]);\n\n  function isMutatingArrayMethod(method) {\n    return MUTATING_METHODS.has(method);\n  }\n\n  function isNonMutatingArrayMethod(method) {\n    return NON_MUTATING_METHODS.has(method);\n  }\n\n  function isArrayOperationMethod(method) {\n    return isMutatingArrayMethod(method) || isNonMutatingArrayMethod(method);\n  }\n\n  function enterOperation(state, method) {\n    state.operationMethod = method;\n  }\n\n  function exitOperation(state) {\n    state.operationMethod = void 0;\n  }\n\n  function executeArrayMethod(state, operation) {\n    let markLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    prepareCopy(state);\n    const result = operation();\n    markChanged(state);\n    if (markLength) state.assigned_.set(\"length\", true);\n    return result;\n  }\n\n  function markAllIndicesReassigned(state) {\n    state.allIndicesReassigned_ = true;\n  }\n\n  function normalizeSliceIndex(index, length) {\n    if (index < 0) {\n      return Math.max(length + index, 0);\n    }\n\n    return Math.min(index, length);\n  }\n\n  function handleInsertedValues(state, startIndex, values) {\n    for (let i = 0; i < values.length; i++) {\n      const index = startIndex + i;\n      state.assigned_.set(index, true);\n      handleCrossReference(state, index, values[i]);\n    }\n  }\n\n  function handleSimpleOperation(state, method, args) {\n    return executeArrayMethod(state, () => {\n      const lengthBefore = state.copy_.length;\n      const result = state.copy_[method](...args);\n\n      if (SHIFTING_METHODS.has(method)) {\n        markAllIndicesReassigned(state);\n      }\n\n      if (method === \"push\" && args.length > 0) {\n        handleInsertedValues(state, lengthBefore, args);\n      } else if (method === \"unshift\" && args.length > 0) {\n        handleInsertedValues(state, 0, args);\n      }\n\n      return RESULT_RETURNING_METHODS.has(method) ? result : state.draft_;\n    });\n  }\n\n  function handleReorderingOperation(state, method, args) {\n    return executeArrayMethod(state, () => {\n      ;\n      state.copy_[method](...args);\n      markAllIndicesReassigned(state);\n      return state.draft_;\n    }, false);\n  }\n\n  function createMethodInterceptor(state, originalMethod) {\n    return function interceptedMethod() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      const method = originalMethod;\n      enterOperation(state, method);\n\n      try {\n        if (isMutatingArrayMethod(method)) {\n          if (RESULT_RETURNING_METHODS.has(method)) {\n            return handleSimpleOperation(state, method, args);\n          }\n\n          if (REORDERING_METHODS.has(method)) {\n            return handleReorderingOperation(state, method, args);\n          }\n\n          if (method === \"splice\") {\n            const res = executeArrayMethod(state, () => state.copy_.splice(...args));\n            markAllIndicesReassigned(state);\n\n            if (args.length > 2) {\n              const startIndex = normalizeSliceIndex(args[0] ?? 0, state.copy_.length);\n              handleInsertedValues(state, startIndex, args.slice(2));\n            }\n\n            return res;\n          }\n        } else {\n          return handleNonMutatingOperation(state, method, args);\n        }\n      } finally {\n        exitOperation(state);\n      }\n    };\n  }\n\n  function handleNonMutatingOperation(state, method, args) {\n    const source = latest(state);\n\n    if (method === \"filter\") {\n      const predicate = args[0];\n      const result = [];\n\n      for (let i = 0; i < source.length; i++) {\n        if (predicate(source[i], i, source)) {\n          result.push(state.draft_[i]);\n        }\n      }\n\n      return result;\n    }\n\n    if (FIND_METHODS.has(method)) {\n      const predicate = args[0];\n      const isForward = method === \"find\";\n      const step = isForward ? 1 : -1;\n      const start = isForward ? 0 : source.length - 1;\n\n      for (let i = start; i >= 0 && i < source.length; i += step) {\n        if (predicate(source[i], i, source)) {\n          return state.draft_[i];\n        }\n      }\n\n      return void 0;\n    }\n\n    if (method === \"slice\") {\n      const rawStart = args[0] ?? 0;\n      const rawEnd = args[1] ?? source.length;\n      const start = normalizeSliceIndex(rawStart, source.length);\n      const end = normalizeSliceIndex(rawEnd, source.length);\n      const result = [];\n\n      for (let i = start; i < end; i++) {\n        result.push(state.draft_[i]);\n      }\n\n      return result;\n    }\n\n    return source[method](...args);\n  }\n\n  loadPlugin(PluginArrayMethods, {\n    createMethodInterceptor,\n    isArrayOperationMethod,\n    isMutatingArrayMethod\n  });\n} // src/immer.ts\n\n\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = /* @__PURE__ */immer.produceWithPatches.bind(immer);\nvar setAutoFreeze = /* @__PURE__ */immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = /* @__PURE__ */immer.setUseStrictShallowCopy.bind(immer);\nvar setUseStrictIteration = /* @__PURE__ */immer.setUseStrictIteration.bind(immer);\nvar applyPatches = /* @__PURE__ */immer.applyPatches.bind(immer);\nvar createDraft = /* @__PURE__ */immer.createDraft.bind(immer);\nvar finishDraft = /* @__PURE__ */immer.finishDraft.bind(immer);\n\nvar castDraft = value => value;\n\nvar castImmutable = value => value;\n\nexport { Immer2 as Immer, applyPatches, castDraft, castImmutable, createDraft, current, enableArrayMethods, enableMapSet, enablePatches, finishDraft, freeze, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseStrictIteration, setUseStrictShallowCopy };","map":{"version":3,"mappings":"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","names":["NOTHING","Symbol","for","DRAFTABLE","DRAFT_STATE","errors","process","env","NODE_ENV","plugin","thing","data","die","error","e","args","msg","isFunction","apply","Error","O","Object","getPrototypeOf","CONSTRUCTOR","PROTOTYPE","CONFIGURABLE","ENUMERABLE","WRITABLE","VALUE","isDraft","value","isDraftable","isPlainObject","isArray","isMap","isSet","objectCtorString","toString","cachedCtorStrings","WeakMap","isObjectish","proto","Ctor","hasOwnProperty","call","ctorString","get","Function","set","original","base_","each","obj","iter","strict","getArchtype","keys","Reflect","ownKeys","forEach","key","entry","index","state","type_","has","prop","type","propOrOldValue","add","is","x","y","Array","target","Map","Set","isBoolean","isArrayIndex","n","Number","isInteger","String","getProxyDraft","latest","copy_","getValue","proxyDraft","getFinalValue","modified_","shallowCopy","base","slice","isPlain","descriptors","getOwnPropertyDescriptors","i","length","desc","create","assign","freeze","deep","isFrozen","defineProperties","dontMutateMethodOverride","clear","delete","_key","dontMutateFrozenCollections","PluginMapSet","PluginPatches","PluginArrayMethods","plugins","getPlugin","pluginKey","isPluginLoaded","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","handledSet_","processedForPatches_","mapSetPlugin_","arrayMethodsPlugin_","usePatchesInScope","scope","patchListener","patchPlugin_","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","finalize","generateReplacementPatches_","maybeFreeze","rootScope","finalValue","handleValue","isSameScope","finalized_","callbacks_","callback","pop","generatePatchesAndFinalize","autoFreeze_","markStateFinalized","scope_","EMPTY_LOCATIONS_RESULT","updateDraftInParent","parent","draftValue","finalizedValue","originalKey","parentCopy","parentType","currentValue","draftLocations_","draftLocations","push","locations","location","registerChildFinalizationCallback","child","childCleanup","fixSetContents","draft_","shouldFinalize","allIndicesReassigned_","assigned_","size","basePath","getPath","generatePatches_","handleCrossReference","crossReferenceCleanup","prepareCopy","nestedDraftCleanup","targetCopy","handledSet","updatedValue","createProxyProxy","baseIsArray","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","Proxy","revocable","arrayPlugin","isArrayWithStringProp","isArrayOperationMethod","createMethodInterceptor","source","readPropFromProto","operationMethod","isMutatingArrayMethod","peek","childKey","childDraft","createProxy","getDescriptorFromProto","current","currentState","markChanged","isNaN","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","setPrototypeOf","fn","arguments","parseInt","useStrictShallowCopy_","Immer","constructor","config","recipe","defaultBase","self","curriedProduce","produce","hasError","p","ip","produceWithPatches","patches","inversePatches","autoFreeze","setAutoFreeze","useStrictShallowCopy","setUseStrictShallowCopy","useStrictIteration","setUseStrictIteration","createDraft","finishDraft","useStrictIteration_","shouldUseStrictIteration","applyPatches","patch","path","op","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","key_","rootDraftCleanup","currentImpl","copy","childValue","enablePatches","errorOffset","valueAtKey","setParent","from","indexOf","reverse","resolvePath","join","REPLACE","ADD","REMOVE","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","allReassigned","copiedItem","baseItem","isAssigned","childState","concat","clonePatchValueIfNeeded","assignedValue","origValue","unshift","baseValue","replacement","deepClonePatchValue","splice","map","entries","k","v","cloned","enableMapSet","DraftMap","assertUnrevoked","prepareMapCopy","cb","thisArg","_value","_map","values","iterator","next","r","done","DraftSet","prepareSetCopy","JSON","stringify","enableArrayMethods","SHIFTING_METHODS","QUEUE_METHODS","RESULT_RETURNING_METHODS","REORDERING_METHODS","MUTATING_METHODS","FIND_METHODS","NON_MUTATING_METHODS","method","isNonMutatingArrayMethod","enterOperation","exitOperation","executeArrayMethod","operation","markLength","markAllIndicesReassigned","normalizeSliceIndex","Math","max","min","handleInsertedValues","startIndex","handleSimpleOperation","lengthBefore","handleReorderingOperation","originalMethod","interceptedMethod","res","handleNonMutatingOperation","predicate","isForward","step","start","rawStart","rawEnd","end","bind","castDraft","castImmutable"],"sources":["C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\env.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\errors.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\common.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\plugins.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\scope.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\finalize.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\proxy.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\immerClass.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\current.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\plugins\\patches.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\plugins\\mapset.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\plugins\\arrayMethods.ts","C:\\Users\\HP\\Desktop\\react-projects\\Project-weathe\\Projekt\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\immer.ts"],"sourcesContent":["// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","import {isFunction} from \"../internal\"\n\nexport const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = isFunction(e) ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nconst O = Object\n\nexport const getPrototypeOf = O.getPrototypeOf\n\nexport const CONSTRUCTOR = \"constructor\"\nexport const PROTOTYPE = \"prototype\"\n\nexport const CONFIGURABLE = \"configurable\"\nexport const ENUMERABLE = \"enumerable\"\nexport const WRITABLE = \"writable\"\nexport const VALUE = \"value\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport let isDraft = (value: any): boolean => !!value && !!value[DRAFT_STATE]\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tisArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value[CONSTRUCTOR]?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString()\nconst cachedCtorStrings = new WeakMap()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || !isObjectish(value)) return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null || proto === O[PROTOTYPE]) return true\n\n\tconst Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR]\n\tif (Ctor === Object) return true\n\n\tif (!isFunction(Ctor)) return false\n\n\tlet ctorString = cachedCtorStrings.get(Ctor)\n\tif (ctorString === undefined) {\n\t\tctorString = Function.toString.call(Ctor)\n\t\tcachedCtorStrings.set(Ctor, ctorString)\n\t}\n\n\treturn ctorString === objectCtorString\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n *\n * @param obj The object to iterate over\n * @param iter The iterator function\n * @param strict When true (default), includes symbols and non-enumerable properties.\n *               When false, uses looseiteration over only enumerable string properties.\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tstrict?: boolean\n): void\nexport function each(obj: any, iter: any, strict: boolean = true) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\t// If strict, we do a full iteration including symbols and non-enumerable properties\n\t\t// Otherwise, we only iterate enumerable string properties for performance\n\t\tconst keys = strict ? Reflect.ownKeys(obj) : O.keys(obj)\n\t\tkeys.forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport let has = (\n\tthing: any,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): boolean =>\n\ttype === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: O[PROTOTYPE].hasOwnProperty.call(thing, prop)\n\n/*#__PURE__*/\nexport let get = (\n\tthing: AnyMap | AnyObject,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): any =>\n\t// @ts-ignore\n\ttype === ArchType.Map ? thing.get(prop) : thing[prop]\n\n/*#__PURE__*/\nexport let set = (\n\tthing: any,\n\tpropOrOldValue: PropertyKey,\n\tvalue: any,\n\ttype = getArchtype(thing)\n) => {\n\tif (type === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (type === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport let isArray = Array.isArray\n\n/*#__PURE__*/\nexport let isMap = (target: any): target is AnyMap => target instanceof Map\n\n/*#__PURE__*/\nexport let isSet = (target: any): target is AnySet => target instanceof Set\n\nexport let isObjectish = (target: any) => typeof target === \"object\"\n\nexport let isFunction = (target: any): target is Function =>\n\ttypeof target === \"function\"\n\nexport let isBoolean = (target: any): target is boolean =>\n\ttypeof target === \"boolean\"\n\nexport function isArrayIndex(value: string | number): value is number | string {\n\tconst n = +value\n\treturn Number.isInteger(n) && String(n) === value\n}\n\nexport let getProxyDraft = <T extends any>(value: T): ImmerState | null => {\n\tif (!isObjectish(value)) return null\n\treturn (value as {[DRAFT_STATE]: any})?.[DRAFT_STATE]\n}\n\n/*#__PURE__*/\nexport let latest = (state: ImmerState): any => state.copy_ || state.base_\n\nexport let getValue = <T extends object>(value: T): T => {\n\tconst proxyDraft = getProxyDraft(value)\n\treturn proxyDraft ? proxyDraft.copy_ ?? proxyDraft.base_ : value\n}\n\nexport let getFinalValue = (state: ImmerState): any =>\n\tstate.modified_ ? state.copy_ : state.base_\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (isArray(base)) return Array[PROTOTYPE].slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = O.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc[WRITABLE] === false) {\n\t\t\t\tdesc[WRITABLE] = true\n\t\t\t\tdesc[CONFIGURABLE] = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\t[CONFIGURABLE]: true,\n\t\t\t\t\t[WRITABLE]: true, // could live with !!desc.set as well here...\n\t\t\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t\t\t[VALUE]: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn O.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = O.create(proto)\n\t\treturn O.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tO.defineProperties(obj, {\n\t\t\tset: dontMutateMethodOverride,\n\t\t\tadd: dontMutateMethodOverride,\n\t\t\tclear: dontMutateMethodOverride,\n\t\t\tdelete: dontMutateMethodOverride\n\t\t})\n\t}\n\tO.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.values (only string-like, enumerables) instead of each()\n\t\teach(\n\t\t\tobj,\n\t\t\t(_key, value) => {\n\t\t\t\tfreeze(value, true)\n\t\t\t},\n\t\t\tfalse\n\t\t)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nconst dontMutateMethodOverride = {\n\t[VALUE]: dontMutateFrozenCollections\n}\n\nexport function isFrozen(obj: any): boolean {\n\t// Fast path: primitives and null/undefined are always \"frozen\"\n\tif (obj === null || !isObjectish(obj)) return true\n\treturn O.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie,\n\tImmerScope,\n\tProxyArrayState\n} from \"../internal\"\n\nexport const PluginMapSet = \"MapSet\"\nexport const PluginPatches = \"Patches\"\nexport const PluginArrayMethods = \"ArrayMethods\"\n\nexport type PatchesPlugin = {\n\tgeneratePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\trootScope: ImmerScope\n\t): void\n\tgenerateReplacementPatches_(\n\t\tbase: any,\n\t\treplacement: any,\n\t\trootScope: ImmerScope\n\t): void\n\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\tgetPath: (state: ImmerState) => PatchPath | null\n}\n\nexport type MapSetPlugin = {\n\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): [T, ImmerState]\n\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): [T, ImmerState]\n\tfixSetContents: (state: ImmerState) => void\n}\n\nexport type ArrayMethodsPlugin = {\n\tcreateMethodInterceptor: (state: ProxyArrayState, method: string) => Function\n\tisArrayOperationMethod: (method: string) => boolean\n\tisMutatingArrayMethod: (method: string) => boolean\n}\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: PatchesPlugin\n\tMapSet?: MapSetPlugin\n\tArrayMethods?: ArrayMethodsPlugin\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport let isPluginLoaded = <K extends keyof Plugins>(pluginKey: K): boolean =>\n\t!!plugins[pluginKey]\n\nexport let clearPlugin = <K extends keyof Plugins>(pluginKey: K): void => {\n\tdelete plugins[pluginKey]\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin,\n\tPatchesPlugin,\n\tMapSetPlugin,\n\tisPluginLoaded,\n\tPluginMapSet,\n\tPluginPatches,\n\tArrayMethodsPlugin,\n\tPluginArrayMethods\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tpatchPlugin_?: PatchesPlugin\n\tmapSetPlugin_?: MapSetPlugin\n\tarrayMethodsPlugin_?: ArrayMethodsPlugin\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n\thandledSet_: Set<any>\n\tprocessedForPatches_: Set<any>\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport let getCurrentScope = () => currentScope!\n\nlet createScope = (\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope => ({\n\tdrafts_: [],\n\tparent_,\n\timmer_,\n\t// Whenever the modified draft contains a draft from another scope, we\n\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\tcanAutoFreeze_: true,\n\tunfinalizedDrafts_: 0,\n\thandledSet_: new Set(),\n\tprocessedForPatches_: new Set(),\n\tmapSetPlugin_: isPluginLoaded(PluginMapSet)\n\t\t? getPlugin(PluginMapSet)\n\t\t: undefined,\n\tarrayMethodsPlugin_: isPluginLoaded(PluginArrayMethods)\n\t\t? getPlugin(PluginArrayMethods)\n\t\t: undefined\n})\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tscope.patchPlugin_ = getPlugin(PluginPatches) // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport let enterScope = (immer: Immer) =>\n\t(currentScope = createScope(currentScope, immer))\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tget,\n\tPatch,\n\tlatest,\n\tprepareCopy,\n\tgetFinalValue,\n\tgetValue,\n\tProxyArrayState\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t}\n\t\tconst {patchPlugin_} = scope\n\t\tif (patchPlugin_) {\n\t\t\tpatchPlugin_.generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft)\n\t}\n\n\tmaybeFreeze(scope, result, true)\n\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\tif (!state) {\n\t\tconst finalValue = handleValue(value, rootScope.handledSet_, rootScope)\n\t\treturn finalValue\n\t}\n\n\t// Never finalize drafts owned by another scope\n\tif (!isSameScope(state, rootScope)) {\n\t\treturn value\n\t}\n\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\treturn state.base_\n\t}\n\n\tif (!state.finalized_) {\n\t\t// Execute all registered draft finalization callbacks\n\t\tconst {callbacks_} = state\n\t\tif (callbacks_) {\n\t\t\twhile (callbacks_.length > 0) {\n\t\t\t\tconst callback = callbacks_.pop()!\n\t\t\t\tcallback(rootScope)\n\t\t\t}\n\t\t}\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t}\n\n\t// By now the root copy has been fully updated throughout its tree\n\treturn state.copy_\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n\nfunction markStateFinalized(state: ImmerState) {\n\tstate.finalized_ = true\n\tstate.scope_.unfinalizedDrafts_--\n}\n\nlet isSameScope = (state: ImmerState, rootScope: ImmerScope) =>\n\tstate.scope_ === rootScope\n\n// A reusable empty array to avoid allocations\nconst EMPTY_LOCATIONS_RESULT: (string | symbol | number)[] = []\n\n// Updates all references to a draft in its parent to the finalized value.\n// This handles cases where the same draft appears multiple times in the parent, or has been moved around.\nexport function updateDraftInParent(\n\tparent: ImmerState,\n\tdraftValue: any,\n\tfinalizedValue: any,\n\toriginalKey?: string | number | symbol\n): void {\n\tconst parentCopy = latest(parent)\n\tconst parentType = parent.type_\n\n\t// Fast path: Check if draft is still at original key\n\tif (originalKey !== undefined) {\n\t\tconst currentValue = get(parentCopy, originalKey, parentType)\n\t\tif (currentValue === draftValue) {\n\t\t\t// Still at original location, just update it\n\t\t\tset(parentCopy, originalKey, finalizedValue, parentType)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Slow path: Build reverse mapping of all children\n\t// to their indices in the parent, so that we can\n\t// replace all locations where this draft appears.\n\t// We only have to build this once per parent.\n\tif (!parent.draftLocations_) {\n\t\tconst draftLocations = (parent.draftLocations_ = new Map())\n\n\t\t// Use `each` which works on Arrays, Maps, and Objects\n\t\teach(parentCopy, (key, value) => {\n\t\t\tif (isDraft(value)) {\n\t\t\t\tconst keys = draftLocations.get(value) || []\n\t\t\t\tkeys.push(key)\n\t\t\t\tdraftLocations.set(value, keys)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Look up all locations where this draft appears\n\tconst locations =\n\t\tparent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT\n\n\t// Update all locations\n\tfor (const location of locations) {\n\t\tset(parentCopy, location, finalizedValue, parentType)\n\t}\n}\n\n// Register a callback to finalize a child draft when the parent draft is finalized.\n// This assumes there is a parent -> child relationship between the two drafts,\n// and we have a key to locate the child in the parent.\nexport function registerChildFinalizationCallback(\n\tparent: ImmerState,\n\tchild: ImmerState,\n\tkey: string | number | symbol\n) {\n\tparent.callbacks_.push(function childCleanup(rootScope) {\n\t\tconst state: ImmerState = child\n\n\t\t// Can only continue if this is a draft owned by this scope\n\t\tif (!state || !isSameScope(state, rootScope)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Handle potential set value finalization first\n\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t// Update all locations in the parent that referenced this draft\n\t\tupdateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key)\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t})\n}\n\nfunction generatePatchesAndFinalize(state: ImmerState, rootScope: ImmerScope) {\n\tconst shouldFinalize =\n\t\tstate.modified_ &&\n\t\t!state.finalized_ &&\n\t\t(state.type_ === ArchType.Set ||\n\t\t\t(state.type_ === ArchType.Array &&\n\t\t\t\t(state as ProxyArrayState).allIndicesReassigned_) ||\n\t\t\t(state.assigned_?.size ?? 0) > 0)\n\n\tif (shouldFinalize) {\n\t\tconst {patchPlugin_} = rootScope\n\t\tif (patchPlugin_) {\n\t\t\tconst basePath = patchPlugin_!.getPath(state)\n\n\t\t\tif (basePath) {\n\t\t\t\tpatchPlugin_!.generatePatches_(state, basePath, rootScope)\n\t\t\t}\n\t\t}\n\n\t\tmarkStateFinalized(state)\n\t}\n}\n\nexport function handleCrossReference(\n\ttarget: ImmerState,\n\tkey: string | number | symbol,\n\tvalue: any\n) {\n\tconst {scope_} = target\n\t// Check if value is a draft from this scope\n\tif (isDraft(value)) {\n\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\tif (isSameScope(state, scope_)) {\n\t\t\t// Register callback to update this location when the draft finalizes\n\n\t\t\tstate.callbacks_.push(function crossReferenceCleanup() {\n\t\t\t\t// Update the target location with finalized value\n\t\t\t\tprepareCopy(target)\n\n\t\t\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t\t\tupdateDraftInParent(target, value, finalizedValue, key)\n\t\t\t})\n\t\t}\n\t} else if (isDraftable(value)) {\n\t\t// Handle non-draft objects that might contain drafts\n\t\ttarget.callbacks_.push(function nestedDraftCleanup() {\n\t\t\tconst targetCopy = latest(target)\n\n\t\t\t// For Sets, check if value is still in the set\n\t\t\tif (target.type_ === ArchType.Set) {\n\t\t\t\tif (targetCopy.has(value)) {\n\t\t\t\t\t// Process the value to replace any nested drafts\n\t\t\t\t\thandleValue(value, scope_.handledSet_, scope_)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Maps/objects\n\t\t\t\tif (get(targetCopy, key, target.type_) === value) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tscope_.drafts_.length > 1 &&\n\t\t\t\t\t\t((target as Exclude<ImmerState, SetState>).assigned_!.get(key) ??\n\t\t\t\t\t\t\tfalse) === true &&\n\t\t\t\t\t\ttarget.copy_\n\t\t\t\t\t) {\n\t\t\t\t\t\t// This might be a non-draft value that has drafts\n\t\t\t\t\t\t// inside. We do need to recurse here to handle those.\n\t\t\t\t\t\thandleValue(\n\t\t\t\t\t\t\tget(target.copy_, key, target.type_),\n\t\t\t\t\t\t\tscope_.handledSet_,\n\t\t\t\t\t\t\tscope_\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nexport function handleValue(\n\ttarget: any,\n\thandledSet: Set<any>,\n\trootScope: ImmerScope\n) {\n\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t// This benefits especially adding large data tree's without further processing.\n\t\t// See add-data.js perf test\n\t\treturn target\n\t}\n\n\t// Skip if already handled, frozen, or not draftable\n\tif (\n\t\tisDraft(target) ||\n\t\thandledSet.has(target) ||\n\t\t!isDraftable(target) ||\n\t\tisFrozen(target)\n\t) {\n\t\treturn target\n\t}\n\n\thandledSet.add(target)\n\n\t// Process ALL properties/entries\n\teach(target, (key, value) => {\n\t\tif (isDraft(value)) {\n\t\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\t\tif (isSameScope(state, rootScope)) {\n\t\t\t\t// Replace draft with finalized value\n\n\t\t\t\tconst updatedValue = getFinalValue(state)\n\n\t\t\t\tset(target, key, updatedValue, target.type_)\n\n\t\t\t\tmarkStateFinalized(state)\n\t\t\t}\n\t\t} else if (isDraftable(value)) {\n\t\t\t// Recursively handle nested values\n\t\t\thandleValue(value, handledSet, rootScope)\n\t\t}\n\t})\n\n\treturn target\n}\n","import {\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\thandleCrossReference,\n\tWRITABLE,\n\tCONFIGURABLE,\n\tENUMERABLE,\n\tVALUE,\n\tisArray,\n\tisArrayIndex\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n\toperationMethod?: string\n\tallIndicesReassigned_?: boolean\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): [Drafted<T, ProxyState>, ProxyState] {\n\tconst baseIsArray = isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: baseIsArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\t// actually instantiated in `prepareCopy()`\n\t\tassigned_: undefined,\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false,\n\t\t// `callbacks` actually gets assigned in `createProxy`\n\t\tcallbacks_: undefined as any\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (baseIsArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn [proxy as any, state]\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tlet arrayPlugin = state.scope_.arrayMethodsPlugin_\n\t\tconst isArrayWithStringProp =\n\t\t\tstate.type_ === ArchType.Array && typeof prop === \"string\"\n\t\t// Intercept array methods so that we can override\n\t\t// behavior and skip proxy creation for perf\n\t\tif (isArrayWithStringProp) {\n\t\t\tif (arrayPlugin?.isArrayOperationMethod(prop)) {\n\t\t\t\treturn arrayPlugin.createMethodInterceptor(state, prop)\n\t\t\t}\n\t\t}\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop, state.type_)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\n\t\t// During mutating array operations, defer proxy creation for array elements\n\t\t// This optimization avoids creating unnecessary proxies during sort/reverse\n\t\tif (\n\t\t\tisArrayWithStringProp &&\n\t\t\t(state as ProxyArrayState).operationMethod &&\n\t\t\tarrayPlugin?.isMutatingArrayMethod(\n\t\t\t\t(state as ProxyArrayState).operationMethod!\n\t\t\t) &&\n\t\t\tisArrayIndex(prop)\n\t\t) {\n\t\t\t// Return raw value during mutating operations, create proxy only if modified\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\t// Ensure array keys are always numbers\n\t\t\tconst childKey = state.type_ === ArchType.Array ? +(prop as string) : prop\n\t\t\tconst childDraft = createProxy(state.scope_, value, state, childKey)\n\n\t\t\treturn (state.copy_![childKey] = childDraft)\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_!.set(prop, false)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (\n\t\t\t\tis(value, current) &&\n\t\t\t\t(value !== undefined || has(state.base_, prop, state.type_))\n\t\t\t)\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_!.set(prop, true)\n\n\t\thandleCrossReference(state, prop, value)\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\tprepareCopy(state)\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_!.set(prop, false)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tstate.assigned_!.delete(prop)\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\t[WRITABLE]: true,\n\t\t\t[CONFIGURABLE]: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t[VALUE]: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\n// Use `for..in` instead of `each` to work around a weird\n// prod test suite issue\nfor (let key in objectTraps) {\n\tlet fn = objectTraps[key as keyof typeof objectTraps] as Function\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\tconst args = arguments\n\t\targs[0] = args[0][0]\n\t\treturn fn.apply(this, args)\n\t}\n}\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? VALUE in desc\n\t\t\t? desc[VALUE]\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: ImmerState) {\n\tif (!state.copy_) {\n\t\t// Actually create the `assigned_` map now that we\n\t\t// know this is a modified draft.\n\t\tstate.assigned_ = new Map()\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent,\n\tImmerScope,\n\tregisterChildFinalizationCallback,\n\tArchType,\n\tMapSetPlugin,\n\tAnyMap,\n\tAnySet,\n\tisObjectish,\n\tisFunction,\n\tisBoolean,\n\tPluginMapSet,\n\tPluginPatches\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\"\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\tuseStrictIteration_: boolean = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t\tuseStrictIteration?: boolean\n\t}) {\n\t\tif (isBoolean(config?.autoFreeze)) this.setAutoFreeze(config!.autoFreeze)\n\t\tif (isBoolean(config?.useStrictShallowCopy))\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t\tif (isBoolean(config?.useStrictIteration))\n\t\t\tthis.setUseStrictIteration(config!.useStrictIteration)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (isFunction(base) && !isFunction(recipe)) {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (!isFunction(recipe)) die(6)\n\t\tif (patchListener !== undefined && !isFunction(patchListener)) die(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(scope, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || !isObjectish(base)) {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(PluginPatches).generateReplacementPatches_(base, result, {\n\t\t\t\t\tpatches_: p,\n\t\t\t\t\tinversePatches_: ip\n\t\t\t\t} as ImmerScope) // dummy scope\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (isFunction(base)) {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(scope, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\t/**\n\t * Pass false to use faster iteration that skips non-enumerable properties\n\t * but still handles symbols for compatibility.\n\t *\n\t * By default, strict iteration is enabled (includes all own properties).\n\t */\n\tsetUseStrictIteration(value: boolean) {\n\t\tthis.useStrictIteration_ = value\n\t}\n\n\tshouldUseStrictIteration(): boolean {\n\t\treturn this.useStrictIteration_\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(PluginPatches).applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\trootScope: ImmerScope,\n\tvalue: T,\n\tparent?: ImmerState,\n\tkey?: string | number | symbol\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\t// returning a tuple here lets us skip a proxy access\n\t// to DRAFT_STATE later\n\tconst [draft, state] = isMap(value)\n\t\t? getPlugin(PluginMapSet).proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(PluginMapSet).proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent?.scope_ ?? getCurrentScope()\n\tscope.drafts_.push(draft)\n\n\t// Ensure the parent callbacks are passed down so we actually\n\t// track all callbacks added throughout the tree\n\tstate.callbacks_ = parent?.callbacks_ ?? []\n\tstate.key_ = key\n\n\tif (parent && key !== undefined) {\n\t\tregisterChildFinalizationCallback(parent, state, key)\n\t} else {\n\t\t// It's a root draft, register it with the scope\n\t\tstate.callbacks_.push(function rootDraftCleanup(rootScope) {\n\t\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\t\tconst {patchPlugin_} = rootScope\n\n\t\t\tif (state.modified_ && patchPlugin_) {\n\t\t\t\tpatchPlugin_.generatePatches_(state, [], rootScope)\n\t\t\t}\n\t\t})\n\t}\n\n\treturn draft as any\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tlet strict = true // Default to strict for compatibility\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t\tstrict = state.scope_.immer_.shouldUseStrictIteration()\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(\n\t\tcopy,\n\t\t(key, childValue) => {\n\t\t\tset(copy, key, currentImpl(childValue))\n\t\t},\n\t\tstrict\n\t)\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors,\n\tDRAFT_STATE,\n\tgetProxyDraft,\n\tImmerScope,\n\tisObjectish,\n\tisFunction,\n\tCONSTRUCTOR,\n\tPluginPatches,\n\tisArray,\n\tPROTOTYPE\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tfunction getPath(state: ImmerState, path: PatchPath = []): PatchPath | null {\n\t\t// Step 1: Check if state has a stored key\n\t\tif (state.key_ !== undefined) {\n\t\t\t// Step 2: Validate the key is still valid in parent\n\n\t\t\tconst parentCopy = state.parent_!.copy_ ?? state.parent_!.base_\n\t\t\tconst proxyDraft = getProxyDraft(get(parentCopy, state.key_!))\n\t\t\tconst valueAtKey = get(parentCopy, state.key_!)\n\n\t\t\tif (valueAtKey === undefined) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\t// Check if the value at the key is still related to this draft\n\t\t\t// It should be either the draft itself, the base, or the copy\n\t\t\tif (\n\t\t\t\tvalueAtKey !== state.draft_ &&\n\t\t\t\tvalueAtKey !== state.base_ &&\n\t\t\t\tvalueAtKey !== state.copy_\n\t\t\t) {\n\t\t\t\treturn null // Value was replaced with something else\n\t\t\t}\n\t\t\tif (proxyDraft != null && proxyDraft.base_ !== state.base_) {\n\t\t\t\treturn null // Different draft\n\t\t\t}\n\n\t\t\t// Step 3: Handle Set case specially\n\t\t\tconst isSet = state.parent_!.type_ === ArchType.Set\n\t\t\tlet key: string | number\n\n\t\t\tif (isSet) {\n\t\t\t\t// For Sets, find the index in the drafts_ map\n\t\t\t\tconst setParent = state.parent_ as SetState\n\t\t\t\tkey = Array.from(setParent.drafts_.keys()).indexOf(state.key_)\n\t\t\t} else {\n\t\t\t\tkey = state.key_ as string | number\n\t\t\t}\n\n\t\t\t// Step 4: Validate key still exists in parent\n\t\t\tif (!((isSet && parentCopy.size > key) || has(parentCopy, key))) {\n\t\t\t\treturn null // Key deleted\n\t\t\t}\n\n\t\t\t// Step 5: Add key to path\n\t\t\tpath.push(key)\n\t\t}\n\n\t\t// Step 6: Recurse to parent if exists\n\t\tif (state.parent_) {\n\t\t\treturn getPath(state.parent_, path)\n\t\t}\n\n\t\t// Step 7: At root - reverse path and validate\n\t\tpath.reverse()\n\n\t\ttry {\n\t\t\t// Validate path can be resolved from ROOT\n\t\t\tresolvePath(state.copy_, path)\n\t\t} catch (e) {\n\t\t\treturn null // Path invalid\n\t\t}\n\n\t\treturn path\n\t}\n\n\t// NEW: Add resolvePath helper function\n\tfunction resolvePath(base: any, path: PatchPath): any {\n\t\tlet current = base\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst key = path[i]\n\t\t\tcurrent = get(current, key)\n\t\t\tif (!isObjectish(current) || current === null) {\n\t\t\t\tthrow new Error(`Cannot resolve path at '${path.join(\"/\")}'`)\n\t\t\t}\n\t\t}\n\t\treturn current\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tscope: ImmerScope\n\t): void {\n\t\tif (state.scope_.processedForPatches_.has(state)) {\n\t\t\treturn\n\t\t}\n\n\t\tstate.scope_.processedForPatches_.add(state)\n\n\t\tconst {patches_, inversePatches_} = scope\n\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\tconst allReassigned = state.allIndicesReassigned_ === true\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tconst copiedItem = copy_[i]\n\t\t\tconst baseItem = base_[i]\n\n\t\t\tconst isAssigned = allReassigned || assigned_?.get(i.toString())\n\t\t\tif (isAssigned && copiedItem !== baseItem) {\n\t\t\t\tconst childState = copiedItem?.[DRAFT_STATE]\n\t\t\t\tif (childState && childState.modified_) {\n\t\t\t\t\t// Skip - let the child generate its own patches\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copiedItem)\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(baseItem)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_, type_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key, type_)\n\t\t\tconst value = get(copy_!, key, type_)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(\n\t\t\t\top === REMOVE\n\t\t\t\t\t? {op, path}\n\t\t\t\t\t: {op, path, value: clonePatchValueIfNeeded(value)}\n\t\t\t)\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tscope: ImmerScope\n\t): void {\n\t\tconst {patches_, inversePatches_} = scope\n\t\tpatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === CONSTRUCTOR)\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (isFunction(base) && p === PROTOTYPE) die(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (!isObjectish(base)) die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(PluginPatches, {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_,\n\t\tgetPath\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach,\n\tgetValue,\n\tPluginMapSet,\n\thandleCrossReference\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\thandleCrossReference(state, key, value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_, value, state, key)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, MapState] {\n\t\t// @ts-ignore\n\t\tconst map = new DraftMap(target, parent)\n\t\treturn [map as any, map[DRAFT_STATE]]\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t\thandleCrossReference(state, value, value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, SetState] {\n\t\t// @ts-ignore\n\t\tconst set = new DraftSet(target, parent)\n\t\treturn [set as any, set[DRAFT_STATE]]\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_, value, state, value)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tfunction fixSetContents(target: ImmerState) {\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\tif (target.type_ === ArchType.Set && target.copy_) {\n\t\t\tconst copy = new Set(target.copy_)\n\t\t\ttarget.copy_.clear()\n\t\t\tcopy.forEach(value => {\n\t\t\t\ttarget.copy_!.add(getValue(value))\n\t\t\t})\n\t\t}\n\t}\n\n\tloadPlugin(PluginMapSet, {proxyMap_, proxySet_, fixSetContents})\n}\n","import {\n\tPluginArrayMethods,\n\tlatest,\n\tloadPlugin,\n\tmarkChanged,\n\tprepareCopy,\n\thandleCrossReference,\n\tProxyArrayState\n} from \"../internal\"\n\n/**\n * Methods that directly modify the array in place.\n * These operate on the copy without creating per-element proxies:\n * - `push`, `pop`: Add/remove from end\n * - `shift`, `unshift`: Add/remove from start (marks all indices reassigned)\n * - `splice`: Add/remove at arbitrary position (marks all indices reassigned)\n * - `reverse`, `sort`: Reorder elements (marks all indices reassigned)\n */\ntype MutatingArrayMethod =\n\t| \"push\"\n\t| \"pop\"\n\t| \"shift\"\n\t| \"unshift\"\n\t| \"splice\"\n\t| \"reverse\"\n\t| \"sort\"\n\n/**\n * Methods that read from the array without modifying it.\n * These fall into distinct categories based on return semantics:\n *\n * **Subset operations** (return drafts - mutations propagate):\n * - `filter`, `slice`: Return array of draft proxies\n * - `find`, `findLast`: Return single draft proxy or undefined\n *\n * **Transform operations** (return base values - mutations don't track):\n * - `concat`, `flat`: Create new structures, not subsets of original\n *\n * **Primitive-returning** (no draft needed):\n * - `findIndex`, `findLastIndex`, `indexOf`, `lastIndexOf`: Return numbers\n * - `some`, `every`, `includes`: Return booleans\n * - `join`, `toString`, `toLocaleString`: Return strings\n */\ntype NonMutatingArrayMethod =\n\t| \"filter\"\n\t| \"slice\"\n\t| \"concat\"\n\t| \"flat\"\n\t| \"find\"\n\t| \"findIndex\"\n\t| \"findLast\"\n\t| \"findLastIndex\"\n\t| \"some\"\n\t| \"every\"\n\t| \"indexOf\"\n\t| \"lastIndexOf\"\n\t| \"includes\"\n\t| \"join\"\n\t| \"toString\"\n\t| \"toLocaleString\"\n\n/** Union of all array operation methods handled by the plugin. */\nexport type ArrayOperationMethod = MutatingArrayMethod | NonMutatingArrayMethod\n\n/**\n * Enables optimized array method handling for Immer drafts.\n *\n * This plugin overrides array methods to avoid unnecessary Proxy creation during iteration,\n * significantly improving performance for array-heavy operations.\n *\n * **Mutating methods** (push, pop, shift, unshift, splice, sort, reverse):\n * Operate directly on the copy without creating per-element proxies.\n *\n * **Non-mutating methods** fall into categories:\n * - **Subset operations** (filter, slice, find, findLast): Return draft proxies - mutations track\n * - **Transform operations** (concat, flat): Return base values - mutations don't track\n * - **Primitive-returning** (indexOf, includes, some, every, etc.): Return primitives\n *\n * **Important**: Callbacks for overridden methods receive base values, not drafts.\n * This is the core performance optimization.\n *\n * @example\n * ```ts\n * import { enableArrayMethods, produce } from \"immer\"\n *\n * enableArrayMethods()\n *\n * const next = produce(state, draft => {\n *   // Optimized - no proxy creation per element\n *   draft.items.sort((a, b) => a.value - b.value)\n *\n *   // filter returns drafts - mutations propagate\n *   const filtered = draft.items.filter(x => x.value > 5)\n *   filtered[0].value = 999 // Affects draft.items[originalIndex]\n * })\n * ```\n *\n * @see https://immerjs.github.io/immer/array-methods\n */\nexport function enableArrayMethods() {\n\tconst SHIFTING_METHODS = new Set<MutatingArrayMethod>([\"shift\", \"unshift\"])\n\n\tconst QUEUE_METHODS = new Set<MutatingArrayMethod>([\"push\", \"pop\"])\n\n\tconst RESULT_RETURNING_METHODS = new Set<MutatingArrayMethod>([\n\t\t...QUEUE_METHODS,\n\t\t...SHIFTING_METHODS\n\t])\n\n\tconst REORDERING_METHODS = new Set<MutatingArrayMethod>([\"reverse\", \"sort\"])\n\n\t// Optimized method detection using array-based lookup\n\tconst MUTATING_METHODS = new Set<MutatingArrayMethod>([\n\t\t...RESULT_RETURNING_METHODS,\n\t\t...REORDERING_METHODS,\n\t\t\"splice\"\n\t])\n\n\tconst FIND_METHODS = new Set<NonMutatingArrayMethod>([\"find\", \"findLast\"])\n\n\tconst NON_MUTATING_METHODS = new Set<NonMutatingArrayMethod>([\n\t\t\"filter\",\n\t\t\"slice\",\n\t\t\"concat\",\n\t\t\"flat\",\n\t\t...FIND_METHODS,\n\t\t\"findIndex\",\n\t\t\"findLastIndex\",\n\t\t\"some\",\n\t\t\"every\",\n\t\t\"indexOf\",\n\t\t\"lastIndexOf\",\n\t\t\"includes\",\n\t\t\"join\",\n\t\t\"toString\",\n\t\t\"toLocaleString\"\n\t])\n\n\t// Type guard for method detection\n\tfunction isMutatingArrayMethod(\n\t\tmethod: string\n\t): method is MutatingArrayMethod {\n\t\treturn MUTATING_METHODS.has(method as any)\n\t}\n\n\tfunction isNonMutatingArrayMethod(\n\t\tmethod: string\n\t): method is NonMutatingArrayMethod {\n\t\treturn NON_MUTATING_METHODS.has(method as any)\n\t}\n\n\tfunction isArrayOperationMethod(\n\t\tmethod: string\n\t): method is ArrayOperationMethod {\n\t\treturn isMutatingArrayMethod(method) || isNonMutatingArrayMethod(method)\n\t}\n\n\tfunction enterOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: ArrayOperationMethod\n\t) {\n\t\tstate.operationMethod = method\n\t}\n\n\tfunction exitOperation(state: ProxyArrayState) {\n\t\tstate.operationMethod = undefined\n\t}\n\n\t// Shared utility functions for array method handlers\n\tfunction executeArrayMethod<T>(\n\t\tstate: ProxyArrayState,\n\t\toperation: () => T,\n\t\tmarkLength = true\n\t): T {\n\t\tprepareCopy(state)\n\t\tconst result = operation()\n\t\tmarkChanged(state)\n\t\tif (markLength) state.assigned_!.set(\"length\", true)\n\t\treturn result\n\t}\n\n\tfunction markAllIndicesReassigned(state: ProxyArrayState) {\n\t\tstate.allIndicesReassigned_ = true\n\t}\n\n\tfunction normalizeSliceIndex(index: number, length: number): number {\n\t\tif (index < 0) {\n\t\t\treturn Math.max(length + index, 0)\n\t\t}\n\t\treturn Math.min(index, length)\n\t}\n\n\t/**\n\t * Calls handleCrossReference for each value being inserted into the array,\n\t * and marks the corresponding indices as assigned in `assigned_`.\n\t *\n\t * This ensures nested drafts inside inserted values (e.g. from spreading\n\t * a draft object) are properly finalized, matching the behavior of the\n\t * proxy set trap which calls handleCrossReference on every assignment.\n\t *\n\t * Without this, values containing draft proxies (like `{...state[0]}`)\n\t * pushed via the array methods plugin would have their nested drafts\n\t * revoked during finalization without being replaced by final values.\n\t */\n\tfunction handleInsertedValues(\n\t\tstate: ProxyArrayState,\n\t\tstartIndex: number,\n\t\tvalues: any[]\n\t) {\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst index = startIndex + i\n\t\t\tstate.assigned_!.set(index, true)\n\t\t\thandleCrossReference(state, index, values[i])\n\t\t}\n\t}\n\n\t/**\n\t * Handles mutating operations that add/remove elements (push, pop, shift, unshift, splice).\n\t *\n\t * Operates directly on `state.copy_` without creating per-element proxies.\n\t * For shifting methods (shift, unshift), marks all indices as reassigned since\n\t * indices shift.\n\t *\n\t * @returns For push/pop/shift/unshift: the native method result. For others: the draft.\n\t */\n\tfunction handleSimpleOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: string,\n\t\targs: any[]\n\t) {\n\t\treturn executeArrayMethod(state, () => {\n\t\t\t// For push/unshift, capture the length before the operation\n\t\t\t// so we can compute insertion indices for handleCrossReference\n\t\t\tconst lengthBefore = state.copy_!.length\n\n\t\t\tconst result = (state.copy_! as any)[method](...args)\n\n\t\t\t// Handle index reassignment for shifting methods\n\t\t\tif (SHIFTING_METHODS.has(method as MutatingArrayMethod)) {\n\t\t\t\tmarkAllIndicesReassigned(state)\n\t\t\t}\n\n\t\t\t// Handle cross-references for newly inserted values.\n\t\t\t// push appends at the end, unshift inserts at the beginning.\n\t\t\tif (method === \"push\" && args.length > 0) {\n\t\t\t\thandleInsertedValues(state, lengthBefore, args)\n\t\t\t} else if (method === \"unshift\" && args.length > 0) {\n\t\t\t\thandleInsertedValues(state, 0, args)\n\t\t\t}\n\n\t\t\t// Return appropriate value based on method\n\t\t\treturn RESULT_RETURNING_METHODS.has(method as MutatingArrayMethod)\n\t\t\t\t? result\n\t\t\t\t: state.draft_\n\t\t})\n\t}\n\n\t/**\n\t * Handles reordering operations (reverse, sort) that change element order.\n\t *\n\t * Operates directly on `state.copy_` and marks all indices as reassigned\n\t * since element positions change. Does not mark length as changed since\n\t * these operations preserve array length.\n\t *\n\t * @returns The draft proxy for method chaining.\n\t */\n\tfunction handleReorderingOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: string,\n\t\targs: any[]\n\t) {\n\t\treturn executeArrayMethod(\n\t\t\tstate,\n\t\t\t() => {\n\t\t\t\t;(state.copy_! as any)[method](...args)\n\t\t\t\tmarkAllIndicesReassigned(state)\n\t\t\t\treturn state.draft_\n\t\t\t},\n\t\t\tfalse\n\t\t) // Don't mark length as changed\n\t}\n\n\t/**\n\t * Creates an interceptor function for a specific array method.\n\t *\n\t * The interceptor wraps array method calls to:\n\t * 1. Set `state.operationMethod` flag during execution (allows proxy `get` trap\n\t *    to detect we're inside an optimized method and skip proxy creation)\n\t * 2. Route to appropriate handler based on method type\n\t * 3. Clean up the operation flag in `finally` block\n\t *\n\t * The `operationMethod` flag is the key mechanism that enables the proxy's `get`\n\t * trap to return base values instead of creating nested proxies during iteration.\n\t *\n\t * @param state - The proxy array state\n\t * @param originalMethod - Name of the array method being intercepted\n\t * @returns Interceptor function that handles the method call\n\t */\n\tfunction createMethodInterceptor(\n\t\tstate: ProxyArrayState,\n\t\toriginalMethod: string\n\t) {\n\t\treturn function interceptedMethod(...args: any[]) {\n\t\t\t// Enter operation mode - this flag tells the proxy's get trap to return\n\t\t\t// base values instead of creating nested proxies during iteration\n\t\t\tconst method = originalMethod as ArrayOperationMethod\n\t\t\tenterOperation(state, method)\n\n\t\t\ttry {\n\t\t\t\t// Check if this is a mutating method\n\t\t\t\tif (isMutatingArrayMethod(method)) {\n\t\t\t\t\t// Direct method dispatch - no configuration lookup needed\n\t\t\t\t\tif (RESULT_RETURNING_METHODS.has(method)) {\n\t\t\t\t\t\treturn handleSimpleOperation(state, method, args)\n\t\t\t\t\t}\n\t\t\t\t\tif (REORDERING_METHODS.has(method)) {\n\t\t\t\t\t\treturn handleReorderingOperation(state, method, args)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (method === \"splice\") {\n\t\t\t\t\t\tconst res = executeArrayMethod(state, () =>\n\t\t\t\t\t\t\tstate.copy_!.splice(...(args as [number, number, ...any[]]))\n\t\t\t\t\t\t)\n\t\t\t\t\t\tmarkAllIndicesReassigned(state)\n\t\t\t\t\t\t// Handle cross-references for inserted values (args from index 2+)\n\t\t\t\t\t\tif (args.length > 2) {\n\t\t\t\t\t\t\tconst startIndex = normalizeSliceIndex(\n\t\t\t\t\t\t\t\targs[0] ?? 0,\n\t\t\t\t\t\t\t\tstate.copy_!.length\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\thandleInsertedValues(state, startIndex, args.slice(2))\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn res\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Handle non-mutating methods\n\t\t\t\t\treturn handleNonMutatingOperation(state, method, args)\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\t// Always exit operation mode - must be in finally to handle exceptions\n\t\t\t\texitOperation(state)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles non-mutating array methods with different return semantics.\n\t *\n\t * **Subset operations** return draft proxies for mutation tracking:\n\t * - `filter`, `slice`: Return `state.draft_[i]` for each selected element\n\t * - `find`, `findLast`: Return `state.draft_[i]` for the found element\n\t *\n\t * This allows mutations on returned elements to propagate back to the draft:\n\t * ```ts\n\t * const filtered = draft.items.filter(x => x.value > 5)\n\t * filtered[0].value = 999 // Mutates draft.items[originalIndex]\n\t * ```\n\t *\n\t * **Transform operations** return base values (no draft tracking):\n\t * - `concat`, `flat`: These create NEW arrays rather than selecting subsets.\n\t *   Since the result structure differs from the original, tracking mutations\n\t *   back to specific draft indices would be impractical/impossible.\n\t *\n\t * **Primitive operations** return the native result directly:\n\t * - `indexOf`, `includes`, `some`, `every`, `join`, etc.\n\t *\n\t * @param state - The proxy array state\n\t * @param method - The non-mutating method name\n\t * @param args - Arguments passed to the method\n\t * @returns Drafts for subset operations, base values for transforms, primitives otherwise\n\t */\n\tfunction handleNonMutatingOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: NonMutatingArrayMethod,\n\t\targs: any[]\n\t) {\n\t\tconst source = latest(state)\n\n\t\t// Methods that return arrays with selected items - need to return drafts\n\t\tif (method === \"filter\") {\n\t\t\tconst predicate = args[0]\n\t\t\tconst result: any[] = []\n\n\t\t\t// First pass: call predicate on base values to determine which items pass\n\t\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\t\tif (predicate(source[i], i, source)) {\n\t\t\t\t\t// Only create draft for items that passed the predicate\n\t\t\t\t\tresult.push(state.draft_[i])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\n\t\tif (FIND_METHODS.has(method)) {\n\t\t\tconst predicate = args[0]\n\t\t\tconst isForward = method === \"find\"\n\t\t\tconst step = isForward ? 1 : -1\n\t\t\tconst start = isForward ? 0 : source.length - 1\n\n\t\t\tfor (let i = start; i >= 0 && i < source.length; i += step) {\n\t\t\t\tif (predicate(source[i], i, source)) {\n\t\t\t\t\treturn state.draft_[i]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (method === \"slice\") {\n\t\t\tconst rawStart = args[0] ?? 0\n\t\t\tconst rawEnd = args[1] ?? source.length\n\n\t\t\t// Normalize negative indices\n\t\t\tconst start = normalizeSliceIndex(rawStart, source.length)\n\t\t\tconst end = normalizeSliceIndex(rawEnd, source.length)\n\n\t\t\tconst result: any[] = []\n\n\t\t\t// Return drafts for items in the slice range\n\t\t\tfor (let i = start; i < end; i++) {\n\t\t\t\tresult.push(state.draft_[i])\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\n\t\t// For other methods, call on base array directly:\n\t\t// - indexOf, includes, join, toString: Return primitives, no draft needed\n\t\t// - concat, flat: Return NEW arrays (not subsets). Elements are base values.\n\t\t//   This is intentional - concat/flat create new data structures rather than\n\t\t//   selecting subsets of the original, making draft tracking impractical.\n\t\treturn source[method as keyof typeof Array.prototype](...args)\n\t}\n\n\tloadPlugin(PluginArrayMethods, {\n\t\tcreateMethodInterceptor,\n\t\tisArrayOperationMethod,\n\t\tisMutatingArrayMethod\n\t})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = /* @__PURE__ */ immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(\n\timmer\n)\n\n/**\n * Pass false to use loose iteration that only processes enumerable string properties.\n * This skips symbols and non-enumerable properties for maximum performance.\n *\n * By default, strict iteration is enabled (includes all own properties).\n */\nexport const setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(\n\timmer\n)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = /* @__PURE__ */ immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport let castDraft = <T>(value: T): Draft<T> => value as any\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport let castImmutable = <T>(value: T): Immutable<T> => value as any\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableArrayMethods} from \"./plugins/arrayMethods\"\n"]},"metadata":{},"sourceType":"module"}