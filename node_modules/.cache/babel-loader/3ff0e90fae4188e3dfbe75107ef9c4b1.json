{"ast":null,"code":"var _excluded = [\"x\", \"y\"];\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n\n  return t;\n}\n\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n\n  var o,\n      r,\n      i = _objectWithoutPropertiesLoose(e, t);\n\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n\n  return i;\n}\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n\n  return t;\n}\n\nimport { useEffect } from 'react';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { selectEventEmitter, selectSyncId, selectSyncMethod } from '../state/selectors/rootPropsSelectors';\nimport { BRUSH_SYNC_EVENT, eventCenter, TOOLTIP_SYNC_EVENT } from '../util/Events';\nimport { createEventEmitter } from '../state/optionsSlice';\nimport { setSyncInteraction } from '../state/tooltipSlice';\nimport { selectTooltipDataKey } from '../state/selectors/selectors';\nimport { selectTooltipAxisTicks } from '../state/selectors/tooltipSelectors';\nimport { selectSynchronisedTooltipState } from './syncSelectors';\nimport { useChartLayout, useViewBox } from '../context/chartLayoutContext';\nimport { setDataStartEndIndexes } from '../state/chartDataSlice';\nimport { noop } from '../util/DataUtils';\n\nfunction useTooltipSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipTicks = useAppSelector(selectTooltipAxisTicks);\n  var layout = useChartLayout();\n  var viewBox = useViewBox();\n  var className = useAppSelector(state => state.rootProps.className);\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n\n      if (mySyncId !== incomingSyncId) {\n        // This event is not for this chart\n        return;\n      }\n\n      if (syncMethod === 'index') {\n        var _action$payload;\n\n        if (viewBox && action !== null && action !== void 0 && (_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.coordinate && action.payload.sourceViewBox) {\n          var _action$payload$coord = action.payload.coordinate,\n              {\n            x: _x,\n            y: _y\n          } = _action$payload$coord,\n              otherCoordinateProps = _objectWithoutProperties(_action$payload$coord, _excluded);\n\n          var {\n            x: sourceX,\n            y: sourceY,\n            width: sourceWidth,\n            height: sourceHeight\n          } = action.payload.sourceViewBox;\n\n          var scaledCoordinate = _objectSpread(_objectSpread({}, otherCoordinateProps), {}, {\n            x: viewBox.x + (sourceWidth ? (_x - sourceX) / sourceWidth : 0) * viewBox.width,\n            y: viewBox.y + (sourceHeight ? (_y - sourceY) / sourceHeight : 0) * viewBox.height\n          });\n\n          dispatch(_objectSpread(_objectSpread({}, action), {}, {\n            payload: _objectSpread(_objectSpread({}, action.payload), {}, {\n              coordinate: scaledCoordinate\n            })\n          }));\n        } else {\n          dispatch(action);\n        }\n\n        return;\n      }\n\n      if (tooltipTicks == null) {\n        // for the other two sync methods, we need the ticks to be available\n        return;\n      }\n\n      var activeTick;\n\n      if (typeof syncMethod === 'function') {\n        /*\n         * This is what the data shape in 2.x CategoricalChartState used to look like.\n         * In 3.x we store things differently but let's try to keep the old shape for compatibility.\n         */\n        var syncMethodParam = {\n          activeTooltipIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          isTooltipActive: action.payload.active,\n          activeIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          activeLabel: action.payload.label,\n          activeDataKey: action.payload.dataKey,\n          activeCoordinate: action.payload.coordinate\n        }; // Call a callback function. If there is an application specific algorithm\n\n        var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);\n        activeTick = tooltipTicks[activeTooltipIndex];\n      } else if (syncMethod === 'value') {\n        // labels are always strings, tick.value might be a string or a number, depending on axis type\n        activeTick = tooltipTicks.find(tick => String(tick.value) === action.payload.label);\n      }\n\n      var {\n        coordinate\n      } = action.payload;\n\n      if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {\n        dispatch(setSyncInteraction({\n          active: false,\n          coordinate: undefined,\n          dataKey: undefined,\n          index: null,\n          label: undefined,\n          sourceViewBox: undefined,\n          graphicalItemId: undefined\n        }));\n        return;\n      }\n\n      var {\n        x,\n        y\n      } = coordinate;\n      var validateChartX = Math.min(x, viewBox.x + viewBox.width);\n      var validateChartY = Math.min(y, viewBox.y + viewBox.height);\n      var activeCoordinate = {\n        x: layout === 'horizontal' ? activeTick.coordinate : validateChartX,\n        y: layout === 'horizontal' ? validateChartY : activeTick.coordinate\n      };\n      var syncAction = setSyncInteraction({\n        active: action.payload.active,\n        coordinate: activeCoordinate,\n        dataKey: action.payload.dataKey,\n        index: String(activeTick.index),\n        label: action.payload.label,\n        sourceViewBox: action.payload.sourceViewBox,\n        graphicalItemId: action.payload.graphicalItemId\n      });\n      dispatch(syncAction);\n    };\n\n    eventCenter.on(TOOLTIP_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(TOOLTIP_SYNC_EVENT, listener);\n    };\n  }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);\n}\n\nfunction useBrushSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n\n      if (mySyncId === incomingSyncId) {\n        dispatch(setDataStartEndIndexes(action));\n      }\n    };\n\n    eventCenter.on(BRUSH_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(BRUSH_SYNC_EVENT, listener);\n    };\n  }, [dispatch, myEventEmitter, mySyncId]);\n}\n/**\n * Will receive synchronisation events from other charts.\n *\n * Reads syncMethod from state and decides how to synchronise the tooltip based on that.\n *\n * @returns void\n */\n\n\nexport function useSynchronisedEventsFromOtherCharts() {\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(createEventEmitter());\n  }, [dispatch]);\n  useTooltipSyncEventsListener();\n  useBrushSyncEventsListener();\n}\n/**\n * Will send events to other charts.\n * If syncId is undefined, no events will be sent.\n *\n * This ignores the syncMethod, because that is set and computed on the receiving end.\n *\n * @param tooltipEventType from Tooltip\n * @param trigger from Tooltip\n * @param activeCoordinate from state\n * @param activeLabel from state\n * @param activeIndex from state\n * @param isTooltipActive from state\n * @returns void\n */\n\nexport function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {\n  var activeDataKey = useAppSelector(state => selectTooltipDataKey(state, tooltipEventType, trigger));\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var syncId = useAppSelector(selectSyncId);\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipState = useAppSelector(selectSynchronisedTooltipState);\n  var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;\n  var viewBox = useViewBox();\n  useEffect(() => {\n    if (isReceivingSynchronisation) {\n      /*\n       * This chart currently has active tooltip, synchronised from another chart.\n       * Let's not send any outgoing synchronisation events while that's happening\n       * to avoid infinite loops.\n       */\n      return;\n    }\n\n    if (syncId == null) {\n      /*\n       * syncId is not set, means that this chart is not synchronised with any other chart,\n       * means we don't need to send synchronisation events\n       */\n      return;\n    }\n\n    if (eventEmitterSymbol == null) {\n      /*\n       * When using Recharts internal hooks and selectors outside charts context,\n       * these properties will be undefined. Let's return silently instead of throwing an error.\n       */\n      return;\n    }\n\n    var syncAction = setSyncInteraction({\n      active: isTooltipActive,\n      coordinate: activeCoordinate,\n      dataKey: activeDataKey,\n      index: activeIndex,\n      label: typeof activeLabel === 'number' ? String(activeLabel) : activeLabel,\n      sourceViewBox: viewBox,\n      graphicalItemId: undefined\n    });\n    eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive, viewBox]);\n}\nexport function useBrushChartSynchronisation() {\n  var syncId = useAppSelector(selectSyncId);\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var brushStartIndex = useAppSelector(state => state.chartData.dataStartIndex);\n  var brushEndIndex = useAppSelector(state => state.chartData.dataEndIndex);\n  useEffect(() => {\n    if (syncId == null || brushStartIndex == null || brushEndIndex == null || eventEmitterSymbol == null) {\n      return;\n    }\n\n    var syncAction = {\n      startIndex: brushStartIndex,\n      endIndex: brushEndIndex\n    };\n    eventCenter.emit(BRUSH_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [brushEndIndex, brushStartIndex, eventEmitterSymbol, syncId]);\n}","map":{"version":3,"names":["_excluded","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","_objectWithoutProperties","_objectWithoutPropertiesLoose","n","indexOf","propertyIsEnumerable","hasOwnProperty","useEffect","useAppDispatch","useAppSelector","selectEventEmitter","selectSyncId","selectSyncMethod","BRUSH_SYNC_EVENT","eventCenter","TOOLTIP_SYNC_EVENT","createEventEmitter","setSyncInteraction","selectTooltipDataKey","selectTooltipAxisTicks","selectSynchronisedTooltipState","useChartLayout","useViewBox","setDataStartEndIndexes","noop","useTooltipSyncEventsListener","mySyncId","myEventEmitter","dispatch","syncMethod","tooltipTicks","layout","viewBox","className","state","rootProps","listener","incomingSyncId","action","emitter","_action$payload","payload","coordinate","sourceViewBox","_action$payload$coord","x","_x","y","_y","otherCoordinateProps","sourceX","sourceY","width","sourceWidth","height","sourceHeight","scaledCoordinate","activeTick","syncMethodParam","activeTooltipIndex","index","undefined","isTooltipActive","active","activeIndex","activeLabel","label","activeDataKey","dataKey","activeCoordinate","find","tick","graphicalItemId","validateChartX","Math","min","validateChartY","syncAction","on","off","useBrushSyncEventsListener","useSynchronisedEventsFromOtherCharts","useTooltipChartSynchronisation","tooltipEventType","trigger","eventEmitterSymbol","syncId","tooltipState","isReceivingSynchronisation","emit","useBrushChartSynchronisation","brushStartIndex","chartData","dataStartIndex","brushEndIndex","dataEndIndex","startIndex","endIndex"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/synchronisation/useChartSynchronisation.js"],"sourcesContent":["var _excluded = [\"x\", \"y\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nimport { useEffect } from 'react';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { selectEventEmitter, selectSyncId, selectSyncMethod } from '../state/selectors/rootPropsSelectors';\nimport { BRUSH_SYNC_EVENT, eventCenter, TOOLTIP_SYNC_EVENT } from '../util/Events';\nimport { createEventEmitter } from '../state/optionsSlice';\nimport { setSyncInteraction } from '../state/tooltipSlice';\nimport { selectTooltipDataKey } from '../state/selectors/selectors';\nimport { selectTooltipAxisTicks } from '../state/selectors/tooltipSelectors';\nimport { selectSynchronisedTooltipState } from './syncSelectors';\nimport { useChartLayout, useViewBox } from '../context/chartLayoutContext';\nimport { setDataStartEndIndexes } from '../state/chartDataSlice';\nimport { noop } from '../util/DataUtils';\nfunction useTooltipSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipTicks = useAppSelector(selectTooltipAxisTicks);\n  var layout = useChartLayout();\n  var viewBox = useViewBox();\n  var className = useAppSelector(state => state.rootProps.className);\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n      if (mySyncId !== incomingSyncId) {\n        // This event is not for this chart\n        return;\n      }\n      if (syncMethod === 'index') {\n        var _action$payload;\n        if (viewBox && action !== null && action !== void 0 && (_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.coordinate && action.payload.sourceViewBox) {\n          var _action$payload$coord = action.payload.coordinate,\n            {\n              x: _x,\n              y: _y\n            } = _action$payload$coord,\n            otherCoordinateProps = _objectWithoutProperties(_action$payload$coord, _excluded);\n          var {\n            x: sourceX,\n            y: sourceY,\n            width: sourceWidth,\n            height: sourceHeight\n          } = action.payload.sourceViewBox;\n          var scaledCoordinate = _objectSpread(_objectSpread({}, otherCoordinateProps), {}, {\n            x: viewBox.x + (sourceWidth ? (_x - sourceX) / sourceWidth : 0) * viewBox.width,\n            y: viewBox.y + (sourceHeight ? (_y - sourceY) / sourceHeight : 0) * viewBox.height\n          });\n          dispatch(_objectSpread(_objectSpread({}, action), {}, {\n            payload: _objectSpread(_objectSpread({}, action.payload), {}, {\n              coordinate: scaledCoordinate\n            })\n          }));\n        } else {\n          dispatch(action);\n        }\n        return;\n      }\n      if (tooltipTicks == null) {\n        // for the other two sync methods, we need the ticks to be available\n        return;\n      }\n      var activeTick;\n      if (typeof syncMethod === 'function') {\n        /*\n         * This is what the data shape in 2.x CategoricalChartState used to look like.\n         * In 3.x we store things differently but let's try to keep the old shape for compatibility.\n         */\n        var syncMethodParam = {\n          activeTooltipIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          isTooltipActive: action.payload.active,\n          activeIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          activeLabel: action.payload.label,\n          activeDataKey: action.payload.dataKey,\n          activeCoordinate: action.payload.coordinate\n        };\n        // Call a callback function. If there is an application specific algorithm\n        var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);\n        activeTick = tooltipTicks[activeTooltipIndex];\n      } else if (syncMethod === 'value') {\n        // labels are always strings, tick.value might be a string or a number, depending on axis type\n        activeTick = tooltipTicks.find(tick => String(tick.value) === action.payload.label);\n      }\n      var {\n        coordinate\n      } = action.payload;\n      if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {\n        dispatch(setSyncInteraction({\n          active: false,\n          coordinate: undefined,\n          dataKey: undefined,\n          index: null,\n          label: undefined,\n          sourceViewBox: undefined,\n          graphicalItemId: undefined\n        }));\n        return;\n      }\n      var {\n        x,\n        y\n      } = coordinate;\n      var validateChartX = Math.min(x, viewBox.x + viewBox.width);\n      var validateChartY = Math.min(y, viewBox.y + viewBox.height);\n      var activeCoordinate = {\n        x: layout === 'horizontal' ? activeTick.coordinate : validateChartX,\n        y: layout === 'horizontal' ? validateChartY : activeTick.coordinate\n      };\n      var syncAction = setSyncInteraction({\n        active: action.payload.active,\n        coordinate: activeCoordinate,\n        dataKey: action.payload.dataKey,\n        index: String(activeTick.index),\n        label: action.payload.label,\n        sourceViewBox: action.payload.sourceViewBox,\n        graphicalItemId: action.payload.graphicalItemId\n      });\n      dispatch(syncAction);\n    };\n    eventCenter.on(TOOLTIP_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(TOOLTIP_SYNC_EVENT, listener);\n    };\n  }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);\n}\nfunction useBrushSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n      if (mySyncId === incomingSyncId) {\n        dispatch(setDataStartEndIndexes(action));\n      }\n    };\n    eventCenter.on(BRUSH_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(BRUSH_SYNC_EVENT, listener);\n    };\n  }, [dispatch, myEventEmitter, mySyncId]);\n}\n\n/**\n * Will receive synchronisation events from other charts.\n *\n * Reads syncMethod from state and decides how to synchronise the tooltip based on that.\n *\n * @returns void\n */\nexport function useSynchronisedEventsFromOtherCharts() {\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(createEventEmitter());\n  }, [dispatch]);\n  useTooltipSyncEventsListener();\n  useBrushSyncEventsListener();\n}\n\n/**\n * Will send events to other charts.\n * If syncId is undefined, no events will be sent.\n *\n * This ignores the syncMethod, because that is set and computed on the receiving end.\n *\n * @param tooltipEventType from Tooltip\n * @param trigger from Tooltip\n * @param activeCoordinate from state\n * @param activeLabel from state\n * @param activeIndex from state\n * @param isTooltipActive from state\n * @returns void\n */\nexport function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {\n  var activeDataKey = useAppSelector(state => selectTooltipDataKey(state, tooltipEventType, trigger));\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var syncId = useAppSelector(selectSyncId);\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipState = useAppSelector(selectSynchronisedTooltipState);\n  var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;\n  var viewBox = useViewBox();\n  useEffect(() => {\n    if (isReceivingSynchronisation) {\n      /*\n       * This chart currently has active tooltip, synchronised from another chart.\n       * Let's not send any outgoing synchronisation events while that's happening\n       * to avoid infinite loops.\n       */\n      return;\n    }\n    if (syncId == null) {\n      /*\n       * syncId is not set, means that this chart is not synchronised with any other chart,\n       * means we don't need to send synchronisation events\n       */\n      return;\n    }\n    if (eventEmitterSymbol == null) {\n      /*\n       * When using Recharts internal hooks and selectors outside charts context,\n       * these properties will be undefined. Let's return silently instead of throwing an error.\n       */\n      return;\n    }\n    var syncAction = setSyncInteraction({\n      active: isTooltipActive,\n      coordinate: activeCoordinate,\n      dataKey: activeDataKey,\n      index: activeIndex,\n      label: typeof activeLabel === 'number' ? String(activeLabel) : activeLabel,\n      sourceViewBox: viewBox,\n      graphicalItemId: undefined\n    });\n    eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive, viewBox]);\n}\nexport function useBrushChartSynchronisation() {\n  var syncId = useAppSelector(selectSyncId);\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var brushStartIndex = useAppSelector(state => state.chartData.dataStartIndex);\n  var brushEndIndex = useAppSelector(state => state.chartData.dataEndIndex);\n  useEffect(() => {\n    if (syncId == null || brushStartIndex == null || brushEndIndex == null || eventEmitterSymbol == null) {\n      return;\n    }\n    var syncAction = {\n      startIndex: brushStartIndex,\n      endIndex: brushEndIndex\n    };\n    eventCenter.emit(BRUSH_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [brushEndIndex, brushStartIndex, eventEmitterSymbol, syncId]);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}