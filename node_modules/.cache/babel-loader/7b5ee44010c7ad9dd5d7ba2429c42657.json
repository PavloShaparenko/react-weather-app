{"ast":null,"code":"import { MAX_VALUE_REG, MIN_VALUE_REG } from './ChartUtils';\nimport { isNumber } from './DataUtils';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function isWellFormedNumberDomain(v) {\n  if (Array.isArray(v) && v.length === 2) {\n    var [min, max] = v;\n\n    if (isWellBehavedNumber(min) && isWellBehavedNumber(max)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {\n  if (allowDataOverflow) {\n    // If the data are allowed to overflow - we're fine with whatever user provided\n    return providedDomain;\n  }\n  /*\n   * If the data are not allowed to overflow - we need to extend the domain.\n   * Means that effectively the user is allowed to make the domain larger\n   * but not smaller.\n   */\n\n\n  return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];\n}\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n *\n * This function does not accept data as an argument.\n * This is to enable a performance optimization - if the domain is there,\n * and we know what it is without traversing all the data,\n * then we don't have to traverse all the data!\n *\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param allowDataOverflow boolean, provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\n\nexport function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {\n  if (!allowDataOverflow) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n\n  if (typeof userDomain === 'function') {\n    // The user function expects the data to be provided as an argument\n    return undefined;\n  }\n\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n\n    if (isWellBehavedNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n\n    if (isWellBehavedNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n\n    var candidate = [finalMin, finalMax];\n\n    if (isWellFormedNumberDomain(candidate)) {\n      return candidate;\n    }\n  }\n\n  return undefined;\n}\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n * to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * You are probably thinking, why does domain need tick count?\n * Well it adjusts the domain based on where the \"nice ticks\" land, and nice ticks depend on the tick count.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param dataDomain calculated from data. Can be undefined, as an option for performance optimization\n * @param allowDataOverflow provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\n\nexport function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {\n  if (!allowDataOverflow && dataDomain == null) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n\n  if (typeof userDomain === 'function' && dataDomain != null) {\n    try {\n      var result = userDomain(dataDomain, allowDataOverflow);\n\n      if (isWellFormedNumberDomain(result)) {\n        return extendDomain(result, dataDomain, allowDataOverflow);\n      }\n    } catch (_unused) {\n      /* ignore the exception and compute domain from data later */\n    }\n  }\n\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n\n    if (providedMin === 'auto') {\n      if (dataDomain != null) {\n        finalMin = Math.min(...dataDomain);\n      }\n    } else if (isNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);\n        }\n      } catch (_unused2) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMin === 'string' && MIN_VALUE_REG.test(providedMin)) {\n      var match = MIN_VALUE_REG.exec(providedMin);\n\n      if (match == null || match[1] == null || dataDomain == null) {\n        finalMin = undefined;\n      } else {\n        var value = +match[1];\n        finalMin = dataDomain[0] - value;\n      }\n    } else {\n      finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];\n    }\n\n    if (providedMax === 'auto') {\n      if (dataDomain != null) {\n        finalMax = Math.max(...dataDomain);\n      }\n    } else if (isNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);\n        }\n      } catch (_unused3) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMax === 'string' && MAX_VALUE_REG.test(providedMax)) {\n      var _match = MAX_VALUE_REG.exec(providedMax);\n\n      if (_match == null || _match[1] == null || dataDomain == null) {\n        finalMax = undefined;\n      } else {\n        var _value = +_match[1];\n\n        finalMax = dataDomain[1] + _value;\n      }\n    } else {\n      finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];\n    }\n\n    var candidate = [finalMin, finalMax];\n\n    if (isWellFormedNumberDomain(candidate)) {\n      if (dataDomain == null) {\n        return candidate;\n      }\n\n      return extendDomain(candidate, dataDomain, allowDataOverflow);\n    }\n  }\n\n  return undefined;\n}","map":{"version":3,"names":["MAX_VALUE_REG","MIN_VALUE_REG","isNumber","isWellBehavedNumber","isWellFormedNumberDomain","v","Array","isArray","length","min","max","extendDomain","providedDomain","boundaryDomain","allowDataOverflow","Math","numericalDomainSpecifiedWithoutRequiringData","userDomain","undefined","providedMin","providedMax","finalMin","finalMax","candidate","parseNumericalUserDomain","dataDomain","result","_unused","_unused2","test","match","exec","value","_unused3","_match","_value"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/util/isDomainSpecifiedByUser.js"],"sourcesContent":["import { MAX_VALUE_REG, MIN_VALUE_REG } from './ChartUtils';\nimport { isNumber } from './DataUtils';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function isWellFormedNumberDomain(v) {\n  if (Array.isArray(v) && v.length === 2) {\n    var [min, max] = v;\n    if (isWellBehavedNumber(min) && isWellBehavedNumber(max)) {\n      return true;\n    }\n  }\n  return false;\n}\nexport function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {\n  if (allowDataOverflow) {\n    // If the data are allowed to overflow - we're fine with whatever user provided\n    return providedDomain;\n  }\n  /*\n   * If the data are not allowed to overflow - we need to extend the domain.\n   * Means that effectively the user is allowed to make the domain larger\n   * but not smaller.\n   */\n  return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];\n}\n\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n *\n * This function does not accept data as an argument.\n * This is to enable a performance optimization - if the domain is there,\n * and we know what it is without traversing all the data,\n * then we don't have to traverse all the data!\n *\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param allowDataOverflow boolean, provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\nexport function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {\n  if (!allowDataOverflow) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n  if (typeof userDomain === 'function') {\n    // The user function expects the data to be provided as an argument\n    return undefined;\n  }\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n    if (isWellBehavedNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n    if (isWellBehavedNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n    var candidate = [finalMin, finalMax];\n    if (isWellFormedNumberDomain(candidate)) {\n      return candidate;\n    }\n  }\n  return undefined;\n}\n\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n * to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * You are probably thinking, why does domain need tick count?\n * Well it adjusts the domain based on where the \"nice ticks\" land, and nice ticks depend on the tick count.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param dataDomain calculated from data. Can be undefined, as an option for performance optimization\n * @param allowDataOverflow provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\nexport function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {\n  if (!allowDataOverflow && dataDomain == null) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n  if (typeof userDomain === 'function' && dataDomain != null) {\n    try {\n      var result = userDomain(dataDomain, allowDataOverflow);\n      if (isWellFormedNumberDomain(result)) {\n        return extendDomain(result, dataDomain, allowDataOverflow);\n      }\n    } catch (_unused) {\n      /* ignore the exception and compute domain from data later */\n    }\n  }\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n    if (providedMin === 'auto') {\n      if (dataDomain != null) {\n        finalMin = Math.min(...dataDomain);\n      }\n    } else if (isNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);\n        }\n      } catch (_unused2) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMin === 'string' && MIN_VALUE_REG.test(providedMin)) {\n      var match = MIN_VALUE_REG.exec(providedMin);\n      if (match == null || match[1] == null || dataDomain == null) {\n        finalMin = undefined;\n      } else {\n        var value = +match[1];\n        finalMin = dataDomain[0] - value;\n      }\n    } else {\n      finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];\n    }\n    if (providedMax === 'auto') {\n      if (dataDomain != null) {\n        finalMax = Math.max(...dataDomain);\n      }\n    } else if (isNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);\n        }\n      } catch (_unused3) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMax === 'string' && MAX_VALUE_REG.test(providedMax)) {\n      var _match = MAX_VALUE_REG.exec(providedMax);\n      if (_match == null || _match[1] == null || dataDomain == null) {\n        finalMax = undefined;\n      } else {\n        var _value = +_match[1];\n        finalMax = dataDomain[1] + _value;\n      }\n    } else {\n      finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];\n    }\n    var candidate = [finalMin, finalMax];\n    if (isWellFormedNumberDomain(candidate)) {\n      if (dataDomain == null) {\n        return candidate;\n      }\n      return extendDomain(candidate, dataDomain, allowDataOverflow);\n    }\n  }\n  return undefined;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}