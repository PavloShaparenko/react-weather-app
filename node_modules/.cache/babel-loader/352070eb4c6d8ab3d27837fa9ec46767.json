{"ast":null,"code":"function ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n\n  return t;\n}\n\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === r ? String : Number)(t);\n}\n\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNotNil, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { getSliced } from './getSliced';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n\n  return defaultValue;\n}\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\n\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(minValue);\n  }\n\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n\n  return values;\n};\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\n\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n\n  if (!scale) {\n    return null;\n  }\n\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks set by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      var scaled = scale.map(scaleContent);\n\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scaled + offset,\n        value: entry,\n        offset,\n        index\n      };\n    }).filter(isNotNil);\n    return result;\n  } // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use Date as an index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\n\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n\n  return result;\n};\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\n\nexport var offsetSign = series => {\n  var _series$;\n\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  var m = (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.length;\n\n  if (m == null || m <= 0) {\n    return;\n  }\n\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n\n      if (col == null) {\n        continue;\n      }\n\n      var series1 = col[1];\n      var series0 = col[0];\n      var value = isNan(series1) ? series0 : series1;\n\n      if (value >= 0) {\n        col[0] = positive;\n        positive += value;\n        col[1] = positive;\n      } else {\n        col[0] = negative;\n        negative += value;\n        col[1] = negative;\n      }\n    }\n  }\n};\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\n\nexport var offsetPositive = series => {\n  var _series$2;\n\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  var m = (_series$2 = series[0]) === null || _series$2 === void 0 ? void 0 : _series$2.length;\n\n  if (m == null || m <= 0) {\n    return;\n  }\n\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n\n      if (col == null) {\n        continue;\n      }\n\n      var value = isNan(col[1]) ? col[0] : col[1];\n\n      if (value >= 0) {\n        col[0] = positive;\n        positive += value;\n        col[1] = positive;\n      } else {\n        col[0] = 0;\n        col[1] = 0;\n      }\n    }\n  }\n};\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var _STACK_OFFSET_MAP$off;\n\n  var offsetAccessor = (_STACK_OFFSET_MAP$off = STACK_OFFSET_MAP[offsetType]) !== null && _STACK_OFFSET_MAP$off !== void 0 ? _STACK_OFFSET_MAP$off : stackOffsetNone;\n  var stack = shapeStack().keys(dataKeys).value((d, key) => Number(getValueByDataKey(d, key, 0))).order(stackOrderNone) // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  var result = stack(data); // Post-process ranged data: if value is an array of two numbers, use them directly without stacking\n\n  result.forEach((series, seriesIndex) => {\n    series.forEach((point, pointIndex) => {\n      var value = getValueByDataKey(data[pointIndex], dataKeys[seriesIndex], 0);\n\n      if (Array.isArray(value) && value.length === 2 && isNumber(value[0]) && isNumber(value[1])) {\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[0] = value[0]; // eslint-disable-next-line prefer-destructuring,no-param-reassign\n\n        point[1] = value[1];\n      }\n    });\n  });\n  return result;\n};\n/**\n * Externally, we accept both strings and numbers as stack IDs\n * @inline\n */\n\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also, it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n\n    return ticks !== null && ticks !== void 0 && ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);\n  var scaled = axis.scale.map(value);\n\n  if (!isNumber(scaled)) {\n    return null;\n  }\n\n  return scaled;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  } // @ts-expect-error getValueByDataKey does not validate the output type\n\n\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n\n  if (isNullish(value)) {\n    return null;\n  }\n\n  var scaled = axis.scale.map(value);\n\n  if (!isNumber(scaled)) {\n    return null;\n  }\n\n  return scaled - bandSize / 2 + offset;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]); // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n\n    var maxValue = Math.max(domain[0], domain[1]);\n\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n\n    if (maxValue < 0) {\n      return maxValue;\n    }\n\n    return minValue;\n  }\n\n  return domain[0];\n};\n\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\n\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\n\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n\n    if (!group) {\n      return result;\n    }\n\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var sliced = getSliced(entry, startIndex, endIndex);\n      var s = getDomainOfSingle(sliced);\n\n      if (!isWellBehavedNumber(s[0]) || !isWellBehavedNumber(s[1])) {\n        return res;\n      }\n\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min(((cur === null || cur === void 0 ? void 0 : cur.coordinate) || 0) - ((prev === null || prev === void 0 ? void 0 : prev.coordinate) || 0), bandSize);\n    }\n\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n\n  return undefined;\n}\nexport var calculateCartesianTooltipPos = (coordinate, layout) => {\n  if (layout === 'horizontal') {\n    return coordinate.chartX;\n  }\n\n  if (layout === 'vertical') {\n    return coordinate.chartY;\n  }\n\n  return undefined;\n};\nexport var calculatePolarTooltipPos = (rangeObj, layout) => {\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n\n  return rangeObj.radius;\n};","map":{"version":3,"names":["ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","sortBy","get","stack","shapeStack","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","stackOrderNone","findEntryInArray","isNan","isNotNil","isNullish","isNumber","isNumOrStr","mathSign","getSliced","isWellBehavedNumber","getValueByDataKey","obj","dataKey","defaultValue","appendOffsetOfLegend","offset","legendSettings","legendSize","width","boxWidth","height","boxHeight","align","verticalAlign","layout","isCategoricalAxis","axisType","getCoordinatesOfGrid","ticks","minValue","maxValue","syncWithTicks","map","entry","coordinate","hasMin","hasMax","values","getTicksOfAxis","axis","isGrid","isAll","duplicateDomain","type","range","scale","realScaleType","isCategorical","categoricalDomain","tickCount","niceTicks","offsetForBand","bandwidth","result","index","scaleContent","indexOf","scaled","domain","truncateByDomain","Math","min","max","offsetSign","series","_series$","n","m","j","positive","negative","row","col","series1","series0","offsetPositive","_series$2","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","data","dataKeys","offsetType","_STACK_OFFSET_MAP$off","offsetAccessor","d","key","order","seriesIndex","point","pointIndex","Array","isArray","getNormalizedStackId","publicStackId","undefined","getCateCoordinateOfLine","_ref","bandSize","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref2","getBaseValueOfBar","_ref3","numericAxis","getDomainOfSingle","flat","makeDomainFinite","Infinity","getDomainOfStackGroups","stackGroups","startIndex","endIndex","reduce","stackId","group","stackedData","res","sliced","s","MIN_VALUE_REG","MAX_VALUE_REG","getBandSizeOfAxis","isBar","bandWidth","orderedTicks","len","cur","prev","getTooltipEntry","_ref4","tooltipEntrySettings","payload","name","getTooltipNameProp","nameFromItem","calculateCartesianTooltipPos","chartX","chartY","calculatePolarTooltipPos","rangeObj","angle","radius"],"sources":["C:/Users/HP/Desktop/react-projects/Project-weathe/Projekt/node_modules/recharts/es6/util/ChartUtils.js"],"sourcesContent":["function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNotNil, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { getSliced } from './getSliced';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(minValue);\n  }\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n  return values;\n};\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n  if (!scale) {\n    return null;\n  }\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      var scaled = scale.map(scaleContent);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scaled + offset,\n        value: entry,\n        offset,\n        index\n      };\n    }).filter(isNotNil);\n    return result;\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use Date as an index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\n\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n  return result;\n};\n\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetSign = series => {\n  var _series$;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var series1 = col[1];\n      var series0 = col[0];\n      var value = isNan(series1) ? series0 : series1;\n      if (value >= 0) {\n        col[0] = positive;\n        positive += value;\n        col[1] = positive;\n      } else {\n        col[0] = negative;\n        negative += value;\n        col[1] = negative;\n      }\n    }\n  }\n};\n\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetPositive = series => {\n  var _series$2;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$2 = series[0]) === null || _series$2 === void 0 ? void 0 : _series$2.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var value = isNan(col[1]) ? col[0] : col[1];\n      if (value >= 0) {\n        col[0] = positive;\n        positive += value;\n        col[1] = positive;\n      } else {\n        col[0] = 0;\n        col[1] = 0;\n      }\n    }\n  }\n};\n\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var _STACK_OFFSET_MAP$off;\n  var offsetAccessor = (_STACK_OFFSET_MAP$off = STACK_OFFSET_MAP[offsetType]) !== null && _STACK_OFFSET_MAP$off !== void 0 ? _STACK_OFFSET_MAP$off : stackOffsetNone;\n  var stack = shapeStack().keys(dataKeys).value((d, key) => Number(getValueByDataKey(d, key, 0))).order(stackOrderNone)\n  // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  var result = stack(data);\n\n  // Post-process ranged data: if value is an array of two numbers, use them directly without stacking\n  result.forEach((series, seriesIndex) => {\n    series.forEach((point, pointIndex) => {\n      var value = getValueByDataKey(data[pointIndex], dataKeys[seriesIndex], 0);\n      if (Array.isArray(value) && value.length === 2 && isNumber(value[0]) && isNumber(value[1])) {\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[0] = value[0];\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[1] = value[1];\n      }\n    });\n  });\n  return result;\n};\n\n/**\n * Externally, we accept both strings and numbers as stack IDs\n * @inline\n */\n\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also, it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks !== null && ticks !== void 0 && ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);\n  var scaled = axis.scale.map(value);\n  if (!isNumber(scaled)) {\n    return null;\n  }\n  return scaled;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  // @ts-expect-error getValueByDataKey does not validate the output type\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n  if (isNullish(value)) {\n    return null;\n  }\n  var scaled = axis.scale.map(value);\n  if (!isNumber(scaled)) {\n    return null;\n  }\n  return scaled - bandSize / 2 + offset;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]);\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var maxValue = Math.max(domain[0], domain[1]);\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n    if (maxValue < 0) {\n      return maxValue;\n    }\n    return minValue;\n  }\n  return domain[0];\n};\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n    if (!group) {\n      return result;\n    }\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var sliced = getSliced(entry, startIndex, endIndex);\n      var s = getDomainOfSingle(sliced);\n      if (!isWellBehavedNumber(s[0]) || !isWellBehavedNumber(s[1])) {\n        return res;\n      }\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min(((cur === null || cur === void 0 ? void 0 : cur.coordinate) || 0) - ((prev === null || prev === void 0 ? void 0 : prev.coordinate) || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n  return undefined;\n}\nexport var calculateCartesianTooltipPos = (coordinate, layout) => {\n  if (layout === 'horizontal') {\n    return coordinate.chartX;\n  }\n  if (layout === 'vertical') {\n    return coordinate.chartY;\n  }\n  return undefined;\n};\nexport var calculatePolarTooltipPos = (rangeObj, layout) => {\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n  return rangeObj.radius;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}